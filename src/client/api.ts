/* tslint:disable */
/* eslint-disable */
/**
 * ReRun API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { AxiosInstance, AxiosPromise, AxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
import type { Configuration } from './configuration'
// Some imports not used depending on template conditions
// @ts-ignore
import type { RequestArgs } from './base'
import {
  DUMMY_BASE_URL,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setOAuthToObject,
  setSearchParams,
  toPathString
} from './common'
// @ts-ignore
import { BASE_PATH, BaseAPI, COLLECTION_FORMATS, RequiredError } from './base'

/**
 *
 * @export
 * @interface AddSuitesToExperiencesInput
 */
export interface AddSuitesToExperiencesInput {
  /**
   *
   * @type {boolean}
   * @memberof AddSuitesToExperiencesInput
   */
  allExperiences?: boolean
  /**
   *
   * @type {Array<string>}
   * @memberof AddSuitesToExperiencesInput
   */
  experiences?: Array<string>
  /**
   *
   * @type {ExperienceFilterInput}
   * @memberof AddSuitesToExperiencesInput
   */
  filters?: ExperienceFilterInput
  /**
   *
   * @type {Array<string>}
   * @memberof AddSuitesToExperiencesInput
   */
  testSuiteIDs: Array<string>
}
/**
 *
 * @export
 * @interface AddTagsToExperiencesInput
 */
export interface AddTagsToExperiencesInput {
  /**
   *
   * @type {boolean}
   * @memberof AddTagsToExperiencesInput
   */
  allExperiences?: boolean
  /**
   *
   * @type {Array<string>}
   * @memberof AddTagsToExperiencesInput
   */
  experiences?: Array<string>
  /**
   *
   * @type {ExperienceFilterInput}
   * @memberof AddTagsToExperiencesInput
   */
  filters?: ExperienceFilterInput
  /**
   *
   * @type {Array<string>}
   * @memberof AddTagsToExperiencesInput
   */
  experienceTagIDs: Array<string>
}
/**
 *
 * @export
 * @interface Batch
 */
export interface Batch {
  /**
   *
   * @type {boolean}
   * @memberof Batch
   */
  adhocTestSuite?: boolean
  /**
   *
   * @type {string}
   * @memberof Batch
   */
  associatedAccount: string
  /**
   *
   * @type {string}
   * @memberof Batch
   */
  batchID?: string
  /**
   *
   * @type {string}
   * @memberof Batch
   */
  batchMetricsSetName?: string | null
  /**
   *
   * @type {MetricStatus}
   * @memberof Batch
   */
  batchMetricsStatus?: MetricStatus
  /**
   *
   * @type {BatchType}
   * @memberof Batch
   */
  batchType?: BatchType
  /**
   *
   * @type {string}
   * @memberof Batch
   */
  branchID?: string
  /**
   *
   * @type {string}
   * @memberof Batch
   */
  buildID?: string
  /**
   *
   * @type {string}
   * @memberof Batch
   */
  creationTimestamp?: string
  /**
   *
   * @type {string}
   * @memberof Batch
   */
  description?: string
  /**
   *
   * @type {ExecutionError}
   * @memberof Batch
   */
  executionError?: ExecutionError
  /**
   *
   * @type {Array<ExecutionError>}
   * @memberof Batch
   */
  executionErrors?: Array<ExecutionError> | null
  /**
   *
   * @type {string}
   * @memberof Batch
   */
  friendlyName?: string
  /**
   *
   * @type {string}
   * @memberof Batch
   */
  jobMetricsSetName?: string | null
  /**
   *
   * @type {JobMetricsStatusCounts}
   * @memberof Batch
   */
  jobMetricsStatusCounts?: JobMetricsStatusCounts
  /**
   *
   * @type {BatchJobStatusCounts}
   * @memberof Batch
   */
  jobStatusCounts?: BatchJobStatusCounts
  /**
   *
   * @type {MetricStatus}
   * @memberof Batch
   */
  jobsMetricsStatus?: MetricStatus
  /**
   *
   * @type {string}
   * @memberof Batch
   */
  lastUpdatedTimestamp?: string
  /**
   *
   * @type {string}
   * @memberof Batch
   */
  metricsBuildID?: string
  /**
   *
   * @type {string}
   * @memberof Batch
   */
  orgID?: string
  /**
   *
   * @type {MetricStatus}
   * @memberof Batch
   */
  overallMetricsStatus?: MetricStatus
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Batch
   */
  parameters?: { [key: string]: string }
  /**
   *
   * @type {Array<string>}
   * @memberof Batch
   */
  poolLabels?: Array<string>
  /**
   *
   * @type {string}
   * @memberof Batch
   */
  projectID?: string
  /**
   *
   * @type {BatchStatus}
   * @memberof Batch
   */
  status?: BatchStatus
  /**
   *
   * @type {Array<BatchStatusHistoryType>}
   * @memberof Batch
   */
  statusHistory?: Array<BatchStatusHistoryType>
  /**
   *
   * @type {string}
   * @memberof Batch
   */
  systemID?: string
  /**
   *
   * @type {string}
   * @memberof Batch
   */
  testSuiteID?: string
  /**
   *
   * @type {number}
   * @memberof Batch
   */
  testSuiteRevision?: number
  /**
   *
   * @type {number}
   * @memberof Batch
   */
  totalJobs?: number
  /**
   *
   * @type {string}
   * @memberof Batch
   */
  userID?: string
}

/**
 *
 * @export
 * @interface BatchInput
 */
export interface BatchInput {
  /**
   *
   * @type {number}
   * @memberof BatchInput
   */
  allowableFailurePercent?: number | null
  /**
   *
   * @type {string}
   * @memberof BatchInput
   */
  associatedAccount?: string
  /**
   *
   * @type {string}
   * @memberof BatchInput
   */
  batchMetricsSetName?: string | null
  /**
   *
   * @type {string}
   * @memberof BatchInput
   */
  batchName?: string
  /**
   *
   * @type {string}
   * @memberof BatchInput
   */
  buildID?: string
  /**
   *
   * @type {Array<string>}
   * @memberof BatchInput
   */
  excludedExperienceIDs?: Array<string> | null
  /**
   *
   * @type {Array<string>}
   * @memberof BatchInput
   */
  experienceIDs?: Array<string> | null
  /**
   *
   * @type {Array<string>}
   * @memberof BatchInput
   */
  experienceNames?: Array<string> | null
  /**
   *
   * @type {Array<string>}
   * @memberof BatchInput
   */
  experienceTagIDs?: Array<string> | null
  /**
   *
   * @type {Array<string>}
   * @memberof BatchInput
   */
  experienceTagNames?: Array<string> | null
  /**
   *
   * @type {ExperienceFilterInput}
   * @memberof BatchInput
   */
  filters?: ExperienceFilterInput
  /**
   *
   * @type {string}
   * @memberof BatchInput
   */
  jobMetricsSetName?: string | null
  /**
   *
   * @type {string}
   * @memberof BatchInput
   */
  metricsBuildID?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof BatchInput
   */
  parameters?: { [key: string]: string }
  /**
   *
   * @type {Array<string>}
   * @memberof BatchInput
   */
  poolLabels?: Array<string>
  /**
   *
   * @type {TriggeredVia}
   * @memberof BatchInput
   */
  triggeredVia?: TriggeredVia
}

/**
 *
 * @export
 * @interface BatchJobStatusCounts
 */
export interface BatchJobStatusCounts {
  /**
   *
   * @type {number}
   * @memberof BatchJobStatusCounts
   */
  cancelled: number
  /**
   *
   * @type {number}
   * @memberof BatchJobStatusCounts
   */
  error: number
  /**
   *
   * @type {number}
   * @memberof BatchJobStatusCounts
   */
  metricsQueued: number
  /**
   *
   * @type {number}
   * @memberof BatchJobStatusCounts
   */
  metricsRunning: number
  /**
   *
   * @type {number}
   * @memberof BatchJobStatusCounts
   */
  running: number
  /**
   *
   * @type {number}
   * @memberof BatchJobStatusCounts
   */
  submitted: number
  /**
   *
   * @type {number}
   * @memberof BatchJobStatusCounts
   */
  succeeded: number
}
/**
 *
 * @export
 * @interface BatchLog
 */
export interface BatchLog {
  /**
   *
   * @type {string}
   * @memberof BatchLog
   */
  checksum?: string
  /**
   *
   * @type {string}
   * @memberof BatchLog
   */
  creationTimestamp?: string
  /**
   *
   * @type {ExecutionStep}
   * @memberof BatchLog
   */
  executionStep?: ExecutionStep
  /**
   *
   * @type {string}
   * @memberof BatchLog
   */
  fileName?: string
  /**
   *
   * @type {number}
   * @memberof BatchLog
   */
  fileSize?: number
  /**
   *
   * @type {string}
   * @memberof BatchLog
   */
  location?: string
  /**
   *
   * @type {string}
   * @memberof BatchLog
   */
  logID?: string
  /**
   *
   * @type {string}
   * @memberof BatchLog
   */
  logOutputLocation?: string
  /**
   *
   * @type {LogType}
   * @memberof BatchLog
   */
  logType?: LogType
  /**
   *
   * @type {string}
   * @memberof BatchLog
   */
  orgID?: string
  /**
   *
   * @type {string}
   * @memberof BatchLog
   */
  userID?: string
  /**
   *
   * @type {string}
   * @memberof BatchLog
   */
  batchID?: string
}

/**
 *
 * @export
 * @interface BatchMetric
 */
export interface BatchMetric {
  /**
   *
   * @type {string}
   * @memberof BatchMetric
   */
  creationTimestamp?: string
  /**
   *
   * @type {Array<string>}
   * @memberof BatchMetric
   */
  dataIDs?: Array<string>
  /**
   * true if this metric is for an event
   * @type {boolean}
   * @memberof BatchMetric
   */
  eventMetric?: boolean
  /**
   *
   * @type {string}
   * @memberof BatchMetric
   */
  fileLocation?: string
  /**
   *
   * @type {string}
   * @memberof BatchMetric
   */
  metricID?: string
  /**
   *
   * @type {string}
   * @memberof BatchMetric
   */
  metricURL?: string
  /**
   *
   * @type {string}
   * @memberof BatchMetric
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof BatchMetric
   */
  orgID?: string
  /**
   *
   * @type {string}
   * @memberof BatchMetric
   */
  projectID?: string
  /**
   *
   * @type {MetricStatus}
   * @memberof BatchMetric
   */
  status?: MetricStatus
  /**
   *
   * @type {MetricType}
   * @memberof BatchMetric
   */
  type?: MetricType
  /**
   *
   * @type {string}
   * @memberof BatchMetric
   */
  unit?: string | null
  /**
   *
   * @type {string}
   * @memberof BatchMetric
   */
  userID?: string
  /**
   *
   * @type {number}
   * @memberof BatchMetric
   */
  value?: number | null
  /**
   *
   * @type {string}
   * @memberof BatchMetric
   */
  batchID?: string
}

/**
 *
 * @export
 * @interface BatchMetricsData
 */
export interface BatchMetricsData {
  /**
   *
   * @type {string}
   * @memberof BatchMetricsData
   */
  creationTimestamp?: string
  /**
   *
   * @type {string}
   * @memberof BatchMetricsData
   */
  dataID?: string
  /**
   *
   * @type {string}
   * @memberof BatchMetricsData
   */
  fileLocation?: string
  /**
   *
   * @type {string}
   * @memberof BatchMetricsData
   */
  filename?: string | null
  /**
   *
   * @type {MetricsDataType}
   * @memberof BatchMetricsData
   */
  metricsDataType?: MetricsDataType
  /**
   *
   * @type {string}
   * @memberof BatchMetricsData
   */
  metricsDataURL?: string
  /**
   *
   * @type {string}
   * @memberof BatchMetricsData
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof BatchMetricsData
   */
  orgID?: string
  /**
   *
   * @type {string}
   * @memberof BatchMetricsData
   */
  userID?: string
  /**
   *
   * @type {string}
   * @memberof BatchMetricsData
   */
  batchID?: string
}

/**
 *
 * @export
 * @interface BatchMetricsDataAndIDs
 */
export interface BatchMetricsDataAndIDs {
  /**
   *
   * @type {string}
   * @memberof BatchMetricsDataAndIDs
   */
  batchMetricID?: string
  /**
   *
   * @type {BatchMetricsData}
   * @memberof BatchMetricsDataAndIDs
   */
  batchMetricsData?: BatchMetricsData
}
/**
 *
 * @export
 * @enum {string}
 */

export const BatchStatus = {
  Submitted: 'SUBMITTED',
  ExperiencesRunning: 'EXPERIENCES_RUNNING',
  BatchMetricsQueued: 'BATCH_METRICS_QUEUED',
  BatchMetricsRunning: 'BATCH_METRICS_RUNNING',
  Error: 'ERROR',
  Succeeded: 'SUCCEEDED',
  Cancelled: 'CANCELLED'
} as const

export type BatchStatus = (typeof BatchStatus)[keyof typeof BatchStatus]

/**
 *
 * @export
 * @interface BatchStatusHistoryType
 */
export interface BatchStatusHistoryType {
  /**
   *
   * @type {BatchStatus}
   * @memberof BatchStatusHistoryType
   */
  status?: BatchStatus
  /**
   *
   * @type {string}
   * @memberof BatchStatusHistoryType
   */
  updatedAt?: string
}

/**
 *
 * @export
 * @enum {string}
 */

export const BatchType = {
  Normal: 'NORMAL',
  DebugExperience: 'DEBUG_EXPERIENCE'
} as const

export type BatchType = (typeof BatchType)[keyof typeof BatchType]

/**
 *
 * @export
 * @interface Branch
 */
export interface Branch {
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  branchID: string
  /**
   *
   * @type {BranchType}
   * @memberof Branch
   */
  branchType: BranchType
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  creationTimestamp: string
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  orgID: string
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  projectID: string
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  userID: string
}

/**
 *
 * @export
 * @enum {string}
 */

export const BranchType = {
  ChangeRequest: 'CHANGE_REQUEST',
  Main: 'MAIN',
  Release: 'RELEASE'
} as const

export type BranchType = (typeof BranchType)[keyof typeof BranchType]

/**
 *
 * @export
 * @interface Build
 */
export interface Build {
  /**
   *
   * @type {string}
   * @memberof Build
   */
  associatedAccount: string
  /**
   *
   * @type {string}
   * @memberof Build
   */
  branchID: string
  /**
   *
   * @type {string}
   * @memberof Build
   */
  buildID: string
  /**
   * Build spec in YAML format.
   * @type {string}
   * @memberof Build
   */
  buildSpecification: string
  /**
   *
   * @type {string}
   * @memberof Build
   */
  creationTimestamp: string
  /**
   * [DEPRECATED] This field was previously used to set the build\'s name. If both \'description\' and \'name\' are provided, \'name\' will take precedence. In a future version, this field will be repurposed to store the build\'s description.
   * @type {string}
   * @memberof Build
   * @deprecated
   */
  description: string
  /**
   *
   * @type {string}
   * @memberof Build
   */
  imageUri: string
  /**
   * [DEPRECATED] This field is temporarily being used to set the build\'s description. In a future version, the `description` field will be used instead.
   * @type {string}
   * @memberof Build
   * @deprecated
   */
  longDescription: string
  /**
   * The name of the build. This replaces the previous usage of \'description\'.
   * @type {string}
   * @memberof Build
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof Build
   */
  orgID: string
  /**
   *
   * @type {string}
   * @memberof Build
   */
  projectID: string
  /**
   *
   * @type {string}
   * @memberof Build
   */
  systemID: string
  /**
   *
   * @type {string}
   * @memberof Build
   */
  userID: string
  /**
   *
   * @type {string}
   * @memberof Build
   */
  version: string
}
/**
 *
 * @export
 * @interface CompareBatchTest
 */
export interface CompareBatchTest {
  /**
   *
   * @type {string}
   * @memberof CompareBatchTest
   */
  experienceID: string
  /**
   *
   * @type {string}
   * @memberof CompareBatchTest
   */
  experienceName: string
  /**
   *
   * @type {CompareBatchTestDetails}
   * @memberof CompareBatchTest
   */
  fromTest: CompareBatchTestDetails | null
  /**
   *
   * @type {CompareBatchTestDetails}
   * @memberof CompareBatchTest
   */
  toTest: CompareBatchTestDetails | null
}
/**
 *
 * @export
 * @interface CompareBatchTestDetails
 */
export interface CompareBatchTestDetails {
  /**
   *
   * @type {string}
   * @memberof CompareBatchTestDetails
   */
  jobID: string
  /**
   * The number of failblock/failwarn/passing metrics (based on job\'s status). Otherwise this will be null
   * @type {number}
   * @memberof CompareBatchTestDetails
   */
  numMetrics: number | null
  /**
   *
   * @type {ConflatedJobStatus}
   * @memberof CompareBatchTestDetails
   */
  status: ConflatedJobStatus
}

/**
 *
 * @export
 * @interface CompareBatchesOutput
 */
export interface CompareBatchesOutput {
  /**
   *
   * @type {string}
   * @memberof CompareBatchesOutput
   */
  nextPageToken: string
  /**
   *
   * @type {Array<CompareBatchTest>}
   * @memberof CompareBatchesOutput
   */
  tests: Array<CompareBatchTest>
  /**
   *
   * @type {number}
   * @memberof CompareBatchesOutput
   */
  total: number
}
/**
 *
 * @export
 * @enum {string}
 */

export const CompareBatchesStatusFilter = {
  BothPassing: 'BOTH_PASSING',
  BothFailing: 'BOTH_FAILING',
  OneFailing: 'ONE_FAILING'
} as const

export type CompareBatchesStatusFilter =
  (typeof CompareBatchesStatusFilter)[keyof typeof CompareBatchesStatusFilter]

/**
 *
 * @export
 * @enum {string}
 */

export const ConflatedJobStatus = {
  Queued: 'QUEUED',
  Running: 'RUNNING',
  Error: 'ERROR',
  Cancelled: 'CANCELLED',
  Blocker: 'BLOCKER',
  Warning: 'WARNING',
  Passed: 'PASSED'
} as const

export type ConflatedJobStatus =
  (typeof ConflatedJobStatus)[keyof typeof ConflatedJobStatus]

/**
 *
 * @export
 * @interface CreateBranchInput
 */
export interface CreateBranchInput {
  /**
   *
   * @type {BranchType}
   * @memberof CreateBranchInput
   */
  branchType: BranchType
  /**
   *
   * @type {string}
   * @memberof CreateBranchInput
   */
  name: string
}

/**
 *
 * @export
 * @interface CreateBuildForBranchInput
 */
export interface CreateBuildForBranchInput {
  /**
   *
   * @type {string}
   * @memberof CreateBuildForBranchInput
   */
  associatedAccount?: string
  /**
   *
   * @type {string}
   * @memberof CreateBuildForBranchInput
   */
  buildSpecification?: string
  /**
   * [DEPRECATED] This field was previously used to set the build\'s name. If both \'description\' and \'name\' are provided, \'name\' will take precedence. In a future version, this field will be repurposed to store the build\'s description.
   * @type {string}
   * @memberof CreateBuildForBranchInput
   * @deprecated
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof CreateBuildForBranchInput
   */
  imageUri?: string
  /**
   * [DEPRECATED] This field is temporarily being used to set the build\'s description. In a future version, the `description` field will be used instead.
   * @type {string}
   * @memberof CreateBuildForBranchInput
   * @deprecated
   */
  longDescription?: string
  /**
   * The name of the build. This replaces the previous usage of \'description\'.
   * @type {string}
   * @memberof CreateBuildForBranchInput
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CreateBuildForBranchInput
   */
  systemID: string
  /**
   *
   * @type {string}
   * @memberof CreateBuildForBranchInput
   */
  version: string
}
/**
 *
 * @export
 * @interface CreateBuildForSystemInput
 */
export interface CreateBuildForSystemInput {
  /**
   *
   * @type {string}
   * @memberof CreateBuildForSystemInput
   */
  associatedAccount?: string
  /**
   *
   * @type {string}
   * @memberof CreateBuildForSystemInput
   */
  branchID: string
  /**
   *
   * @type {string}
   * @memberof CreateBuildForSystemInput
   */
  buildSpecification?: string
  /**
   * [DEPRECATED] This field was previously used to set the build\'s name. If both \'description\' and \'name\' are provided, \'name\' will take precedence. In a future version, this field will be repurposed to store the build\'s description.
   * @type {string}
   * @memberof CreateBuildForSystemInput
   * @deprecated
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof CreateBuildForSystemInput
   */
  imageUri?: string
  /**
   * [DEPRECATED] This field is temporarily being used to set the build\'s description. In a future version, the `description` field will be used instead.
   * @type {string}
   * @memberof CreateBuildForSystemInput
   * @deprecated
   */
  longDescription?: string
  /**
   * The name of the build. This replaces the previous usage of \'description\'.
   * @type {string}
   * @memberof CreateBuildForSystemInput
   */
  name?: string
  /**
   *
   * @type {TriggeredVia}
   * @memberof CreateBuildForSystemInput
   */
  triggeredVia?: TriggeredVia
  /**
   *
   * @type {string}
   * @memberof CreateBuildForSystemInput
   */
  version: string
}
/**
 *
 * @export
 * @interface CreateExperienceInput
 */
export interface CreateExperienceInput {
  /**
   *
   * @type {number}
   * @memberof CreateExperienceInput
   */
  containerTimeoutSeconds?: number
  /**
   *
   * @type {string}
   * @memberof CreateExperienceInput
   */
  description: string
  /**
   *
   * @type {string}
   * @memberof CreateExperienceInput
   */
  location: string
  /**
   *
   * @type {string}
   * @memberof CreateExperienceInput
   */
  name: string
}
/**
 *
 * @export
 * @interface CreateExperienceTagInput
 */
export interface CreateExperienceTagInput {
  /**
   *
   * @type {string}
   * @memberof CreateExperienceTagInput
   */
  description: string
  /**
   *
   * @type {string}
   * @memberof CreateExperienceTagInput
   */
  name: string
}
/**
 *
 * @export
 * @interface CreateMetricsBuildInput
 */
export interface CreateMetricsBuildInput {
  /**
   *
   * @type {string}
   * @memberof CreateMetricsBuildInput
   */
  imageUri: string
  /**
   *
   * @type {string}
   * @memberof CreateMetricsBuildInput
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof CreateMetricsBuildInput
   */
  version: string
}
/**
 *
 * @export
 * @interface CreateProjectInput
 */
export interface CreateProjectInput {
  /**
   *
   * @type {string}
   * @memberof CreateProjectInput
   */
  description: string
  /**
   *
   * @type {string}
   * @memberof CreateProjectInput
   */
  name: string
}
/**
 *
 * @export
 * @interface CreateSystemInput
 */
export interface CreateSystemInput {
  /**
   *
   * @type {number}
   * @memberof CreateSystemInput
   */
  build_gpus: number
  /**
   *
   * @type {number}
   * @memberof CreateSystemInput
   */
  build_memory_mib: number
  /**
   *
   * @type {number}
   * @memberof CreateSystemInput
   */
  build_shared_memory_mb: number
  /**
   *
   * @type {number}
   * @memberof CreateSystemInput
   */
  build_vcpus: number
  /**
   *
   * @type {string}
   * @memberof CreateSystemInput
   */
  description: string
  /**
   *
   * @type {number}
   * @memberof CreateSystemInput
   */
  metrics_build_gpus: number
  /**
   *
   * @type {number}
   * @memberof CreateSystemInput
   */
  metrics_build_memory_mib: number
  /**
   *
   * @type {number}
   * @memberof CreateSystemInput
   */
  metrics_build_shared_memory_mb: number
  /**
   *
   * @type {number}
   * @memberof CreateSystemInput
   */
  metrics_build_vcpus: number
  /**
   *
   * @type {string}
   * @memberof CreateSystemInput
   */
  name: string
}
/**
 *
 * @export
 * @interface CreateTestSuiteInput
 */
export interface CreateTestSuiteInput {
  /**
   *
   * @type {boolean}
   * @memberof CreateTestSuiteInput
   */
  allExperiences?: boolean
  /**
   *
   * @type {string}
   * @memberof CreateTestSuiteInput
   */
  batchMetricsSetName?: string | null
  /**
   *
   * @type {string}
   * @memberof CreateTestSuiteInput
   */
  description: string
  /**
   *
   * @type {Array<string>}
   * @memberof CreateTestSuiteInput
   */
  excludedExperienceIDs?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof CreateTestSuiteInput
   */
  experiences: Array<string>
  /**
   *
   * @type {ExperienceFilterInput}
   * @memberof CreateTestSuiteInput
   */
  filters?: ExperienceFilterInput
  /**
   *
   * @type {string}
   * @memberof CreateTestSuiteInput
   */
  jobMetricsSetName?: string | null
  /**
   *
   * @type {string}
   * @memberof CreateTestSuiteInput
   */
  metricsBuildID?: string
  /**
   *
   * @type {string}
   * @memberof CreateTestSuiteInput
   */
  name: string
  /**
   *
   * @type {boolean}
   * @memberof CreateTestSuiteInput
   */
  showOnSummary?: boolean
  /**
   *
   * @type {string}
   * @memberof CreateTestSuiteInput
   */
  summaryReferenceDate?: string
  /**
   *
   * @type {string}
   * @memberof CreateTestSuiteInput
   */
  systemID: string
}
/**
 *
 * @export
 * @interface CustomMetric
 */
export interface CustomMetric {
  /**
   *
   * @type {string}
   * @memberof CustomMetric
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof CustomMetric
   */
  unit?: string
  /**
   *
   * @type {number}
   * @memberof CustomMetric
   */
  value: number
}
/**
 *
 * @export
 * @interface DebugExperienceInput
 */
export interface DebugExperienceInput {
  /**
   *
   * @type {string}
   * @memberof DebugExperienceInput
   */
  batchID?: string
  /**
   *
   * @type {string}
   * @memberof DebugExperienceInput
   */
  buildID?: string
  /**
   *
   * @type {Array<string>}
   * @memberof DebugExperienceInput
   */
  poolLabels?: Array<string>
  /**
   *
   * @type {string}
   * @memberof DebugExperienceInput
   */
  testSuiteID?: string
}
/**
 *
 * @export
 * @interface DebugExperienceOutput
 */
export interface DebugExperienceOutput {
  /**
   *
   * @type {string}
   * @memberof DebugExperienceOutput
   */
  batchID?: string
  /**
   *
   * @type {string}
   * @memberof DebugExperienceOutput
   */
  clusterCAData?: string
  /**
   *
   * @type {string}
   * @memberof DebugExperienceOutput
   */
  clusterEndpoint?: string
  /**
   *
   * @type {string}
   * @memberof DebugExperienceOutput
   */
  clusterToken?: string
  /**
   *
   * @type {string}
   * @memberof DebugExperienceOutput
   */
  namespace?: string
}
/**
 *
 * @export
 * @interface Event
 */
export interface Event {
  /**
   *
   * @type {string}
   * @memberof Event
   */
  creationTimestamp: string
  /**
   *
   * @type {string}
   * @memberof Event
   */
  description: string
  /**
   *
   * @type {string}
   * @memberof Event
   */
  eventID: string
  /**
   *
   * @type {Array<string>}
   * @memberof Event
   */
  metricsIDs: Array<string>
  /**
   *
   * @type {string}
   * @memberof Event
   */
  name: string
  /**
   *
   * @type {MetricStatus}
   * @memberof Event
   */
  status: MetricStatus
  /**
   *
   * @type {Array<string>}
   * @memberof Event
   */
  tags: Array<string>
  /**
   *
   * @type {string}
   * @memberof Event
   */
  timestamp: string
  /**
   *
   * @type {EventTimestampType}
   * @memberof Event
   */
  timestampType: EventTimestampType
}

/**
 *
 * @export
 * @enum {string}
 */

export const EventTimestampType = {
  Absolute: 'ABSOLUTE',
  Relative: 'RELATIVE'
} as const

export type EventTimestampType =
  (typeof EventTimestampType)[keyof typeof EventTimestampType]

/**
 *
 * @export
 * @interface ExecutionError
 */
export interface ExecutionError {
  /**
   * Standardized error code (e.g., UNKNOWN_ERROR, NONZERO_EXIT_CODE)
   * @type {string}
   * @memberof ExecutionError
   */
  errorCode: string
  /**
   * Error metadata
   * @type {object}
   * @memberof ExecutionError
   */
  metadata?: object
}
/**
 *
 * @export
 * @enum {string}
 */

export const ExecutionStep = {
  Experience: 'EXPERIENCE',
  Metrics: 'METRICS',
  BatchMetrics: 'BATCH_METRICS',
  Report: 'REPORT'
} as const

export type ExecutionStep = (typeof ExecutionStep)[keyof typeof ExecutionStep]

/**
 *
 * @export
 * @interface Experience
 */
export interface Experience {
  /**
   *
   * @type {number}
   * @memberof Experience
   */
  containerTimeoutSeconds: number
  /**
   *
   * @type {string}
   * @memberof Experience
   */
  creationTimestamp: string
  /**
   *
   * @type {string}
   * @memberof Experience
   */
  description: string
  /**
   *
   * @type {string}
   * @memberof Experience
   */
  experienceID: string
  /**
   *
   * @type {string}
   * @memberof Experience
   */
  location: string
  /**
   *
   * @type {string}
   * @memberof Experience
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof Experience
   */
  orgID: string
  /**
   *
   * @type {string}
   * @memberof Experience
   */
  projectID: string
  /**
   *
   * @type {string}
   * @memberof Experience
   */
  userID: string
}
/**
 *
 * @export
 * @interface ExperienceFilterInput
 */
export interface ExperienceFilterInput {
  /**
   * Filter experiences by name
   * @type {string}
   * @memberof ExperienceFilterInput
   */
  name?: string
  /**
   * A search query. Supports searching by tag_id
   * @type {string}
   * @memberof ExperienceFilterInput
   */
  search?: string
  /**
   * Filter experiences by a text string on name and description
   * @type {string}
   * @memberof ExperienceFilterInput
   */
  text?: string
}
/**
 *
 * @export
 * @interface ExperienceLocation
 */
export interface ExperienceLocation {
  /**
   *
   * @type {string}
   * @memberof ExperienceLocation
   */
  location?: string
}
/**
 *
 * @export
 * @interface ExperienceLocationContents
 */
export interface ExperienceLocationContents {
  /**
   *
   * @type {boolean}
   * @memberof ExperienceLocationContents
   */
  isCloud?: boolean
  /**
   *
   * @type {number}
   * @memberof ExperienceLocationContents
   */
  objectCount?: number
  /**
   *
   * @type {Array<string>}
   * @memberof ExperienceLocationContents
   */
  objects?: Array<string>
}
/**
 *
 * @export
 * @interface ExperienceTag
 */
export interface ExperienceTag {
  /**
   *
   * @type {string}
   * @memberof ExperienceTag
   */
  creationTimestamp: string
  /**
   *
   * @type {string}
   * @memberof ExperienceTag
   */
  description: string
  /**
   *
   * @type {string}
   * @memberof ExperienceTag
   */
  experienceTagID: string
  /**
   *
   * @type {string}
   * @memberof ExperienceTag
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof ExperienceTag
   */
  orgID: string
  /**
   *
   * @type {string}
   * @memberof ExperienceTag
   */
  projectID: string
  /**
   *
   * @type {string}
   * @memberof ExperienceTag
   */
  userID: string
}
/**
 * The first batch metric in the sequence, and some info about how it has changed
 * @export
 * @interface FirstBuildMetric
 */
export interface FirstBuildMetric {
  /**
   *
   * @type {number}
   * @memberof FirstBuildMetric
   */
  delta: number
  /**
   *
   * @type {string}
   * @memberof FirstBuildMetric
   */
  time: string
  /**
   *
   * @type {number}
   * @memberof FirstBuildMetric
   */
  value: number
}
/**
 *
 * @export
 * @interface GetQuotaOutput
 */
export interface GetQuotaOutput {
  /**
   *
   * @type {number}
   * @memberof GetQuotaOutput
   */
  availableTokens?: number
  /**
   *
   * @type {number}
   * @memberof GetQuotaOutput
   */
  maxTokens?: number
  /**
   *
   * @type {string}
   * @memberof GetQuotaOutput
   */
  orgID?: string
  /**
   *
   * @type {number}
   * @memberof GetQuotaOutput
   */
  secondsUntilRefresh?: number
}
/**
 *
 * @export
 * @interface Job
 */
export interface Job {
  /**
   *
   * @type {string}
   * @memberof Job
   */
  batchID?: string
  /**
   *
   * @type {string}
   * @memberof Job
   */
  branchID?: string
  /**
   *
   * @type {string}
   * @memberof Job
   */
  buildID?: string
  /**
   *
   * @type {ConflatedJobStatus}
   * @memberof Job
   */
  conflatedStatus?: ConflatedJobStatus
  /**
   *
   * @type {string}
   * @memberof Job
   */
  creationTimestamp?: string
  /**
   *
   * @type {string}
   * @memberof Job
   */
  description?: string
  /**
   *
   * @type {ExecutionError}
   * @memberof Job
   */
  executionError?: ExecutionError
  /**
   *
   * @type {Array<ExecutionError>}
   * @memberof Job
   */
  executionErrors?: Array<ExecutionError> | null
  /**
   *
   * @type {string}
   * @memberof Job
   */
  experienceID?: string
  /**
   *
   * @type {string}
   * @memberof Job
   */
  experienceName?: string
  /**
   *
   * @type {string}
   * @memberof Job
   */
  jobID?: string
  /**
   *
   * @type {MetricStatus}
   * @memberof Job
   */
  jobMetricsStatus?: MetricStatus
  /**
   *
   * @type {JobStatus}
   * @memberof Job
   */
  jobStatus?: JobStatus
  /**
   *
   * @type {string}
   * @memberof Job
   */
  lastUpdatedTimestamp?: string
  /**
   *
   * @type {string}
   * @memberof Job
   */
  orgID?: string
  /**
   *
   * @type {string}
   * @memberof Job
   */
  outputLocation?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Job
   */
  parameters?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof Job
   */
  projectID?: string
  /**
   *
   * @type {Array<JobStatusHistoryType>}
   * @memberof Job
   */
  statusHistory?: Array<JobStatusHistoryType>
  /**
   *
   * @type {string}
   * @memberof Job
   */
  systemID?: string
  /**
   *
   * @type {string}
   * @memberof Job
   */
  userID?: string
}

/**
 *
 * @export
 * @interface JobLog
 */
export interface JobLog {
  /**
   *
   * @type {string}
   * @memberof JobLog
   */
  checksum?: string
  /**
   *
   * @type {string}
   * @memberof JobLog
   */
  creationTimestamp?: string
  /**
   *
   * @type {ExecutionStep}
   * @memberof JobLog
   */
  executionStep?: ExecutionStep
  /**
   *
   * @type {string}
   * @memberof JobLog
   */
  fileName?: string
  /**
   *
   * @type {number}
   * @memberof JobLog
   */
  fileSize?: number
  /**
   *
   * @type {string}
   * @memberof JobLog
   */
  location?: string
  /**
   *
   * @type {string}
   * @memberof JobLog
   */
  logID?: string
  /**
   *
   * @type {string}
   * @memberof JobLog
   */
  logOutputLocation?: string
  /**
   *
   * @type {LogType}
   * @memberof JobLog
   */
  logType?: LogType
  /**
   *
   * @type {string}
   * @memberof JobLog
   */
  orgID?: string
  /**
   *
   * @type {string}
   * @memberof JobLog
   */
  userID?: string
  /**
   *
   * @type {string}
   * @memberof JobLog
   */
  jobID?: string
}

/**
 *
 * @export
 * @interface JobMetric
 */
export interface JobMetric {
  /**
   *
   * @type {string}
   * @memberof JobMetric
   */
  creationTimestamp?: string
  /**
   *
   * @type {Array<string>}
   * @memberof JobMetric
   */
  dataIDs?: Array<string>
  /**
   * true if this metric is for an event
   * @type {boolean}
   * @memberof JobMetric
   */
  eventMetric?: boolean
  /**
   *
   * @type {string}
   * @memberof JobMetric
   */
  fileLocation?: string
  /**
   *
   * @type {string}
   * @memberof JobMetric
   */
  metricID?: string
  /**
   *
   * @type {string}
   * @memberof JobMetric
   */
  metricURL?: string
  /**
   *
   * @type {string}
   * @memberof JobMetric
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof JobMetric
   */
  orgID?: string
  /**
   *
   * @type {string}
   * @memberof JobMetric
   */
  projectID?: string
  /**
   *
   * @type {MetricStatus}
   * @memberof JobMetric
   */
  status?: MetricStatus
  /**
   *
   * @type {MetricType}
   * @memberof JobMetric
   */
  type?: MetricType
  /**
   *
   * @type {string}
   * @memberof JobMetric
   */
  unit?: string | null
  /**
   *
   * @type {string}
   * @memberof JobMetric
   */
  userID?: string
  /**
   *
   * @type {number}
   * @memberof JobMetric
   */
  value?: number | null
  /**
   *
   * @type {string}
   * @memberof JobMetric
   */
  batchID?: string
  /**
   *
   * @type {string}
   * @memberof JobMetric
   */
  jobID?: string
}

/**
 *
 * @export
 * @interface JobMetricsData
 */
export interface JobMetricsData {
  /**
   *
   * @type {string}
   * @memberof JobMetricsData
   */
  creationTimestamp?: string
  /**
   *
   * @type {string}
   * @memberof JobMetricsData
   */
  dataID?: string
  /**
   *
   * @type {string}
   * @memberof JobMetricsData
   */
  fileLocation?: string
  /**
   *
   * @type {string}
   * @memberof JobMetricsData
   */
  filename?: string | null
  /**
   *
   * @type {MetricsDataType}
   * @memberof JobMetricsData
   */
  metricsDataType?: MetricsDataType
  /**
   *
   * @type {string}
   * @memberof JobMetricsData
   */
  metricsDataURL?: string
  /**
   *
   * @type {string}
   * @memberof JobMetricsData
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof JobMetricsData
   */
  orgID?: string
  /**
   *
   * @type {string}
   * @memberof JobMetricsData
   */
  userID?: string
  /**
   *
   * @type {string}
   * @memberof JobMetricsData
   */
  jobID?: string
}

/**
 *
 * @export
 * @interface JobMetricsStatusCounts
 */
export interface JobMetricsStatusCounts {
  /**
   *
   * @type {number}
   * @memberof JobMetricsStatusCounts
   */
  failBlock: number
  /**
   *
   * @type {number}
   * @memberof JobMetricsStatusCounts
   */
  failWarn: number
  /**
   *
   * @type {number}
   * @memberof JobMetricsStatusCounts
   */
  noStatusReported: number
  /**
   *
   * @type {number}
   * @memberof JobMetricsStatusCounts
   */
  notApplicable: number
  /**
   *
   * @type {number}
   * @memberof JobMetricsStatusCounts
   */
  passed: number
  /**
   *
   * @type {number}
   * @memberof JobMetricsStatusCounts
   */
  raw: number
}
/**
 *
 * @export
 * @enum {string}
 */

export const JobStatus = {
  Submitted: 'SUBMITTED',
  ExperienceRunning: 'EXPERIENCE_RUNNING',
  MetricsQueued: 'METRICS_QUEUED',
  MetricsRunning: 'METRICS_RUNNING',
  Error: 'ERROR',
  Succeeded: 'SUCCEEDED',
  Cancelled: 'CANCELLED'
} as const

export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus]

/**
 *
 * @export
 * @interface JobStatusHistoryType
 */
export interface JobStatusHistoryType {
  /**
   *
   * @type {JobStatus}
   * @memberof JobStatusHistoryType
   */
  status?: JobStatus
  /**
   *
   * @type {string}
   * @memberof JobStatusHistoryType
   */
  updatedAt?: string
}

/**
 *
 * @export
 * @interface KeyMetric
 */
export interface KeyMetric {
  /**
   *
   * @type {FirstBuildMetric}
   * @memberof KeyMetric
   */
  firstBuildMetric: FirstBuildMetric | null
  /**
   *
   * @type {number}
   * @memberof KeyMetric
   */
  latestValue: number
  /**
   *
   * @type {string}
   * @memberof KeyMetric
   */
  name: string
  /**
   *
   * @type {Array<KeyMetricPerformancePoint>}
   * @memberof KeyMetric
   */
  performance: Array<KeyMetricPerformancePoint>
  /**
   *
   * @type {KeyMetricTarget}
   * @memberof KeyMetric
   */
  target: KeyMetricTarget | null
  /**
   *
   * @type {string}
   * @memberof KeyMetric
   */
  unit: string | null
}
/**
 *
 * @export
 * @interface KeyMetricPerformancePoint
 */
export interface KeyMetricPerformancePoint {
  /**
   *
   * @type {string}
   * @memberof KeyMetricPerformancePoint
   */
  time: string
  /**
   *
   * @type {number}
   * @memberof KeyMetricPerformancePoint
   */
  value: number
}
/**
 * The optional desired target for this metric
 * @export
 * @interface KeyMetricTarget
 */
export interface KeyMetricTarget {
  /**
   *
   * @type {string}
   * @memberof KeyMetricTarget
   */
  operator: string
  /**
   *
   * @type {number}
   * @memberof KeyMetricTarget
   */
  value: number
}
/**
 *
 * @export
 * @interface ListAllJobsOutput
 */
export interface ListAllJobsOutput {
  /**
   *
   * @type {Array<Job>}
   * @memberof ListAllJobsOutput
   */
  jobs?: Array<Job>
  /**
   *
   * @type {string}
   * @memberof ListAllJobsOutput
   */
  nextPageToken?: string
  /**
   *
   * @type {number}
   * @memberof ListAllJobsOutput
   */
  total?: number
}
/**
 *
 * @export
 * @interface ListBatchLogsOutput
 */
export interface ListBatchLogsOutput {
  /**
   *
   * @type {Array<BatchLog>}
   * @memberof ListBatchLogsOutput
   */
  logs?: Array<BatchLog>
  /**
   *
   * @type {string}
   * @memberof ListBatchLogsOutput
   */
  nextPageToken?: string
}
/**
 *
 * @export
 * @interface ListBatchMetricsDataForBatchMetricIDsOutput
 */
export interface ListBatchMetricsDataForBatchMetricIDsOutput {
  /**
   *
   * @type {Array<BatchMetricsDataAndIDs>}
   * @memberof ListBatchMetricsDataForBatchMetricIDsOutput
   */
  batchMetricsDataAndIDs?: Array<BatchMetricsDataAndIDs>
  /**
   *
   * @type {string}
   * @memberof ListBatchMetricsDataForBatchMetricIDsOutput
   */
  nextPageToken?: string
}
/**
 *
 * @export
 * @interface ListBatchMetricsDataOutput
 */
export interface ListBatchMetricsDataOutput {
  /**
   *
   * @type {Array<BatchMetricsData>}
   * @memberof ListBatchMetricsDataOutput
   */
  batchMetricsData?: Array<BatchMetricsData>
  /**
   *
   * @type {string}
   * @memberof ListBatchMetricsDataOutput
   */
  nextPageToken?: string
}
/**
 *
 * @export
 * @interface ListBatchMetricsOutput
 */
export interface ListBatchMetricsOutput {
  /**
   *
   * @type {Array<BatchMetric>}
   * @memberof ListBatchMetricsOutput
   */
  batchMetrics?: Array<BatchMetric>
  /**
   *
   * @type {string}
   * @memberof ListBatchMetricsOutput
   */
  nextPageToken?: string
}
/**
 *
 * @export
 * @interface ListBatchesOutput
 */
export interface ListBatchesOutput {
  /**
   *
   * @type {Array<Batch>}
   * @memberof ListBatchesOutput
   */
  batches?: Array<Batch>
  /**
   *
   * @type {string}
   * @memberof ListBatchesOutput
   */
  nextPageToken?: string
  /**
   *
   * @type {number}
   * @memberof ListBatchesOutput
   */
  total?: number
}
/**
 *
 * @export
 * @interface ListBranchesOutput
 */
export interface ListBranchesOutput {
  /**
   *
   * @type {Array<Branch>}
   * @memberof ListBranchesOutput
   */
  branches?: Array<Branch>
  /**
   *
   * @type {string}
   * @memberof ListBranchesOutput
   */
  nextPageToken?: string
}
/**
 *
 * @export
 * @interface ListBuildsOutput
 */
export interface ListBuildsOutput {
  /**
   *
   * @type {Array<Build>}
   * @memberof ListBuildsOutput
   */
  builds: Array<Build>
  /**
   *
   * @type {string}
   * @memberof ListBuildsOutput
   */
  nextPageToken: string
  /**
   *
   * @type {number}
   * @memberof ListBuildsOutput
   */
  total: number
}
/**
 *
 * @export
 * @interface ListExperienceTagsOutput
 */
export interface ListExperienceTagsOutput {
  /**
   *
   * @type {Array<ExperienceTag>}
   * @memberof ListExperienceTagsOutput
   */
  experienceTags?: Array<ExperienceTag>
  /**
   *
   * @type {string}
   * @memberof ListExperienceTagsOutput
   */
  nextPageToken?: string
}
/**
 *
 * @export
 * @interface ListExperiencesOutput
 */
export interface ListExperiencesOutput {
  /**
   *
   * @type {Array<Experience>}
   * @memberof ListExperiencesOutput
   */
  experiences?: Array<Experience>
  /**
   *
   * @type {string}
   * @memberof ListExperiencesOutput
   */
  nextPageToken?: string
  /**
   *
   * @type {number}
   * @memberof ListExperiencesOutput
   */
  total?: number
}
/**
 *
 * @export
 * @interface ListJobEventsOutput
 */
export interface ListJobEventsOutput {
  /**
   *
   * @type {Array<Event>}
   * @memberof ListJobEventsOutput
   */
  events?: Array<Event>
  /**
   *
   * @type {string}
   * @memberof ListJobEventsOutput
   */
  nextPageToken?: string
}
/**
 *
 * @export
 * @interface ListJobLogsOutput
 */
export interface ListJobLogsOutput {
  /**
   *
   * @type {Array<JobLog>}
   * @memberof ListJobLogsOutput
   */
  logs?: Array<JobLog>
  /**
   *
   * @type {string}
   * @memberof ListJobLogsOutput
   */
  nextPageToken?: string
}
/**
 *
 * @export
 * @interface ListJobMetricsDataOutput
 */
export interface ListJobMetricsDataOutput {
  /**
   *
   * @type {Array<JobMetricsData>}
   * @memberof ListJobMetricsDataOutput
   */
  metricsData?: Array<JobMetricsData>
  /**
   *
   * @type {string}
   * @memberof ListJobMetricsDataOutput
   */
  nextPageToken?: string
}
/**
 *
 * @export
 * @interface ListJobMetricsOutput
 */
export interface ListJobMetricsOutput {
  /**
   *
   * @type {Array<JobMetric>}
   * @memberof ListJobMetricsOutput
   */
  metrics?: Array<JobMetric>
  /**
   *
   * @type {string}
   * @memberof ListJobMetricsOutput
   */
  nextPageToken?: string
}
/**
 *
 * @export
 * @interface ListJobsOutput
 */
export interface ListJobsOutput {
  /**
   *
   * @type {Array<Job>}
   * @memberof ListJobsOutput
   */
  jobs?: Array<Job>
  /**
   *
   * @type {string}
   * @memberof ListJobsOutput
   */
  nextPageToken?: string
  /**
   *
   * @type {number}
   * @memberof ListJobsOutput
   */
  total?: number
}
/**
 *
 * @export
 * @interface ListMetricsBuildOutput
 */
export interface ListMetricsBuildOutput {
  /**
   *
   * @type {Array<MetricsBuild>}
   * @memberof ListMetricsBuildOutput
   */
  metricsBuilds: Array<MetricsBuild>
  /**
   *
   * @type {string}
   * @memberof ListMetricsBuildOutput
   */
  nextPageToken: string
  /**
   *
   * @type {number}
   * @memberof ListMetricsBuildOutput
   */
  total: number
}
/**
 *
 * @export
 * @interface ListMetricsDataAndMetricIDOutput
 */
export interface ListMetricsDataAndMetricIDOutput {
  /**
   *
   * @type {Array<MetricsDataAndMetricID>}
   * @memberof ListMetricsDataAndMetricIDOutput
   */
  metricsDataAndIDs?: Array<MetricsDataAndMetricID>
  /**
   *
   * @type {string}
   * @memberof ListMetricsDataAndMetricIDOutput
   */
  nextPageToken?: string
}
/**
 *
 * @export
 * @interface ListParameterSweepsOutput
 */
export interface ListParameterSweepsOutput {
  /**
   *
   * @type {string}
   * @memberof ListParameterSweepsOutput
   */
  nextPageToken?: string
  /**
   *
   * @type {Array<ParameterSweep>}
   * @memberof ListParameterSweepsOutput
   */
  sweeps?: Array<ParameterSweep>
}
/**
 *
 * @export
 * @interface ListProjectsOutput
 */
export interface ListProjectsOutput {
  /**
   *
   * @type {string}
   * @memberof ListProjectsOutput
   */
  nextPageToken?: string
  /**
   *
   * @type {Array<Project>}
   * @memberof ListProjectsOutput
   */
  projects?: Array<Project>
}
/**
 *
 * @export
 * @interface ListReportLogsOutput
 */
export interface ListReportLogsOutput {
  /**
   *
   * @type {Array<ReportLog>}
   * @memberof ListReportLogsOutput
   */
  logs?: Array<ReportLog>
  /**
   *
   * @type {string}
   * @memberof ListReportLogsOutput
   */
  nextPageToken?: string
}
/**
 *
 * @export
 * @interface ListReportMetricsDataForReportMetricIDsOutput
 */
export interface ListReportMetricsDataForReportMetricIDsOutput {
  /**
   *
   * @type {string}
   * @memberof ListReportMetricsDataForReportMetricIDsOutput
   */
  nextPageToken?: string
  /**
   *
   * @type {Array<ReportMetricsDataAndIDs>}
   * @memberof ListReportMetricsDataForReportMetricIDsOutput
   */
  reportMetricsDataAndIDs?: Array<ReportMetricsDataAndIDs>
}
/**
 *
 * @export
 * @interface ListReportMetricsDataOutput
 */
export interface ListReportMetricsDataOutput {
  /**
   *
   * @type {string}
   * @memberof ListReportMetricsDataOutput
   */
  nextPageToken?: string
  /**
   *
   * @type {Array<MetricsData>}
   * @memberof ListReportMetricsDataOutput
   */
  reportMetricsData?: Array<MetricsData>
}
/**
 *
 * @export
 * @interface ListReportMetricsOutput
 */
export interface ListReportMetricsOutput {
  /**
   *
   * @type {string}
   * @memberof ListReportMetricsOutput
   */
  nextPageToken?: string
  /**
   *
   * @type {Array<Metric>}
   * @memberof ListReportMetricsOutput
   */
  reportMetrics?: Array<Metric>
}
/**
 *
 * @export
 * @interface ListReportsOutput
 */
export interface ListReportsOutput {
  /**
   *
   * @type {string}
   * @memberof ListReportsOutput
   */
  nextPageToken?: string
  /**
   *
   * @type {Array<Report>}
   * @memberof ListReportsOutput
   */
  reports?: Array<Report>
  /**
   *
   * @type {number}
   * @memberof ListReportsOutput
   */
  total?: number
}
/**
 *
 * @export
 * @interface ListSystemsOutput
 */
export interface ListSystemsOutput {
  /**
   *
   * @type {string}
   * @memberof ListSystemsOutput
   */
  nextPageToken?: string
  /**
   *
   * @type {Array<System>}
   * @memberof ListSystemsOutput
   */
  systems?: Array<System>
}
/**
 *
 * @export
 * @interface ListTagsForBatchMetricsOutput
 */
export interface ListTagsForBatchMetricsOutput {
  /**
   *
   * @type {string}
   * @memberof ListTagsForBatchMetricsOutput
   */
  nextPageToken?: string
  /**
   *
   * @type {Array<MetricTag>}
   * @memberof ListTagsForBatchMetricsOutput
   */
  tags?: Array<MetricTag>
}
/**
 *
 * @export
 * @interface ListTagsForJobMetricsOutput
 */
export interface ListTagsForJobMetricsOutput {
  /**
   *
   * @type {string}
   * @memberof ListTagsForJobMetricsOutput
   */
  nextPageToken?: string
  /**
   *
   * @type {Array<MetricTag>}
   * @memberof ListTagsForJobMetricsOutput
   */
  tags?: Array<MetricTag>
}
/**
 *
 * @export
 * @interface ListTagsForReportMetricsOutput
 */
export interface ListTagsForReportMetricsOutput {
  /**
   *
   * @type {string}
   * @memberof ListTagsForReportMetricsOutput
   */
  nextPageToken?: string
  /**
   *
   * @type {Array<MetricTag>}
   * @memberof ListTagsForReportMetricsOutput
   */
  tags?: Array<MetricTag>
}
/**
 *
 * @export
 * @interface ListTestSuiteOutput
 */
export interface ListTestSuiteOutput {
  /**
   *
   * @type {string}
   * @memberof ListTestSuiteOutput
   */
  nextPageToken: string
  /**
   *
   * @type {Array<TestSuite>}
   * @memberof ListTestSuiteOutput
   */
  testSuites: Array<TestSuite>
  /**
   *
   * @type {number}
   * @memberof ListTestSuiteOutput
   */
  total: number
}
/**
 *
 * @export
 * @interface ListTestSuiteRevisionsOutput
 */
export interface ListTestSuiteRevisionsOutput {
  /**
   *
   * @type {string}
   * @memberof ListTestSuiteRevisionsOutput
   */
  nextPageToken?: string
  /**
   *
   * @type {Array<TestSuite>}
   * @memberof ListTestSuiteRevisionsOutput
   */
  testSuites?: Array<TestSuite>
}
/**
 *
 * @export
 * @interface ListViewObjectsOutput
 */
export interface ListViewObjectsOutput {
  /**
   *
   * @type {string}
   * @memberof ListViewObjectsOutput
   */
  nextPageToken?: string
  /**
   *
   * @type {Array<ViewObject>}
   * @memberof ListViewObjectsOutput
   */
  viewSessions?: Array<ViewObject>
}
/**
 *
 * @export
 * @interface Log
 */
export interface Log {
  /**
   *
   * @type {string}
   * @memberof Log
   */
  checksum?: string
  /**
   *
   * @type {string}
   * @memberof Log
   */
  creationTimestamp?: string
  /**
   *
   * @type {ExecutionStep}
   * @memberof Log
   */
  executionStep?: ExecutionStep
  /**
   *
   * @type {string}
   * @memberof Log
   */
  fileName?: string
  /**
   *
   * @type {number}
   * @memberof Log
   */
  fileSize?: number
  /**
   *
   * @type {string}
   * @memberof Log
   */
  location?: string
  /**
   *
   * @type {string}
   * @memberof Log
   */
  logID?: string
  /**
   *
   * @type {string}
   * @memberof Log
   */
  logOutputLocation?: string
  /**
   *
   * @type {LogType}
   * @memberof Log
   */
  logType?: LogType
  /**
   *
   * @type {string}
   * @memberof Log
   */
  orgID?: string
  /**
   *
   * @type {string}
   * @memberof Log
   */
  userID?: string
}

/**
 *
 * @export
 * @enum {string}
 */

export const LogType = {
  OtherLog: 'OTHER_LOG',
  MetricsOutputLog: 'METRICS_OUTPUT_LOG',
  ContainerLog: 'CONTAINER_LOG',
  ExecutionLog: 'EXECUTION_LOG',
  McapLog: 'MCAP_LOG',
  Mp4Log: 'MP4_LOG',
  ArchiveLog: 'ARCHIVE_LOG',
  FoxgloveMcapLog: 'FOXGLOVE_MCAP_LOG',
  RerunIoLog: 'RERUN_IO_LOG',
  ErrorLog: 'ERROR_LOG',
  ServiceLog: 'SERVICE_LOG',
  EmissionsLog: 'EMISSIONS_LOG'
} as const

export type LogType = (typeof LogType)[keyof typeof LogType]

/**
 *
 * @export
 * @interface Metric
 */
export interface Metric {
  /**
   *
   * @type {string}
   * @memberof Metric
   */
  creationTimestamp?: string
  /**
   *
   * @type {Array<string>}
   * @memberof Metric
   */
  dataIDs?: Array<string>
  /**
   * true if this metric is for an event
   * @type {boolean}
   * @memberof Metric
   */
  eventMetric?: boolean
  /**
   *
   * @type {string}
   * @memberof Metric
   */
  fileLocation?: string
  /**
   *
   * @type {string}
   * @memberof Metric
   */
  metricID?: string
  /**
   *
   * @type {string}
   * @memberof Metric
   */
  metricURL?: string
  /**
   *
   * @type {string}
   * @memberof Metric
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof Metric
   */
  orgID?: string
  /**
   *
   * @type {string}
   * @memberof Metric
   */
  projectID?: string
  /**
   *
   * @type {MetricStatus}
   * @memberof Metric
   */
  status?: MetricStatus
  /**
   *
   * @type {MetricType}
   * @memberof Metric
   */
  type?: MetricType
  /**
   *
   * @type {string}
   * @memberof Metric
   */
  unit?: string | null
  /**
   *
   * @type {string}
   * @memberof Metric
   */
  userID?: string
  /**
   *
   * @type {number}
   * @memberof Metric
   */
  value?: number | null
}

/**
 *
 * @export
 * @enum {string}
 */

export const MetricStatus = {
  Passed: 'PASSED',
  FailWarn: 'FAIL_WARN',
  Raw: 'RAW',
  NotApplicable: 'NOT_APPLICABLE',
  FailBlock: 'FAIL_BLOCK',
  NoStatusReported: 'NO_STATUS_REPORTED'
} as const

export type MetricStatus = (typeof MetricStatus)[keyof typeof MetricStatus]

/**
 *
 * @export
 * @interface MetricTag
 */
export interface MetricTag {
  /**
   *
   * @type {string}
   * @memberof MetricTag
   */
  creationTimestamp: string
  /**
   *
   * @type {string}
   * @memberof MetricTag
   */
  metricID?: string
  /**
   *
   * @type {string}
   * @memberof MetricTag
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof MetricTag
   */
  tagID: string
  /**
   *
   * @type {string}
   * @memberof MetricTag
   */
  value: string
}
/**
 *
 * @export
 * @enum {string}
 */

export const MetricType = {
  Scalar: 'SCALAR',
  Composite: 'COMPOSITE'
} as const

export type MetricType = (typeof MetricType)[keyof typeof MetricType]

/**
 *
 * @export
 * @interface MetricsBuild
 */
export interface MetricsBuild {
  /**
   *
   * @type {string}
   * @memberof MetricsBuild
   */
  creationTimestamp: string
  /**
   *
   * @type {string}
   * @memberof MetricsBuild
   */
  imageUri: string
  /**
   *
   * @type {string}
   * @memberof MetricsBuild
   */
  metricsBuildID: string
  /**
   *
   * @type {string}
   * @memberof MetricsBuild
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof MetricsBuild
   */
  orgID: string
  /**
   *
   * @type {string}
   * @memberof MetricsBuild
   */
  projectID: string
  /**
   *
   * @type {string}
   * @memberof MetricsBuild
   */
  userID: string
  /**
   *
   * @type {string}
   * @memberof MetricsBuild
   */
  version: string
}
/**
 *
 * @export
 * @interface MetricsData
 */
export interface MetricsData {
  /**
   *
   * @type {string}
   * @memberof MetricsData
   */
  creationTimestamp?: string
  /**
   *
   * @type {string}
   * @memberof MetricsData
   */
  dataID?: string
  /**
   *
   * @type {string}
   * @memberof MetricsData
   */
  fileLocation?: string
  /**
   *
   * @type {string}
   * @memberof MetricsData
   */
  filename?: string | null
  /**
   *
   * @type {MetricsDataType}
   * @memberof MetricsData
   */
  metricsDataType?: MetricsDataType
  /**
   *
   * @type {string}
   * @memberof MetricsData
   */
  metricsDataURL?: string
  /**
   *
   * @type {string}
   * @memberof MetricsData
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof MetricsData
   */
  orgID?: string
  /**
   *
   * @type {string}
   * @memberof MetricsData
   */
  userID?: string
}

/**
 *
 * @export
 * @interface MetricsDataAndMetricID
 */
export interface MetricsDataAndMetricID {
  /**
   *
   * @type {string}
   * @memberof MetricsDataAndMetricID
   */
  metricID?: string
  /**
   *
   * @type {JobMetricsData}
   * @memberof MetricsDataAndMetricID
   */
  metricsData?: JobMetricsData
}
/**
 *
 * @export
 * @enum {string}
 */

export const MetricsDataType = {
  Standard: 'STANDARD',
  ExternalFile: 'EXTERNAL_FILE'
} as const

export type MetricsDataType =
  (typeof MetricsDataType)[keyof typeof MetricsDataType]

/**
 *
 * @export
 * @interface MutateSystemsToExperienceInput
 */
export interface MutateSystemsToExperienceInput {
  /**
   *
   * @type {boolean}
   * @memberof MutateSystemsToExperienceInput
   */
  allExperiences?: boolean
  /**
   *
   * @type {Array<string>}
   * @memberof MutateSystemsToExperienceInput
   */
  experiences?: Array<string>
  /**
   *
   * @type {ExperienceFilterInput}
   * @memberof MutateSystemsToExperienceInput
   */
  filters?: ExperienceFilterInput
  /**
   *
   * @type {Array<string>}
   * @memberof MutateSystemsToExperienceInput
   */
  systemIDs: Array<string>
}
/**
 *
 * @export
 * @enum {string}
 */

export const ObjectType = {
  Frame: 'TYPE_FRAME',
  Se3: 'TYPE_SE3',
  So3: 'TYPE_SO3',
  DcurveSe3: 'TYPE_DCURVE_SE3',
  TcurveSe3: 'TYPE_TCURVE_SE3',
  Trajectory: 'TYPE_TRAJECTORY',
  FramedVector: 'TYPE_FRAMED_VECTOR'
} as const

export type ObjectType = (typeof ObjectType)[keyof typeof ObjectType]

/**
 *
 * @export
 * @interface ParameterSweep
 */
export interface ParameterSweep {
  /**
   *
   * @type {string}
   * @memberof ParameterSweep
   */
  associatedAccount: string
  /**
   *
   * @type {Array<string>}
   * @memberof ParameterSweep
   */
  batches?: Array<string>
  /**
   *
   * @type {string}
   * @memberof ParameterSweep
   */
  creationTimestamp?: string
  /**
   *
   * @type {string}
   * @memberof ParameterSweep
   */
  lastUpdatedTimestamp?: string
  /**
   *
   * @type {string}
   * @memberof ParameterSweep
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof ParameterSweep
   */
  orgID?: string
  /**
   *
   * @type {string}
   * @memberof ParameterSweep
   */
  parameterSweepID?: string
  /**
   *
   * @type {Array<SweepParameter>}
   * @memberof ParameterSweep
   */
  parameters?: Array<SweepParameter>
  /**
   *
   * @type {string}
   * @memberof ParameterSweep
   */
  projectID?: string
  /**
   *
   * @type {ParameterSweepStatus}
   * @memberof ParameterSweep
   */
  status?: ParameterSweepStatus
  /**
   *
   * @type {Array<ParameterSweepStatusHistoryType>}
   * @memberof ParameterSweep
   */
  statusHistory?: Array<ParameterSweepStatusHistoryType>
  /**
   *
   * @type {string}
   * @memberof ParameterSweep
   */
  userID?: string
}

/**
 *
 * @export
 * @interface ParameterSweepInput
 */
export interface ParameterSweepInput {
  /**
   *
   * @type {number}
   * @memberof ParameterSweepInput
   */
  allowableFailurePercent?: number | null
  /**
   *
   * @type {string}
   * @memberof ParameterSweepInput
   */
  associatedAccount?: string
  /**
   *
   * @type {string}
   * @memberof ParameterSweepInput
   */
  buildID?: string
  /**
   *
   * @type {Array<string>}
   * @memberof ParameterSweepInput
   */
  experienceIDs?: Array<string> | null
  /**
   *
   * @type {Array<string>}
   * @memberof ParameterSweepInput
   */
  experienceNames?: Array<string> | null
  /**
   *
   * @type {Array<string>}
   * @memberof ParameterSweepInput
   */
  experienceTagIDs?: Array<string> | null
  /**
   *
   * @type {Array<string>}
   * @memberof ParameterSweepInput
   */
  experienceTagNames?: Array<string> | null
  /**
   *
   * @type {string}
   * @memberof ParameterSweepInput
   */
  metricsBuildID?: string
  /**
   *
   * @type {Array<SweepParameter>}
   * @memberof ParameterSweepInput
   */
  parameters?: Array<SweepParameter>
  /**
   *
   * @type {Array<string>}
   * @memberof ParameterSweepInput
   */
  poolLabels?: Array<string>
  /**
   *
   * @type {TriggeredVia}
   * @memberof ParameterSweepInput
   */
  triggeredVia?: TriggeredVia
}

/**
 *
 * @export
 * @enum {string}
 */

export const ParameterSweepStatus = {
  Submitted: 'SUBMITTED',
  Running: 'RUNNING',
  Succeeded: 'SUCCEEDED',
  Error: 'ERROR',
  Cancelled: 'CANCELLED'
} as const

export type ParameterSweepStatus =
  (typeof ParameterSweepStatus)[keyof typeof ParameterSweepStatus]

/**
 *
 * @export
 * @interface ParameterSweepStatusHistoryType
 */
export interface ParameterSweepStatusHistoryType {
  /**
   *
   * @type {ParameterSweepStatus}
   * @memberof ParameterSweepStatusHistoryType
   */
  status?: ParameterSweepStatus
  /**
   *
   * @type {string}
   * @memberof ParameterSweepStatusHistoryType
   */
  updatedAt?: string
}

/**
 *
 * @export
 * @interface Project
 */
export interface Project {
  /**
   *
   * @type {boolean}
   * @memberof Project
   */
  archived: boolean
  /**
   *
   * @type {string}
   * @memberof Project
   */
  creationTimestamp: string
  /**
   *
   * @type {string}
   * @memberof Project
   */
  description: string
  /**
   *
   * @type {string}
   * @memberof Project
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof Project
   */
  orgID: string
  /**
   *
   * @type {string}
   * @memberof Project
   */
  projectID: string
  /**
   *
   * @type {string}
   * @memberof Project
   */
  userID: string
}
/**
 *
 * @export
 * @interface ReferenceBatchSummary
 */
export interface ReferenceBatchSummary {
  /**
   *
   * @type {number}
   * @memberof ReferenceBatchSummary
   */
  fixedTests: number
  /**
   *
   * @type {number}
   * @memberof ReferenceBatchSummary
   */
  newIssues: number
  /**
   *
   * @type {number}
   * @memberof ReferenceBatchSummary
   */
  newTests: number
}
/**
 *
 * @export
 * @interface Report
 */
export interface Report {
  /**
   *
   * @type {string}
   * @memberof Report
   */
  associatedAccount: string
  /**
   *
   * @type {string}
   * @memberof Report
   */
  branchID: string
  /**
   *
   * @type {string}
   * @memberof Report
   */
  creationTimestamp: string
  /**
   *
   * @type {string}
   * @memberof Report
   */
  endTimestamp: string
  /**
   *
   * @type {string}
   * @memberof Report
   */
  lastUpdatedTimestamp: string
  /**
   *
   * @type {string}
   * @memberof Report
   */
  metricsBuildID: string
  /**
   *
   * @type {MetricStatus}
   * @memberof Report
   */
  metricsStatus: MetricStatus
  /**
   *
   * @type {string}
   * @memberof Report
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof Report
   */
  orgID: string
  /**
   *
   * @type {string}
   * @memberof Report
   */
  outputLocation: string
  /**
   *
   * @type {string}
   * @memberof Report
   */
  projectID: string
  /**
   *
   * @type {string}
   * @memberof Report
   */
  reportID: string
  /**
   *
   * @type {boolean}
   * @memberof Report
   */
  respectRevisionBoundary: boolean
  /**
   *
   * @type {string}
   * @memberof Report
   */
  startTimestamp: string
  /**
   *
   * @type {ReportStatus}
   * @memberof Report
   */
  status: ReportStatus
  /**
   *
   * @type {Array<ReportStatusHistoryType>}
   * @memberof Report
   */
  statusHistory: Array<ReportStatusHistoryType>
  /**
   *
   * @type {string}
   * @memberof Report
   */
  testSuiteID: string
  /**
   *
   * @type {number}
   * @memberof Report
   */
  testSuiteRevision: number
  /**
   *
   * @type {TriggeredVia}
   * @memberof Report
   */
  triggeredVia?: TriggeredVia
  /**
   *
   * @type {string}
   * @memberof Report
   */
  userID: string
}

/**
 *
 * @export
 * @interface ReportInput
 */
export interface ReportInput {
  /**
   *
   * @type {string}
   * @memberof ReportInput
   */
  associatedAccount?: string
  /**
   *
   * @type {string}
   * @memberof ReportInput
   */
  branchID: string
  /**
   *
   * @type {string}
   * @memberof ReportInput
   */
  endTimestamp?: string
  /**
   *
   * @type {string}
   * @memberof ReportInput
   */
  metricsBuildID: string
  /**
   *
   * @type {string}
   * @memberof ReportInput
   */
  name?: string
  /**
   *
   * @type {Array<string>}
   * @memberof ReportInput
   */
  poolLabels?: Array<string>
  /**
   *
   * @type {boolean}
   * @memberof ReportInput
   */
  respectRevisionBoundary?: boolean
  /**
   *
   * @type {string}
   * @memberof ReportInput
   */
  startTimestamp: string
  /**
   *
   * @type {string}
   * @memberof ReportInput
   */
  testSuiteID: string
  /**
   *
   * @type {number}
   * @memberof ReportInput
   */
  testSuiteRevision?: number
  /**
   *
   * @type {TriggeredVia}
   * @memberof ReportInput
   */
  triggeredVia?: TriggeredVia
}

/**
 *
 * @export
 * @interface ReportLog
 */
export interface ReportLog {
  /**
   *
   * @type {string}
   * @memberof ReportLog
   */
  checksum: string
  /**
   *
   * @type {string}
   * @memberof ReportLog
   */
  creationTimestamp: string
  /**
   *
   * @type {string}
   * @memberof ReportLog
   */
  fileName: string
  /**
   *
   * @type {number}
   * @memberof ReportLog
   */
  fileSize: number
  /**
   *
   * @type {string}
   * @memberof ReportLog
   */
  location: string
  /**
   *
   * @type {string}
   * @memberof ReportLog
   */
  logID: string
  /**
   *
   * @type {string}
   * @memberof ReportLog
   */
  logOutputLocation: string
  /**
   *
   * @type {LogType}
   * @memberof ReportLog
   */
  logType: LogType
  /**
   *
   * @type {string}
   * @memberof ReportLog
   */
  orgID: string
  /**
   *
   * @type {string}
   * @memberof ReportLog
   */
  userID: string
}

/**
 *
 * @export
 * @interface ReportMetricsDataAndIDs
 */
export interface ReportMetricsDataAndIDs {
  /**
   *
   * @type {string}
   * @memberof ReportMetricsDataAndIDs
   */
  reportMetricID?: string
  /**
   *
   * @type {MetricsData}
   * @memberof ReportMetricsDataAndIDs
   */
  reportMetricsData?: MetricsData
}
/**
 *
 * @export
 * @interface ReportMetricsDataToReportMetric
 */
export interface ReportMetricsDataToReportMetric {
  /**
   *
   * @type {string}
   * @memberof ReportMetricsDataToReportMetric
   */
  reportMetricID?: string
  /**
   *
   * @type {Array<string>}
   * @memberof ReportMetricsDataToReportMetric
   */
  reportMetricsDataIDs?: Array<string>
}
/**
 *
 * @export
 * @enum {string}
 */

export const ReportStatus = {
  Submitted: 'SUBMITTED',
  Running: 'RUNNING',
  Error: 'ERROR',
  Succeeded: 'SUCCEEDED'
} as const

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]

/**
 *
 * @export
 * @interface ReportStatusHistoryType
 */
export interface ReportStatusHistoryType {
  /**
   *
   * @type {ReportStatus}
   * @memberof ReportStatusHistoryType
   */
  status?: ReportStatus
  /**
   *
   * @type {string}
   * @memberof ReportStatusHistoryType
   */
  updatedAt?: string
}

/**
 *
 * @export
 * @interface ReviseTestSuiteInput
 */
export interface ReviseTestSuiteInput {
  /**
   *
   * @type {boolean}
   * @memberof ReviseTestSuiteInput
   */
  adhoc?: boolean
  /**
   *
   * @type {boolean}
   * @memberof ReviseTestSuiteInput
   */
  allExperiences?: boolean
  /**
   *
   * @type {string}
   * @memberof ReviseTestSuiteInput
   */
  batchMetricsSetName?: string | null
  /**
   *
   * @type {string}
   * @memberof ReviseTestSuiteInput
   */
  description?: string
  /**
   *
   * @type {Array<string>}
   * @memberof ReviseTestSuiteInput
   */
  excludedExperienceIDs?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof ReviseTestSuiteInput
   */
  experiences?: Array<string>
  /**
   *
   * @type {ExperienceFilterInput}
   * @memberof ReviseTestSuiteInput
   */
  filters?: ExperienceFilterInput
  /**
   *
   * @type {string}
   * @memberof ReviseTestSuiteInput
   */
  jobMetricsSetName?: string | null
  /**
   *
   * @type {string}
   * @memberof ReviseTestSuiteInput
   */
  metricsBuildID?: string
  /**
   *
   * @type {string}
   * @memberof ReviseTestSuiteInput
   */
  name?: string
  /**
   *
   * @type {boolean}
   * @memberof ReviseTestSuiteInput
   */
  show_on_summary?: boolean
  /**
   *
   * @type {string}
   * @memberof ReviseTestSuiteInput
   */
  systemID?: string
  /**
   *
   * @type {boolean}
   * @memberof ReviseTestSuiteInput
   */
  updateMetricsBuild: boolean
}
/**
 *
 * @export
 * @interface SelectExperiencesInput
 */
export interface SelectExperiencesInput {
  /**
   *
   * @type {boolean}
   * @memberof SelectExperiencesInput
   */
  allExperiences?: boolean
  /**
   *
   * @type {Array<string>}
   * @memberof SelectExperiencesInput
   */
  experiences?: Array<string>
  /**
   *
   * @type {ExperienceFilterInput}
   * @memberof SelectExperiencesInput
   */
  filters?: ExperienceFilterInput
}
/**
 *
 * @export
 * @interface SweepParameter
 */
export interface SweepParameter {
  /**
   *
   * @type {string}
   * @memberof SweepParameter
   */
  name?: string
  /**
   *
   * @type {Array<string>}
   * @memberof SweepParameter
   */
  values?: Array<string>
}
/**
 *
 * @export
 * @interface System
 */
export interface System {
  /**
   *
   * @type {boolean}
   * @memberof System
   */
  archived: boolean
  /**
   *
   * @type {number}
   * @memberof System
   */
  build_gpus: number
  /**
   *
   * @type {number}
   * @memberof System
   */
  build_memory_mib: number
  /**
   *
   * @type {number}
   * @memberof System
   */
  build_shared_memory_mb: number
  /**
   *
   * @type {number}
   * @memberof System
   */
  build_vcpus: number
  /**
   *
   * @type {string}
   * @memberof System
   */
  creationTimestamp: string
  /**
   *
   * @type {string}
   * @memberof System
   */
  description: string
  /**
   *
   * @type {number}
   * @memberof System
   */
  metrics_build_gpus: number
  /**
   *
   * @type {number}
   * @memberof System
   */
  metrics_build_memory_mib: number
  /**
   *
   * @type {number}
   * @memberof System
   */
  metrics_build_shared_memory_mb: number
  /**
   *
   * @type {number}
   * @memberof System
   */
  metrics_build_vcpus: number
  /**
   *
   * @type {string}
   * @memberof System
   */
  name: string
  /**
   *
   * @type {number}
   * @memberof System
   */
  numBatches: number
  /**
   *
   * @type {number}
   * @memberof System
   */
  numBuilds: number
  /**
   *
   * @type {number}
   * @memberof System
   */
  numExperiences: number
  /**
   *
   * @type {number}
   * @memberof System
   */
  numMetricsBuilds: number
  /**
   *
   * @type {number}
   * @memberof System
   */
  numTestSuites: number
  /**
   *
   * @type {string}
   * @memberof System
   */
  orgID: string
  /**
   *
   * @type {string}
   * @memberof System
   */
  projectID: string
  /**
   *
   * @type {string}
   * @memberof System
   */
  systemID: string
  /**
   *
   * @type {string}
   * @memberof System
   */
  userID: string
}
/**
 *
 * @export
 * @interface TestSuite
 */
export interface TestSuite {
  /**
   *
   * @type {string}
   * @memberof TestSuite
   */
  batchMetricsSetName?: string | null
  /**
   *
   * @type {string}
   * @memberof TestSuite
   */
  creationTimestamp: string
  /**
   *
   * @type {string}
   * @memberof TestSuite
   */
  description: string
  /**
   *
   * @type {Array<string>}
   * @memberof TestSuite
   */
  experiences: Array<string>
  /**
   *
   * @type {string}
   * @memberof TestSuite
   */
  jobMetricsSetName?: string | null
  /**
   *
   * @type {string}
   * @memberof TestSuite
   */
  metricsBuildID?: string
  /**
   *
   * @type {string}
   * @memberof TestSuite
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof TestSuite
   */
  orgID: string
  /**
   *
   * @type {string}
   * @memberof TestSuite
   */
  projectID: string
  /**
   *
   * @type {boolean}
   * @memberof TestSuite
   */
  showOnSummary: boolean
  /**
   *
   * @type {string}
   * @memberof TestSuite
   */
  summaryReferenceDate?: string
  /**
   *
   * @type {string}
   * @memberof TestSuite
   */
  systemID: string
  /**
   *
   * @type {string}
   * @memberof TestSuite
   */
  testSuiteID: string
  /**
   *
   * @type {number}
   * @memberof TestSuite
   */
  testSuiteRevision: number
  /**
   *
   * @type {string}
   * @memberof TestSuite
   */
  userID: string
}
/**
 *
 * @export
 * @interface TestSuiteBatchInput
 */
export interface TestSuiteBatchInput {
  /**
   *
   * @type {number}
   * @memberof TestSuiteBatchInput
   */
  allowableFailurePercent?: number | null
  /**
   *
   * @type {string}
   * @memberof TestSuiteBatchInput
   */
  associatedAccount?: string
  /**
   *
   * @type {string}
   * @memberof TestSuiteBatchInput
   */
  batchName?: string
  /**
   *
   * @type {string}
   * @memberof TestSuiteBatchInput
   */
  buildID: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof TestSuiteBatchInput
   */
  parameters?: { [key: string]: string }
  /**
   *
   * @type {Array<string>}
   * @memberof TestSuiteBatchInput
   */
  poolLabels?: Array<string>
  /**
   *
   * @type {TriggeredVia}
   * @memberof TestSuiteBatchInput
   */
  triggeredVia?: TriggeredVia
}

/**
 *
 * @export
 * @interface TestSuiteBatchSummaryJobResults
 */
export interface TestSuiteBatchSummaryJobResults {
  /**
   *
   * @type {string}
   * @memberof TestSuiteBatchSummaryJobResults
   */
  batchCreationTimestamp: string
  /**
   *
   * @type {string}
   * @memberof TestSuiteBatchSummaryJobResults
   */
  batchID: string
  /**
   *
   * @type {number}
   * @memberof TestSuiteBatchSummaryJobResults
   */
  blocker: number
  /**
   *
   * @type {string}
   * @memberof TestSuiteBatchSummaryJobResults
   */
  buildCreationTimestamp: string
  /**
   *
   * @type {string}
   * @memberof TestSuiteBatchSummaryJobResults
   */
  buildID: string
  /**
   *
   * @type {number}
   * @memberof TestSuiteBatchSummaryJobResults
   */
  cancelled: number
  /**
   *
   * @type {number}
   * @memberof TestSuiteBatchSummaryJobResults
   */
  error: number
  /**
   *
   * @type {Array<CustomMetric>}
   * @memberof TestSuiteBatchSummaryJobResults
   */
  metrics: Array<CustomMetric>
  /**
   *
   * @type {number}
   * @memberof TestSuiteBatchSummaryJobResults
   */
  passed: number
  /**
   *
   * @type {number}
   * @memberof TestSuiteBatchSummaryJobResults
   */
  queued: number
  /**
   *
   * @type {number}
   * @memberof TestSuiteBatchSummaryJobResults
   */
  running: number
  /**
   *
   * @type {number}
   * @memberof TestSuiteBatchSummaryJobResults
   */
  total: number
  /**
   *
   * @type {number}
   * @memberof TestSuiteBatchSummaryJobResults
   */
  warning: number
}
/**
 *
 * @export
 * @interface TestSuiteSummary
 */
export interface TestSuiteSummary {
  /**
   *
   * @type {Array<TestSuiteBatchSummaryJobResults>}
   * @memberof TestSuiteSummary
   */
  batches: Array<TestSuiteBatchSummaryJobResults>
  /**
   *
   * @type {string}
   * @memberof TestSuiteSummary
   */
  branchID: string
  /**
   *
   * @type {KeyMetric}
   * @memberof TestSuiteSummary
   */
  keyMetric: KeyMetric | null
  /**
   *
   * @type {string}
   * @memberof TestSuiteSummary
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof TestSuiteSummary
   */
  projectID: string
  /**
   *
   * @type {TestSuiteBatchSummaryJobResults}
   * @memberof TestSuiteSummary
   */
  referenceBatch?: TestSuiteBatchSummaryJobResults
  /**
   *
   * @type {ReferenceBatchSummary}
   * @memberof TestSuiteSummary
   */
  referenceBatchSummary: ReferenceBatchSummary | null
  /**
   *
   * @type {string}
   * @memberof TestSuiteSummary
   */
  reportID: string
  /**
   *
   * @type {TestSuiteSummarySummary}
   * @memberof TestSuiteSummary
   */
  summary: TestSuiteSummarySummary
  /**
   *
   * @type {string}
   * @memberof TestSuiteSummary
   */
  systemID: string
  /**
   *
   * @type {string}
   * @memberof TestSuiteSummary
   */
  testSuiteDescription: string
  /**
   *
   * @type {string}
   * @memberof TestSuiteSummary
   */
  testSuiteID: string
  /**
   *
   * @type {number}
   * @memberof TestSuiteSummary
   */
  testSuiteRevision: number
}
/**
 *
 * @export
 * @interface TestSuiteSummaryOutput
 */
export interface TestSuiteSummaryOutput {
  /**
   *
   * @type {string}
   * @memberof TestSuiteSummaryOutput
   */
  nextPageToken: string
  /**
   *
   * @type {Array<TestSuiteSummary>}
   * @memberof TestSuiteSummaryOutput
   */
  testSuites: Array<TestSuiteSummary>
}
/**
 *
 * @export
 * @interface TestSuiteSummarySummary
 */
export interface TestSuiteSummarySummary {
  /**
   *
   * @type {number}
   * @memberof TestSuiteSummarySummary
   */
  fixedTests: number
  /**
   *
   * @type {number}
   * @memberof TestSuiteSummarySummary
   */
  newIssues: number
  /**
   *
   * @type {number}
   * @memberof TestSuiteSummarySummary
   */
  newTests: number
}
/**
 *
 * @export
 * @enum {string}
 */

export const TriggeredVia = {
  Local: 'LOCAL',
  Webapp: 'WEBAPP',
  Gitlab: 'GITLAB',
  Github: 'GITHUB'
} as const

export type TriggeredVia = (typeof TriggeredVia)[keyof typeof TriggeredVia]

/**
 *
 * @export
 * @interface UpdateBatchInput
 */
export interface UpdateBatchInput {
  /**
   *
   * @type {string}
   * @memberof UpdateBatchInput
   */
  description: string
}
/**
 *
 * @export
 * @interface UpdateBuildFields
 */
export interface UpdateBuildFields {
  /**
   *
   * @type {string}
   * @memberof UpdateBuildFields
   */
  branchID?: string
  /**
   * [DEPRECATED] This field was previously used to set the build\'s name. If both \'description\' and \'name\' are provided, \'name\' will take precedence. In a future version, this field will be repurposed to store the build\'s description.
   * @type {string}
   * @memberof UpdateBuildFields
   * @deprecated
   */
  description?: string
  /**
   * [DEPRECATED] This field is temporarily being used to set the build\'s description. In a future version, the `description` field will be used instead.
   * @type {string}
   * @memberof UpdateBuildFields
   * @deprecated
   */
  longDescription?: string
  /**
   * The name of the build. This replaces the previous usage of \'description\'.
   * @type {string}
   * @memberof UpdateBuildFields
   */
  name?: string
}
/**
 *
 * @export
 * @interface UpdateBuildInput
 */
export interface UpdateBuildInput {
  /**
   *
   * @type {UpdateBuildFields}
   * @memberof UpdateBuildInput
   */
  build?: UpdateBuildFields
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateBuildInput
   */
  updateMask?: Array<string>
}
/**
 *
 * @export
 * @interface UpdateEventInput
 */
export interface UpdateEventInput {
  /**
   *
   * @type {string}
   * @memberof UpdateEventInput
   */
  description: string
}
/**
 *
 * @export
 * @interface UpdateExperienceFields
 */
export interface UpdateExperienceFields {
  /**
   *
   * @type {number}
   * @memberof UpdateExperienceFields
   */
  containerTimeoutSeconds?: number
  /**
   *
   * @type {string}
   * @memberof UpdateExperienceFields
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof UpdateExperienceFields
   */
  location?: string
  /**
   *
   * @type {string}
   * @memberof UpdateExperienceFields
   */
  name?: string
}
/**
 *
 * @export
 * @interface UpdateExperienceInput
 */
export interface UpdateExperienceInput {
  /**
   *
   * @type {UpdateExperienceFields}
   * @memberof UpdateExperienceInput
   */
  experience?: UpdateExperienceFields
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateExperienceInput
   */
  updateMask?: Array<string>
}
/**
 *
 * @export
 * @interface UpdateExperienceTagFields
 */
export interface UpdateExperienceTagFields {
  /**
   *
   * @type {string}
   * @memberof UpdateExperienceTagFields
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof UpdateExperienceTagFields
   */
  name?: string
}
/**
 *
 * @export
 * @interface UpdateExperienceTagInput
 */
export interface UpdateExperienceTagInput {
  /**
   *
   * @type {UpdateExperienceTagFields}
   * @memberof UpdateExperienceTagInput
   */
  experienceTag?: UpdateExperienceTagFields
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateExperienceTagInput
   */
  updateMask?: Array<string>
}
/**
 *
 * @export
 * @interface UpdateJobInput
 */
export interface UpdateJobInput {
  /**
   *
   * @type {string}
   * @memberof UpdateJobInput
   */
  description: string
}
/**
 *
 * @export
 * @interface UpdateProjectFields
 */
export interface UpdateProjectFields {
  /**
   *
   * @type {string}
   * @memberof UpdateProjectFields
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof UpdateProjectFields
   */
  name?: string
}
/**
 *
 * @export
 * @interface UpdateProjectInput
 */
export interface UpdateProjectInput {
  /**
   *
   * @type {UpdateProjectFields}
   * @memberof UpdateProjectInput
   */
  project?: UpdateProjectFields
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateProjectInput
   */
  updateMask?: Array<string>
}
/**
 *
 * @export
 * @interface UpdateSystemInput
 */
export interface UpdateSystemInput {
  /**
   *
   * @type {number}
   * @memberof UpdateSystemInput
   */
  build_gpus?: number
  /**
   *
   * @type {number}
   * @memberof UpdateSystemInput
   */
  build_memory_mib?: number
  /**
   *
   * @type {number}
   * @memberof UpdateSystemInput
   */
  build_shared_memory_mb?: number
  /**
   *
   * @type {number}
   * @memberof UpdateSystemInput
   */
  build_vcpus?: number
  /**
   *
   * @type {string}
   * @memberof UpdateSystemInput
   */
  description?: string
  /**
   *
   * @type {number}
   * @memberof UpdateSystemInput
   */
  metrics_build_gpus?: number
  /**
   *
   * @type {number}
   * @memberof UpdateSystemInput
   */
  metrics_build_memory_mib?: number
  /**
   *
   * @type {number}
   * @memberof UpdateSystemInput
   */
  metrics_build_shared_memory_mb?: number
  /**
   *
   * @type {number}
   * @memberof UpdateSystemInput
   */
  metrics_build_vcpus?: number
  /**
   *
   * @type {string}
   * @memberof UpdateSystemInput
   */
  name?: string
}
/**
 *
 * @export
 * @interface ViewMetadata
 */
export interface ViewMetadata {
  /**
   *
   * @type {string}
   * @memberof ViewMetadata
   */
  fileName?: string
  /**
   *
   * @type {number}
   * @memberof ViewMetadata
   */
  lineNumber?: number
  /**
   *
   * @type {string}
   * @memberof ViewMetadata
   */
  objectName?: string
  /**
   *
   * @type {ObjectType}
   * @memberof ViewMetadata
   */
  objectType?: ObjectType
}

/**
 *
 * @export
 * @interface ViewObject
 */
export interface ViewObject {
  /**
   *
   * @type {string}
   * @memberof ViewObject
   */
  friendlyName?: string
  /**
   *
   * @type {string}
   * @memberof ViewObject
   */
  mcapURL?: string
  /**
   *
   * @type {number}
   * @memberof ViewObject
   */
  objectCount?: number
  /**
   *
   * @type {string}
   * @memberof ViewObject
   */
  orgID?: string
  /**
   *
   * @type {string}
   * @memberof ViewObject
   */
  userID?: string
  /**
   *
   * @type {string}
   * @memberof ViewObject
   */
  viewSessionID?: string
  /**
   *
   * @type {string}
   * @memberof ViewObject
   */
  viewTimestamp?: string
  /**
   *
   * @type {string}
   * @memberof ViewObject
   */
  viewURL?: string
}
/**
 *
 * @export
 * @interface ViewObjectAndMetadata
 */
export interface ViewObjectAndMetadata {
  /**
   *
   * @type {Array<ViewMetadata>}
   * @memberof ViewObjectAndMetadata
   */
  viewMetadata?: Array<ViewMetadata>
  /**
   *
   * @type {ViewObject}
   * @memberof ViewObjectAndMetadata
   */
  viewObject?: ViewObject
}
/**
 *
 * @export
 * @interface ViewSessionUpdate
 */
export interface ViewSessionUpdate {
  /**
   *
   * @type {string}
   * @memberof ViewSessionUpdate
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof ViewSessionUpdate
   */
  mcap?: string
  /**
   * A link to view the session.
   * @type {string}
   * @memberof ViewSessionUpdate
   */
  view?: string
}

/**
 * BatchesApi - axios parameter creator
 * @export
 */
export const BatchesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Cancels a batch.
     * @param {string} projectID
     * @param {string} batchID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelBatch: async (
      projectID: string,
      batchID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('cancelBatch', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('cancelBatch', 'batchID', batchID)
      const localVarPath = `/projects/{projectID}/batches/{batchID}/:cancel`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Get a summary describing how individual tests have changed between the two given batches. A warning or a blocking failure is considered failing from the point of view of filters and ordering.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} otherBatchID the batch to compare to
     * @param {CompareBatchesStatusFilter} [status] filter tests by their status
     * @param {string} [search] filter tests by their name
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    compareBatches: async (
      projectID: string,
      batchID: string,
      otherBatchID: string,
      status?: CompareBatchesStatusFilter,
      search?: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('compareBatches', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('compareBatches', 'batchID', batchID)
      // verify required parameter 'otherBatchID' is not null or undefined
      assertParamExists('compareBatches', 'otherBatchID', otherBatchID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/compare/{otherBatchID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(
            `{${'otherBatchID'}}`,
            encodeURIComponent(String(otherBatchID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Adds a batch.  ID should be omitted and will be returned in the response.
     * @param {string} projectID
     * @param {BatchInput} [batchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBatch: async (
      projectID: string,
      batchInput?: BatchInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('createBatch', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/batches`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        batchInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Creates a batch for that test suite
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {TestSuiteBatchInput} [testSuiteBatchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBatchForTestSuite: async (
      projectID: string,
      testSuiteID: string,
      testSuiteBatchInput?: TestSuiteBatchInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('createBatchForTestSuite', 'projectID', projectID)
      // verify required parameter 'testSuiteID' is not null or undefined
      assertParamExists('createBatchForTestSuite', 'testSuiteID', testSuiteID)
      const localVarPath = `/projects/{projectID}/suites/{testSuiteID}/batches`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'testSuiteID'}}`, encodeURIComponent(String(testSuiteID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        testSuiteBatchInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Creates a batch for that test suite revision
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {number} revision
     * @param {TestSuiteBatchInput} [testSuiteBatchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBatchForTestSuiteRevision: async (
      projectID: string,
      testSuiteID: string,
      revision: number,
      testSuiteBatchInput?: TestSuiteBatchInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'createBatchForTestSuiteRevision',
        'projectID',
        projectID
      )
      // verify required parameter 'testSuiteID' is not null or undefined
      assertParamExists(
        'createBatchForTestSuiteRevision',
        'testSuiteID',
        testSuiteID
      )
      // verify required parameter 'revision' is not null or undefined
      assertParamExists('createBatchForTestSuiteRevision', 'revision', revision)
      const localVarPath =
        `/projects/{projectID}/suites/{testSuiteID}/revisions/{revision}/batches`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(
            `{${'testSuiteID'}}`,
            encodeURIComponent(String(testSuiteID))
          )
          .replace(`{${'revision'}}`, encodeURIComponent(String(revision)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        testSuiteBatchInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Deletes a log.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} logID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBatchLog: async (
      projectID: string,
      batchID: string,
      logID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('deleteBatchLog', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('deleteBatchLog', 'batchID', batchID)
      // verify required parameter 'logID' is not null or undefined
      assertParamExists('deleteBatchLog', 'logID', logID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/logs/{logID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'logID'}}`, encodeURIComponent(String(logID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Deletes a log.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} logID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteJobLog: async (
      projectID: string,
      batchID: string,
      jobID: string,
      logID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('deleteJobLog', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('deleteJobLog', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('deleteJobLog', 'jobID', jobID)
      // verify required parameter 'logID' is not null or undefined
      assertParamExists('deleteJobLog', 'logID', logID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/logs/{logID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
          .replace(`{${'logID'}}`, encodeURIComponent(String(logID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a batch.
     * @param {string} projectID
     * @param {string} batchID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBatch: async (
      projectID: string,
      batchID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getBatch', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('getBatch', 'batchID', batchID)
      const localVarPath = `/projects/{projectID}/batches/{batchID}`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Get an individual log file
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} logID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBatchLog: async (
      projectID: string,
      batchID: string,
      logID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getBatchLog', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('getBatchLog', 'batchID', batchID)
      // verify required parameter 'logID' is not null or undefined
      assertParamExists('getBatchLog', 'logID', logID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/logs/{logID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'logID'}}`, encodeURIComponent(String(logID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Retrieve a single event. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} eventID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventForJob: async (
      projectID: string,
      batchID: string,
      jobID: string,
      eventID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getEventForJob', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('getEventForJob', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('getEventForJob', 'jobID', jobID)
      // verify required parameter 'eventID' is not null or undefined
      assertParamExists('getEventForJob', 'eventID', eventID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/events/{eventID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
          .replace(`{${'eventID'}}`, encodeURIComponent(String(eventID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Retrieve the given job.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJob: async (
      projectID: string,
      batchID: string,
      jobID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getJob', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('getJob', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('getJob', 'jobID', jobID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Get an individual log file
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} logID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJobLog: async (
      projectID: string,
      batchID: string,
      jobID: string,
      logID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getJobLog', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('getJobLog', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('getJobLog', 'jobID', jobID)
      // verify required parameter 'logID' is not null or undefined
      assertParamExists('getJobLog', 'logID', logID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/logs/{logID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
          .replace(`{${'logID'}}`, encodeURIComponent(String(logID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * List jobs across all batches in a project
     * @param {string} projectID
     * @param {string} [search] Filter based on attributes metrics_build_name and metrics_build_version
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllJobs: async (
      projectID: string,
      search?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listAllJobs', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/batches/-/jobs`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Get all the account names that have triggered batches in the given project. These usernames are collected automatically from CI systems.
     * @param {string} projectID
     * @param {string} [name] Filter by the account name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchAccounts: async (
      projectID: string,
      name?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listBatchAccounts', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/batches/accounts`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * List the logs associated with a given batch
     * @param {string} projectID
     * @param {string} batchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchLogsForBatch: async (
      projectID: string,
      batchID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listBatchLogsForBatch', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listBatchLogsForBatch', 'batchID', batchID)
      const localVarPath = `/projects/{projectID}/batches/{batchID}/logs`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the (batch) metrics for a given batch. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetrics: async (
      projectID: string,
      batchID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listBatchMetrics', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listBatchMetrics', 'batchID', batchID)
      const localVarPath = `/projects/{projectID}/batches/{batchID}/metrics`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the metrics data associated with a given batch ID
     * @param {string} projectID
     * @param {string} batchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetricsData: async (
      projectID: string,
      batchID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listBatchMetricsData', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listBatchMetricsData', 'batchID', batchID)
      const localVarPath = `/projects/{projectID}/batches/{batchID}/metricsData`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the batch metrics data associated with given batch metric ID(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetricsDataForBatchMetricIDs: async (
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'listBatchMetricsDataForBatchMetricIDs',
        'projectID',
        projectID
      )
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists(
        'listBatchMetricsDataForBatchMetricIDs',
        'batchID',
        batchID
      )
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists(
        'listBatchMetricsDataForBatchMetricIDs',
        'metricID',
        metricID
      )
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/metrics/{metricID}/metricsData`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the batch metrics data associated with given batch metrics data IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetricsDataForBatchMetricsDataIDs: async (
      projectID: string,
      batchID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'listBatchMetricsDataForBatchMetricsDataIDs',
        'projectID',
        projectID
      )
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists(
        'listBatchMetricsDataForBatchMetricsDataIDs',
        'batchID',
        batchID
      )
      // verify required parameter 'metricsDataID' is not null or undefined
      assertParamExists(
        'listBatchMetricsDataForBatchMetricsDataIDs',
        'metricsDataID',
        metricsDataID
      )
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/metricsData/{metricsDataID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(
            `{${'metricsDataID'}}`,
            encodeURIComponent(String(metricsDataID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the batch metrics associated with given batch metric IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetricsForBatchMetricIDs: async (
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'listBatchMetricsForBatchMetricIDs',
        'projectID',
        projectID
      )
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listBatchMetricsForBatchMetricIDs', 'batchID', batchID)
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists(
        'listBatchMetricsForBatchMetricIDs',
        'metricID',
        metricID
      )
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/metrics/{metricID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * List the batches.
     * @param {string} projectID
     * @param {string} [search] Filter based on branch_id, build_id, system_id, created_at, status, metrics_status, batch_id
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatches: async (
      projectID: string,
      search?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listBatches', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/batches`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the batches for a build.
     * @param {string} projectID
     * @param {string} branchID
     * @param {Array<string>} buildID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchesForBuilds: async (
      projectID: string,
      branchID: string,
      buildID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listBatchesForBuilds', 'projectID', projectID)
      // verify required parameter 'branchID' is not null or undefined
      assertParamExists('listBatchesForBuilds', 'branchID', branchID)
      // verify required parameter 'buildID' is not null or undefined
      assertParamExists('listBatchesForBuilds', 'buildID', buildID)
      const localVarPath =
        `/projects/{projectID}/branches/{branchID}/builds/{buildID}/batches`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'branchID'}}`, encodeURIComponent(String(branchID)))
          .replace(`{${'buildID'}}`, encodeURIComponent(String(buildID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * List the batches for a test suite (all revisions).
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchesForTestSuite: async (
      projectID: string,
      testSuiteID: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listBatchesForTestSuite', 'projectID', projectID)
      // verify required parameter 'testSuiteID' is not null or undefined
      assertParamExists('listBatchesForTestSuite', 'testSuiteID', testSuiteID)
      const localVarPath = `/projects/{projectID}/suites/{testSuiteID}/batches`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'testSuiteID'}}`, encodeURIComponent(String(testSuiteID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * List the batches for a test suite revision
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {number} revision
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchesForTestSuiteRevision: async (
      projectID: string,
      testSuiteID: string,
      revision: number,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'listBatchesForTestSuiteRevision',
        'projectID',
        projectID
      )
      // verify required parameter 'testSuiteID' is not null or undefined
      assertParamExists(
        'listBatchesForTestSuiteRevision',
        'testSuiteID',
        testSuiteID
      )
      // verify required parameter 'revision' is not null or undefined
      assertParamExists('listBatchesForTestSuiteRevision', 'revision', revision)
      const localVarPath =
        `/projects/{projectID}/suites/{testSuiteID}/revisions/{revision}/batches`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(
            `{${'testSuiteID'}}`,
            encodeURIComponent(String(testSuiteID))
          )
          .replace(`{${'revision'}}`, encodeURIComponent(String(revision)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the events for a given job. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEventsForJob: async (
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listEventsForJob', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listEventsForJob', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('listEventsForJob', 'jobID', jobID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/events`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * List the logs associated with a given job
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<LogType>} [type]
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listJobLogsForJob: async (
      projectID: string,
      batchID: string,
      jobID: string,
      type?: Array<LogType>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listJobLogsForJob', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listJobLogsForJob', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('listJobLogsForJob', 'jobID', jobID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/logs`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (type) {
        localVarQueryParameter['type'] = type
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * List the jobs in the given batch.
     * @param {string} projectID
     * @param {string} batchID
     * @param {JobStatus} [status] Filter jobs by status
     * @param {Array<ConflatedJobStatus>} [conflatedStatus] Filter jobs by their conflated status
     * @param {string} [name] Filter experiences (in job) by name
     * @param {string} [text] Filter experiences (in job) by a text string on name and description
     * @param {Array<string>} [experienceTagIDs] Filter jobs by the tag id(s) attached to the experience
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listJobs: async (
      projectID: string,
      batchID: string,
      status?: JobStatus,
      conflatedStatus?: Array<ConflatedJobStatus>,
      name?: string,
      text?: string,
      experienceTagIDs?: Array<string>,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listJobs', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listJobs', 'batchID', batchID)
      const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }

      if (conflatedStatus) {
        localVarQueryParameter['conflatedStatus'] = conflatedStatus.join(
          COLLECTION_FORMATS.csv
        )
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (text !== undefined) {
        localVarQueryParameter['text'] = text
      }

      if (experienceTagIDs) {
        localVarQueryParameter['experienceTagIDs'] = experienceTagIDs.join(
          COLLECTION_FORMATS.csv
        )
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the metrics data associated with a given job ID
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsDataForJob: async (
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listMetricsDataForJob', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listMetricsDataForJob', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('listMetricsDataForJob', 'jobID', jobID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metricsData`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the metrics data associated with given metric ID(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsDataForMetricIDs: async (
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listMetricsDataForMetricIDs', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listMetricsDataForMetricIDs', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('listMetricsDataForMetricIDs', 'jobID', jobID)
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists('listMetricsDataForMetricIDs', 'metricID', metricID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics/{metricID}/metricsData`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the metrics data associated with given metrics data IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsDataForMetricsDataIDs: async (
      projectID: string,
      batchID: string,
      jobID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'listMetricsDataForMetricsDataIDs',
        'projectID',
        projectID
      )
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listMetricsDataForMetricsDataIDs', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('listMetricsDataForMetricsDataIDs', 'jobID', jobID)
      // verify required parameter 'metricsDataID' is not null or undefined
      assertParamExists(
        'listMetricsDataForMetricsDataIDs',
        'metricsDataID',
        metricsDataID
      )
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metricsData/{metricsDataID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
          .replace(
            `{${'metricsDataID'}}`,
            encodeURIComponent(String(metricsDataID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the metrics for a given job. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsForJob: async (
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listMetricsForJob', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listMetricsForJob', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('listMetricsForJob', 'jobID', jobID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the metrics associated with given metric IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsForMetricIDs: async (
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listMetricsForMetricIDs', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listMetricsForMetricIDs', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('listMetricsForMetricIDs', 'jobID', jobID)
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists('listMetricsForMetricIDs', 'metricID', metricID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics/{metricID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Updates the batch.
     * @param {string} projectID
     * @param {string} batchID
     * @param {UpdateBatchInput} [updateBatchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBatch: async (
      projectID: string,
      batchID: string,
      updateBatchInput?: UpdateBatchInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('updateBatch', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('updateBatch', 'batchID', batchID)
      const localVarPath = `/projects/{projectID}/batches/{batchID}`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateBatchInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Updates the event.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} eventID
     * @param {UpdateEventInput} [updateEventInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEvent: async (
      projectID: string,
      batchID: string,
      jobID: string,
      eventID: string,
      updateEventInput?: UpdateEventInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('updateEvent', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('updateEvent', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('updateEvent', 'jobID', jobID)
      // verify required parameter 'eventID' is not null or undefined
      assertParamExists('updateEvent', 'eventID', eventID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/events/{eventID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
          .replace(`{${'eventID'}}`, encodeURIComponent(String(eventID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateEventInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Updates the job.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {UpdateJobInput} [updateJobInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateJob: async (
      projectID: string,
      batchID: string,
      jobID: string,
      updateJobInput?: UpdateJobInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('updateJob', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('updateJob', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('updateJob', 'jobID', jobID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateJobInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * BatchesApi - functional programming interface
 * @export
 */
export const BatchesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BatchesApiAxiosParamCreator(configuration)
  return {
    /**
     * Cancels a batch.
     * @param {string} projectID
     * @param {string} batchID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelBatch(
      projectID: string,
      batchID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelBatch(
        projectID,
        batchID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Get a summary describing how individual tests have changed between the two given batches. A warning or a blocking failure is considered failing from the point of view of filters and ordering.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} otherBatchID the batch to compare to
     * @param {CompareBatchesStatusFilter} [status] filter tests by their status
     * @param {string} [search] filter tests by their name
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async compareBatches(
      projectID: string,
      batchID: string,
      otherBatchID: string,
      status?: CompareBatchesStatusFilter,
      search?: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CompareBatchesOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.compareBatches(
        projectID,
        batchID,
        otherBatchID,
        status,
        search,
        pageSize,
        pageToken,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Adds a batch.  ID should be omitted and will be returned in the response.
     * @param {string} projectID
     * @param {BatchInput} [batchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createBatch(
      projectID: string,
      batchInput?: BatchInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createBatch(
        projectID,
        batchInput,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Creates a batch for that test suite
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {TestSuiteBatchInput} [testSuiteBatchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createBatchForTestSuite(
      projectID: string,
      testSuiteID: string,
      testSuiteBatchInput?: TestSuiteBatchInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createBatchForTestSuite(
          projectID,
          testSuiteID,
          testSuiteBatchInput,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Creates a batch for that test suite revision
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {number} revision
     * @param {TestSuiteBatchInput} [testSuiteBatchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createBatchForTestSuiteRevision(
      projectID: string,
      testSuiteID: string,
      revision: number,
      testSuiteBatchInput?: TestSuiteBatchInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createBatchForTestSuiteRevision(
          projectID,
          testSuiteID,
          revision,
          testSuiteBatchInput,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Deletes a log.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} logID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteBatchLog(
      projectID: string,
      batchID: string,
      logID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBatchLog(
        projectID,
        batchID,
        logID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Deletes a log.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} logID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteJobLog(
      projectID: string,
      batchID: string,
      jobID: string,
      logID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobLog(
        projectID,
        batchID,
        jobID,
        logID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a batch.
     * @param {string} projectID
     * @param {string} batchID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBatch(
      projectID: string,
      batchID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBatch(
        projectID,
        batchID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Get an individual log file
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} logID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBatchLog(
      projectID: string,
      batchID: string,
      logID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchLog>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchLog(
        projectID,
        batchID,
        logID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieve a single event. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} eventID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      eventID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventForJob(
        projectID,
        batchID,
        jobID,
        eventID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieve the given job.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJob(
      projectID: string,
      batchID: string,
      jobID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getJob(
        projectID,
        batchID,
        jobID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Get an individual log file
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} logID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJobLog(
      projectID: string,
      batchID: string,
      jobID: string,
      logID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobLog>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getJobLog(
        projectID,
        batchID,
        jobID,
        logID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List jobs across all batches in a project
     * @param {string} projectID
     * @param {string} [search] Filter based on attributes metrics_build_name and metrics_build_version
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAllJobs(
      projectID: string,
      search?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListAllJobsOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAllJobs(
        projectID,
        search,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Get all the account names that have triggered batches in the given project. These usernames are collected automatically from CI systems.
     * @param {string} projectID
     * @param {string} [name] Filter by the account name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBatchAccounts(
      projectID: string,
      name?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBatchAccounts(
          projectID,
          name,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the logs associated with a given batch
     * @param {string} projectID
     * @param {string} batchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBatchLogsForBatch(
      projectID: string,
      batchID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBatchLogsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBatchLogsForBatch(
          projectID,
          batchID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the (batch) metrics for a given batch. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBatchMetrics(
      projectID: string,
      batchID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBatchMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBatchMetrics(
          projectID,
          batchID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the metrics data associated with a given batch ID
     * @param {string} projectID
     * @param {string} batchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBatchMetricsData(
      projectID: string,
      batchID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBatchMetricsDataOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBatchMetricsData(
          projectID,
          batchID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the batch metrics data associated with given batch metric ID(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBatchMetricsDataForBatchMetricIDs(
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBatchMetricsDataForBatchMetricIDsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBatchMetricsDataForBatchMetricIDs(
          projectID,
          batchID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the batch metrics data associated with given batch metrics data IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBatchMetricsDataForBatchMetricsDataIDs(
      projectID: string,
      batchID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBatchMetricsDataOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBatchMetricsDataForBatchMetricsDataIDs(
          projectID,
          batchID,
          metricsDataID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the batch metrics associated with given batch metric IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBatchMetricsForBatchMetricIDs(
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBatchMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBatchMetricsForBatchMetricIDs(
          projectID,
          batchID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the batches.
     * @param {string} projectID
     * @param {string} [search] Filter based on branch_id, build_id, system_id, created_at, status, metrics_status, batch_id
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBatches(
      projectID: string,
      search?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBatchesOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listBatches(
        projectID,
        search,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the batches for a build.
     * @param {string} projectID
     * @param {string} branchID
     * @param {Array<string>} buildID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBatchesForBuilds(
      projectID: string,
      branchID: string,
      buildID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBatchesOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBatchesForBuilds(
          projectID,
          branchID,
          buildID,
          pageSize,
          pageToken,
          orderBy,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the batches for a test suite (all revisions).
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBatchesForTestSuite(
      projectID: string,
      testSuiteID: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBatchesOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBatchesForTestSuite(
          projectID,
          testSuiteID,
          pageSize,
          pageToken,
          orderBy,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the batches for a test suite revision
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {number} revision
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBatchesForTestSuiteRevision(
      projectID: string,
      testSuiteID: string,
      revision: number,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBatchesOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBatchesForTestSuiteRevision(
          projectID,
          testSuiteID,
          revision,
          pageSize,
          pageToken,
          orderBy,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the events for a given job. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listEventsForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListJobEventsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listEventsForJob(
          projectID,
          batchID,
          jobID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the logs associated with a given job
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<LogType>} [type]
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listJobLogsForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      type?: Array<LogType>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListJobLogsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listJobLogsForJob(
          projectID,
          batchID,
          jobID,
          type,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the jobs in the given batch.
     * @param {string} projectID
     * @param {string} batchID
     * @param {JobStatus} [status] Filter jobs by status
     * @param {Array<ConflatedJobStatus>} [conflatedStatus] Filter jobs by their conflated status
     * @param {string} [name] Filter experiences (in job) by name
     * @param {string} [text] Filter experiences (in job) by a text string on name and description
     * @param {Array<string>} [experienceTagIDs] Filter jobs by the tag id(s) attached to the experience
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listJobs(
      projectID: string,
      batchID: string,
      status?: JobStatus,
      conflatedStatus?: Array<ConflatedJobStatus>,
      name?: string,
      text?: string,
      experienceTagIDs?: Array<string>,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListJobsOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listJobs(
        projectID,
        batchID,
        status,
        conflatedStatus,
        name,
        text,
        experienceTagIDs,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the metrics data associated with a given job ID
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMetricsDataForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListJobMetricsDataOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listMetricsDataForJob(
          projectID,
          batchID,
          jobID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the metrics data associated with given metric ID(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMetricsDataForMetricIDs(
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListMetricsDataAndMetricIDOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listMetricsDataForMetricIDs(
          projectID,
          batchID,
          jobID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the metrics data associated with given metrics data IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMetricsDataForMetricsDataIDs(
      projectID: string,
      batchID: string,
      jobID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListJobMetricsDataOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listMetricsDataForMetricsDataIDs(
          projectID,
          batchID,
          jobID,
          metricsDataID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the metrics for a given job. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMetricsForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListJobMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listMetricsForJob(
          projectID,
          batchID,
          jobID,
          pageSize,
          pageToken,
          orderBy,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the metrics associated with given metric IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMetricsForMetricIDs(
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListJobMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listMetricsForMetricIDs(
          projectID,
          batchID,
          jobID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Updates the batch.
     * @param {string} projectID
     * @param {string} batchID
     * @param {UpdateBatchInput} [updateBatchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateBatch(
      projectID: string,
      batchID: string,
      updateBatchInput?: UpdateBatchInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateBatch(
        projectID,
        batchID,
        updateBatchInput,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Updates the event.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} eventID
     * @param {UpdateEventInput} [updateEventInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEvent(
      projectID: string,
      batchID: string,
      jobID: string,
      eventID: string,
      updateEventInput?: UpdateEventInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(
        projectID,
        batchID,
        jobID,
        eventID,
        updateEventInput,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Updates the job.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {UpdateJobInput} [updateJobInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateJob(
      projectID: string,
      batchID: string,
      jobID: string,
      updateJobInput?: UpdateJobInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateJob(
        projectID,
        batchID,
        jobID,
        updateJobInput,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * BatchesApi - factory interface
 * @export
 */
export const BatchesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BatchesApiFp(configuration)
  return {
    /**
     * Cancels a batch.
     * @param {string} projectID
     * @param {string} batchID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelBatch(
      projectID: string,
      batchID: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .cancelBatch(projectID, batchID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Get a summary describing how individual tests have changed between the two given batches. A warning or a blocking failure is considered failing from the point of view of filters and ordering.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} otherBatchID the batch to compare to
     * @param {CompareBatchesStatusFilter} [status] filter tests by their status
     * @param {string} [search] filter tests by their name
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    compareBatches(
      projectID: string,
      batchID: string,
      otherBatchID: string,
      status?: CompareBatchesStatusFilter,
      search?: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<CompareBatchesOutput> {
      return localVarFp
        .compareBatches(
          projectID,
          batchID,
          otherBatchID,
          status,
          search,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Adds a batch.  ID should be omitted and will be returned in the response.
     * @param {string} projectID
     * @param {BatchInput} [batchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBatch(
      projectID: string,
      batchInput?: BatchInput,
      options?: any
    ): AxiosPromise<Batch> {
      return localVarFp
        .createBatch(projectID, batchInput, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Creates a batch for that test suite
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {TestSuiteBatchInput} [testSuiteBatchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBatchForTestSuite(
      projectID: string,
      testSuiteID: string,
      testSuiteBatchInput?: TestSuiteBatchInput,
      options?: any
    ): AxiosPromise<Batch> {
      return localVarFp
        .createBatchForTestSuite(
          projectID,
          testSuiteID,
          testSuiteBatchInput,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Creates a batch for that test suite revision
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {number} revision
     * @param {TestSuiteBatchInput} [testSuiteBatchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBatchForTestSuiteRevision(
      projectID: string,
      testSuiteID: string,
      revision: number,
      testSuiteBatchInput?: TestSuiteBatchInput,
      options?: any
    ): AxiosPromise<Batch> {
      return localVarFp
        .createBatchForTestSuiteRevision(
          projectID,
          testSuiteID,
          revision,
          testSuiteBatchInput,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Deletes a log.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} logID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBatchLog(
      projectID: string,
      batchID: string,
      logID: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteBatchLog(projectID, batchID, logID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Deletes a log.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} logID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteJobLog(
      projectID: string,
      batchID: string,
      jobID: string,
      logID: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteJobLog(projectID, batchID, jobID, logID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a batch.
     * @param {string} projectID
     * @param {string} batchID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBatch(
      projectID: string,
      batchID: string,
      options?: any
    ): AxiosPromise<Batch> {
      return localVarFp
        .getBatch(projectID, batchID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Get an individual log file
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} logID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBatchLog(
      projectID: string,
      batchID: string,
      logID: string,
      options?: any
    ): AxiosPromise<BatchLog> {
      return localVarFp
        .getBatchLog(projectID, batchID, logID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Retrieve a single event. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} eventID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      eventID: string,
      options?: any
    ): AxiosPromise<Event> {
      return localVarFp
        .getEventForJob(projectID, batchID, jobID, eventID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Retrieve the given job.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJob(
      projectID: string,
      batchID: string,
      jobID: string,
      options?: any
    ): AxiosPromise<Job> {
      return localVarFp
        .getJob(projectID, batchID, jobID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Get an individual log file
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} logID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJobLog(
      projectID: string,
      batchID: string,
      jobID: string,
      logID: string,
      options?: any
    ): AxiosPromise<JobLog> {
      return localVarFp
        .getJobLog(projectID, batchID, jobID, logID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * List jobs across all batches in a project
     * @param {string} projectID
     * @param {string} [search] Filter based on attributes metrics_build_name and metrics_build_version
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllJobs(
      projectID: string,
      search?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListAllJobsOutput> {
      return localVarFp
        .listAllJobs(projectID, search, pageSize, pageToken, orderBy, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Get all the account names that have triggered batches in the given project. These usernames are collected automatically from CI systems.
     * @param {string} projectID
     * @param {string} [name] Filter by the account name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchAccounts(
      projectID: string,
      name?: string,
      options?: any
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listBatchAccounts(projectID, name, options)
        .then(request => request(axios, basePath))
    },
    /**
     * List the logs associated with a given batch
     * @param {string} projectID
     * @param {string} batchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchLogsForBatch(
      projectID: string,
      batchID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListBatchLogsOutput> {
      return localVarFp
        .listBatchLogsForBatch(projectID, batchID, pageSize, pageToken, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the (batch) metrics for a given batch. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetrics(
      projectID: string,
      batchID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListBatchMetricsOutput> {
      return localVarFp
        .listBatchMetrics(projectID, batchID, pageSize, pageToken, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the metrics data associated with a given batch ID
     * @param {string} projectID
     * @param {string} batchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetricsData(
      projectID: string,
      batchID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListBatchMetricsDataOutput> {
      return localVarFp
        .listBatchMetricsData(projectID, batchID, pageSize, pageToken, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the batch metrics data associated with given batch metric ID(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetricsDataForBatchMetricIDs(
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListBatchMetricsDataForBatchMetricIDsOutput> {
      return localVarFp
        .listBatchMetricsDataForBatchMetricIDs(
          projectID,
          batchID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the batch metrics data associated with given batch metrics data IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetricsDataForBatchMetricsDataIDs(
      projectID: string,
      batchID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListBatchMetricsDataOutput> {
      return localVarFp
        .listBatchMetricsDataForBatchMetricsDataIDs(
          projectID,
          batchID,
          metricsDataID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the batch metrics associated with given batch metric IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetricsForBatchMetricIDs(
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListBatchMetricsOutput> {
      return localVarFp
        .listBatchMetricsForBatchMetricIDs(
          projectID,
          batchID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * List the batches.
     * @param {string} projectID
     * @param {string} [search] Filter based on branch_id, build_id, system_id, created_at, status, metrics_status, batch_id
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatches(
      projectID: string,
      search?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListBatchesOutput> {
      return localVarFp
        .listBatches(projectID, search, pageSize, pageToken, orderBy, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the batches for a build.
     * @param {string} projectID
     * @param {string} branchID
     * @param {Array<string>} buildID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchesForBuilds(
      projectID: string,
      branchID: string,
      buildID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListBatchesOutput> {
      return localVarFp
        .listBatchesForBuilds(
          projectID,
          branchID,
          buildID,
          pageSize,
          pageToken,
          orderBy,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * List the batches for a test suite (all revisions).
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchesForTestSuite(
      projectID: string,
      testSuiteID: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListBatchesOutput> {
      return localVarFp
        .listBatchesForTestSuite(
          projectID,
          testSuiteID,
          pageSize,
          pageToken,
          orderBy,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * List the batches for a test suite revision
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {number} revision
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchesForTestSuiteRevision(
      projectID: string,
      testSuiteID: string,
      revision: number,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListBatchesOutput> {
      return localVarFp
        .listBatchesForTestSuiteRevision(
          projectID,
          testSuiteID,
          revision,
          pageSize,
          pageToken,
          orderBy,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the events for a given job. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEventsForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListJobEventsOutput> {
      return localVarFp
        .listEventsForJob(
          projectID,
          batchID,
          jobID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * List the logs associated with a given job
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<LogType>} [type]
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listJobLogsForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      type?: Array<LogType>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListJobLogsOutput> {
      return localVarFp
        .listJobLogsForJob(
          projectID,
          batchID,
          jobID,
          type,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * List the jobs in the given batch.
     * @param {string} projectID
     * @param {string} batchID
     * @param {JobStatus} [status] Filter jobs by status
     * @param {Array<ConflatedJobStatus>} [conflatedStatus] Filter jobs by their conflated status
     * @param {string} [name] Filter experiences (in job) by name
     * @param {string} [text] Filter experiences (in job) by a text string on name and description
     * @param {Array<string>} [experienceTagIDs] Filter jobs by the tag id(s) attached to the experience
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listJobs(
      projectID: string,
      batchID: string,
      status?: JobStatus,
      conflatedStatus?: Array<ConflatedJobStatus>,
      name?: string,
      text?: string,
      experienceTagIDs?: Array<string>,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListJobsOutput> {
      return localVarFp
        .listJobs(
          projectID,
          batchID,
          status,
          conflatedStatus,
          name,
          text,
          experienceTagIDs,
          pageSize,
          pageToken,
          orderBy,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the metrics data associated with a given job ID
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsDataForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListJobMetricsDataOutput> {
      return localVarFp
        .listMetricsDataForJob(
          projectID,
          batchID,
          jobID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the metrics data associated with given metric ID(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsDataForMetricIDs(
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListMetricsDataAndMetricIDOutput> {
      return localVarFp
        .listMetricsDataForMetricIDs(
          projectID,
          batchID,
          jobID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the metrics data associated with given metrics data IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsDataForMetricsDataIDs(
      projectID: string,
      batchID: string,
      jobID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListJobMetricsDataOutput> {
      return localVarFp
        .listMetricsDataForMetricsDataIDs(
          projectID,
          batchID,
          jobID,
          metricsDataID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the metrics for a given job. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListJobMetricsOutput> {
      return localVarFp
        .listMetricsForJob(
          projectID,
          batchID,
          jobID,
          pageSize,
          pageToken,
          orderBy,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the metrics associated with given metric IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsForMetricIDs(
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListJobMetricsOutput> {
      return localVarFp
        .listMetricsForMetricIDs(
          projectID,
          batchID,
          jobID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Updates the batch.
     * @param {string} projectID
     * @param {string} batchID
     * @param {UpdateBatchInput} [updateBatchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBatch(
      projectID: string,
      batchID: string,
      updateBatchInput?: UpdateBatchInput,
      options?: any
    ): AxiosPromise<Batch> {
      return localVarFp
        .updateBatch(projectID, batchID, updateBatchInput, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Updates the event.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} eventID
     * @param {UpdateEventInput} [updateEventInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEvent(
      projectID: string,
      batchID: string,
      jobID: string,
      eventID: string,
      updateEventInput?: UpdateEventInput,
      options?: any
    ): AxiosPromise<Event> {
      return localVarFp
        .updateEvent(
          projectID,
          batchID,
          jobID,
          eventID,
          updateEventInput,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Updates the job.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {UpdateJobInput} [updateJobInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateJob(
      projectID: string,
      batchID: string,
      jobID: string,
      updateJobInput?: UpdateJobInput,
      options?: any
    ): AxiosPromise<Job> {
      return localVarFp
        .updateJob(projectID, batchID, jobID, updateJobInput, options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * BatchesApi - object-oriented interface
 * @export
 * @class BatchesApi
 * @extends {BaseAPI}
 */
export class BatchesApi extends BaseAPI {
  /**
   * Cancels a batch.
   * @param {string} projectID
   * @param {string} batchID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public cancelBatch(
    projectID: string,
    batchID: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .cancelBatch(projectID, batchID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Get a summary describing how individual tests have changed between the two given batches. A warning or a blocking failure is considered failing from the point of view of filters and ordering.
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} otherBatchID the batch to compare to
   * @param {CompareBatchesStatusFilter} [status] filter tests by their status
   * @param {string} [search] filter tests by their name
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public compareBatches(
    projectID: string,
    batchID: string,
    otherBatchID: string,
    status?: CompareBatchesStatusFilter,
    search?: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .compareBatches(
        projectID,
        batchID,
        otherBatchID,
        status,
        search,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Adds a batch.  ID should be omitted and will be returned in the response.
   * @param {string} projectID
   * @param {BatchInput} [batchInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public createBatch(
    projectID: string,
    batchInput?: BatchInput,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .createBatch(projectID, batchInput, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Creates a batch for that test suite
   * @param {string} projectID
   * @param {string} testSuiteID
   * @param {TestSuiteBatchInput} [testSuiteBatchInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public createBatchForTestSuite(
    projectID: string,
    testSuiteID: string,
    testSuiteBatchInput?: TestSuiteBatchInput,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .createBatchForTestSuite(
        projectID,
        testSuiteID,
        testSuiteBatchInput,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Creates a batch for that test suite revision
   * @param {string} projectID
   * @param {string} testSuiteID
   * @param {number} revision
   * @param {TestSuiteBatchInput} [testSuiteBatchInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public createBatchForTestSuiteRevision(
    projectID: string,
    testSuiteID: string,
    revision: number,
    testSuiteBatchInput?: TestSuiteBatchInput,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .createBatchForTestSuiteRevision(
        projectID,
        testSuiteID,
        revision,
        testSuiteBatchInput,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Deletes a log.
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} logID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public deleteBatchLog(
    projectID: string,
    batchID: string,
    logID: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .deleteBatchLog(projectID, batchID, logID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Deletes a log.
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {string} logID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public deleteJobLog(
    projectID: string,
    batchID: string,
    jobID: string,
    logID: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .deleteJobLog(projectID, batchID, jobID, logID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a batch.
   * @param {string} projectID
   * @param {string} batchID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public getBatch(
    projectID: string,
    batchID: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .getBatch(projectID, batchID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Get an individual log file
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} logID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public getBatchLog(
    projectID: string,
    batchID: string,
    logID: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .getBatchLog(projectID, batchID, logID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a single event. Does not return associated data.
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {string} eventID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public getEventForJob(
    projectID: string,
    batchID: string,
    jobID: string,
    eventID: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .getEventForJob(projectID, batchID, jobID, eventID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Retrieve the given job.
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public getJob(
    projectID: string,
    batchID: string,
    jobID: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .getJob(projectID, batchID, jobID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Get an individual log file
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {string} logID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public getJobLog(
    projectID: string,
    batchID: string,
    jobID: string,
    logID: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .getJobLog(projectID, batchID, jobID, logID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * List jobs across all batches in a project
   * @param {string} projectID
   * @param {string} [search] Filter based on attributes metrics_build_name and metrics_build_version
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listAllJobs(
    projectID: string,
    search?: string,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listAllJobs(projectID, search, pageSize, pageToken, orderBy, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Get all the account names that have triggered batches in the given project. These usernames are collected automatically from CI systems.
   * @param {string} projectID
   * @param {string} [name] Filter by the account name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listBatchAccounts(
    projectID: string,
    name?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listBatchAccounts(projectID, name, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * List the logs associated with a given batch
   * @param {string} projectID
   * @param {string} batchID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listBatchLogsForBatch(
    projectID: string,
    batchID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listBatchLogsForBatch(projectID, batchID, pageSize, pageToken, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the (batch) metrics for a given batch. Does not return associated data.
   * @param {string} projectID
   * @param {string} batchID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listBatchMetrics(
    projectID: string,
    batchID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listBatchMetrics(projectID, batchID, pageSize, pageToken, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the metrics data associated with a given batch ID
   * @param {string} projectID
   * @param {string} batchID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listBatchMetricsData(
    projectID: string,
    batchID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listBatchMetricsData(projectID, batchID, pageSize, pageToken, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the batch metrics data associated with given batch metric ID(s)
   * @param {string} projectID
   * @param {string} batchID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listBatchMetricsDataForBatchMetricIDs(
    projectID: string,
    batchID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listBatchMetricsDataForBatchMetricIDs(
        projectID,
        batchID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the batch metrics data associated with given batch metrics data IDs
   * @param {string} projectID
   * @param {string} batchID
   * @param {Array<string>} metricsDataID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listBatchMetricsDataForBatchMetricsDataIDs(
    projectID: string,
    batchID: string,
    metricsDataID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listBatchMetricsDataForBatchMetricsDataIDs(
        projectID,
        batchID,
        metricsDataID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the batch metrics associated with given batch metric IDs
   * @param {string} projectID
   * @param {string} batchID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listBatchMetricsForBatchMetricIDs(
    projectID: string,
    batchID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listBatchMetricsForBatchMetricIDs(
        projectID,
        batchID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * List the batches.
   * @param {string} projectID
   * @param {string} [search] Filter based on branch_id, build_id, system_id, created_at, status, metrics_status, batch_id
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listBatches(
    projectID: string,
    search?: string,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listBatches(projectID, search, pageSize, pageToken, orderBy, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the batches for a build.
   * @param {string} projectID
   * @param {string} branchID
   * @param {Array<string>} buildID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listBatchesForBuilds(
    projectID: string,
    branchID: string,
    buildID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listBatchesForBuilds(
        projectID,
        branchID,
        buildID,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * List the batches for a test suite (all revisions).
   * @param {string} projectID
   * @param {string} testSuiteID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listBatchesForTestSuite(
    projectID: string,
    testSuiteID: string,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listBatchesForTestSuite(
        projectID,
        testSuiteID,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * List the batches for a test suite revision
   * @param {string} projectID
   * @param {string} testSuiteID
   * @param {number} revision
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listBatchesForTestSuiteRevision(
    projectID: string,
    testSuiteID: string,
    revision: number,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listBatchesForTestSuiteRevision(
        projectID,
        testSuiteID,
        revision,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the events for a given job. Does not return associated data.
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listEventsForJob(
    projectID: string,
    batchID: string,
    jobID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listEventsForJob(projectID, batchID, jobID, pageSize, pageToken, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * List the logs associated with a given job
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {Array<LogType>} [type]
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listJobLogsForJob(
    projectID: string,
    batchID: string,
    jobID: string,
    type?: Array<LogType>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listJobLogsForJob(
        projectID,
        batchID,
        jobID,
        type,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * List the jobs in the given batch.
   * @param {string} projectID
   * @param {string} batchID
   * @param {JobStatus} [status] Filter jobs by status
   * @param {Array<ConflatedJobStatus>} [conflatedStatus] Filter jobs by their conflated status
   * @param {string} [name] Filter experiences (in job) by name
   * @param {string} [text] Filter experiences (in job) by a text string on name and description
   * @param {Array<string>} [experienceTagIDs] Filter jobs by the tag id(s) attached to the experience
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listJobs(
    projectID: string,
    batchID: string,
    status?: JobStatus,
    conflatedStatus?: Array<ConflatedJobStatus>,
    name?: string,
    text?: string,
    experienceTagIDs?: Array<string>,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listJobs(
        projectID,
        batchID,
        status,
        conflatedStatus,
        name,
        text,
        experienceTagIDs,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the metrics data associated with a given job ID
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listMetricsDataForJob(
    projectID: string,
    batchID: string,
    jobID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listMetricsDataForJob(
        projectID,
        batchID,
        jobID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the metrics data associated with given metric ID(s)
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listMetricsDataForMetricIDs(
    projectID: string,
    batchID: string,
    jobID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listMetricsDataForMetricIDs(
        projectID,
        batchID,
        jobID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the metrics data associated with given metrics data IDs
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {Array<string>} metricsDataID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listMetricsDataForMetricsDataIDs(
    projectID: string,
    batchID: string,
    jobID: string,
    metricsDataID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listMetricsDataForMetricsDataIDs(
        projectID,
        batchID,
        jobID,
        metricsDataID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the metrics for a given job. Does not return associated data.
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listMetricsForJob(
    projectID: string,
    batchID: string,
    jobID: string,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listMetricsForJob(
        projectID,
        batchID,
        jobID,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the metrics associated with given metric IDs
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public listMetricsForMetricIDs(
    projectID: string,
    batchID: string,
    jobID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .listMetricsForMetricIDs(
        projectID,
        batchID,
        jobID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Updates the batch.
   * @param {string} projectID
   * @param {string} batchID
   * @param {UpdateBatchInput} [updateBatchInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public updateBatch(
    projectID: string,
    batchID: string,
    updateBatchInput?: UpdateBatchInput,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .updateBatch(projectID, batchID, updateBatchInput, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Updates the event.
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {string} eventID
   * @param {UpdateEventInput} [updateEventInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public updateEvent(
    projectID: string,
    batchID: string,
    jobID: string,
    eventID: string,
    updateEventInput?: UpdateEventInput,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .updateEvent(
        projectID,
        batchID,
        jobID,
        eventID,
        updateEventInput,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Updates the job.
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {UpdateJobInput} [updateJobInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public updateJob(
    projectID: string,
    batchID: string,
    jobID: string,
    updateJobInput?: UpdateJobInput,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .updateJob(projectID, batchID, jobID, updateJobInput, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * BuildsApi - axios parameter creator
 * @export
 */
export const BuildsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Adds a build.
     * @param {string} projectID
     * @param {string} branchID
     * @param {CreateBuildForBranchInput | null} [createBuildForBranchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBuildForBranch: async (
      projectID: string,
      branchID: string,
      createBuildForBranchInput?: CreateBuildForBranchInput | null,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('createBuildForBranch', 'projectID', projectID)
      // verify required parameter 'branchID' is not null or undefined
      assertParamExists('createBuildForBranch', 'branchID', branchID)
      const localVarPath = `/projects/{projectID}/branches/{branchID}/builds`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'branchID'}}`, encodeURIComponent(String(branchID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createBuildForBranchInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Adds a build.
     * @param {string} projectID
     * @param {string} systemID
     * @param {CreateBuildForSystemInput | null} [createBuildForSystemInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBuildForSystem: async (
      projectID: string,
      systemID: string,
      createBuildForSystemInput?: CreateBuildForSystemInput | null,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('createBuildForSystem', 'projectID', projectID)
      // verify required parameter 'systemID' is not null or undefined
      assertParamExists('createBuildForSystem', 'systemID', systemID)
      const localVarPath = `/projects/{projectID}/systems/{systemID}/builds`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'systemID'}}`, encodeURIComponent(String(systemID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createBuildForSystemInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Delete a build.
     * @param {string} projectID
     * @param {string} branchID
     * @param {string} buildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBuildForBranch: async (
      projectID: string,
      branchID: string,
      buildID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('deleteBuildForBranch', 'projectID', projectID)
      // verify required parameter 'branchID' is not null or undefined
      assertParamExists('deleteBuildForBranch', 'branchID', branchID)
      // verify required parameter 'buildID' is not null or undefined
      assertParamExists('deleteBuildForBranch', 'buildID', buildID)
      const localVarPath =
        `/projects/{projectID}/branches/{branchID}/builds/{buildID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'branchID'}}`, encodeURIComponent(String(branchID)))
          .replace(`{${'buildID'}}`, encodeURIComponent(String(buildID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:write'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a specific build.
     * @param {string} projectID
     * @param {string} buildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuild: async (
      projectID: string,
      buildID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getBuild', 'projectID', projectID)
      // verify required parameter 'buildID' is not null or undefined
      assertParamExists('getBuild', 'buildID', buildID)
      const localVarPath = `/projects/{projectID}/builds/{buildID}`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'buildID'}}`, encodeURIComponent(String(buildID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a specific build for a branch.
     * @param {string} projectID
     * @param {string} branchID
     * @param {string} buildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildForBranch: async (
      projectID: string,
      branchID: string,
      buildID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getBuildForBranch', 'projectID', projectID)
      // verify required parameter 'branchID' is not null or undefined
      assertParamExists('getBuildForBranch', 'branchID', branchID)
      // verify required parameter 'buildID' is not null or undefined
      assertParamExists('getBuildForBranch', 'buildID', buildID)
      const localVarPath =
        `/projects/{projectID}/branches/{branchID}/builds/{buildID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'branchID'}}`, encodeURIComponent(String(branchID)))
          .replace(`{${'buildID'}}`, encodeURIComponent(String(buildID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a specific build for a system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {string} buildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildForSystem: async (
      projectID: string,
      systemID: string,
      buildID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getBuildForSystem', 'projectID', projectID)
      // verify required parameter 'systemID' is not null or undefined
      assertParamExists('getBuildForSystem', 'systemID', systemID)
      // verify required parameter 'buildID' is not null or undefined
      assertParamExists('getBuildForSystem', 'buildID', buildID)
      const localVarPath =
        `/projects/{projectID}/systems/{systemID}/builds/{buildID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'systemID'}}`, encodeURIComponent(String(systemID)))
          .replace(`{${'buildID'}}`, encodeURIComponent(String(buildID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Get all the account names that have created builds in the given project. These usernames are collected automatically from CI systems.
     * @param {string} projectID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBuildAccounts: async (
      projectID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listBuildAccounts', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/builds/accounts`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the list of builds.
     * @param {string} projectID
     * @param {string} [search] A search query. Supports searching by branch_id, system_id
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBuilds: async (
      projectID: string,
      search?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listBuilds', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/builds`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the list of builds for a branch.
     * @param {string} projectID
     * @param {Array<string>} branchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBuildsForBranches: async (
      projectID: string,
      branchID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listBuildsForBranches', 'projectID', projectID)
      // verify required parameter 'branchID' is not null or undefined
      assertParamExists('listBuildsForBranches', 'branchID', branchID)
      const localVarPath = `/projects/{projectID}/branches/{branchID}/builds`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'branchID'}}`, encodeURIComponent(String(branchID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the list of builds for a system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBuildsForSystem: async (
      projectID: string,
      systemID: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listBuildsForSystem', 'projectID', projectID)
      // verify required parameter 'systemID' is not null or undefined
      assertParamExists('listBuildsForSystem', 'systemID', systemID)
      const localVarPath = `/projects/{projectID}/systems/{systemID}/builds`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'systemID'}}`, encodeURIComponent(String(systemID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Updates the build.
     * @param {string} projectID
     * @param {string} buildID
     * @param {UpdateBuildInput} [updateBuildInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBuild: async (
      projectID: string,
      buildID: string,
      updateBuildInput?: UpdateBuildInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('updateBuild', 'projectID', projectID)
      // verify required parameter 'buildID' is not null or undefined
      assertParamExists('updateBuild', 'buildID', buildID)
      const localVarPath = `/projects/{projectID}/builds/{buildID}`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'buildID'}}`, encodeURIComponent(String(buildID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateBuildInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * BuildsApi - functional programming interface
 * @export
 */
export const BuildsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BuildsApiAxiosParamCreator(configuration)
  return {
    /**
     * Adds a build.
     * @param {string} projectID
     * @param {string} branchID
     * @param {CreateBuildForBranchInput | null} [createBuildForBranchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createBuildForBranch(
      projectID: string,
      branchID: string,
      createBuildForBranchInput?: CreateBuildForBranchInput | null,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createBuildForBranch(
          projectID,
          branchID,
          createBuildForBranchInput,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Adds a build.
     * @param {string} projectID
     * @param {string} systemID
     * @param {CreateBuildForSystemInput | null} [createBuildForSystemInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createBuildForSystem(
      projectID: string,
      systemID: string,
      createBuildForSystemInput?: CreateBuildForSystemInput | null,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createBuildForSystem(
          projectID,
          systemID,
          createBuildForSystemInput,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete a build.
     * @param {string} projectID
     * @param {string} branchID
     * @param {string} buildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteBuildForBranch(
      projectID: string,
      branchID: string,
      buildID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteBuildForBranch(
          projectID,
          branchID,
          buildID,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a specific build.
     * @param {string} projectID
     * @param {string} buildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuild(
      projectID: string,
      buildID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuild(
        projectID,
        buildID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a specific build for a branch.
     * @param {string} projectID
     * @param {string} branchID
     * @param {string} buildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildForBranch(
      projectID: string,
      branchID: string,
      buildID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getBuildForBranch(
          projectID,
          branchID,
          buildID,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a specific build for a system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {string} buildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildForSystem(
      projectID: string,
      systemID: string,
      buildID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getBuildForSystem(
          projectID,
          systemID,
          buildID,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Get all the account names that have created builds in the given project. These usernames are collected automatically from CI systems.
     * @param {string} projectID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBuildAccounts(
      projectID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBuildAccounts(projectID, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the list of builds.
     * @param {string} projectID
     * @param {string} [search] A search query. Supports searching by branch_id, system_id
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBuilds(
      projectID: string,
      search?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBuildsOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listBuilds(
        projectID,
        search,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the list of builds for a branch.
     * @param {string} projectID
     * @param {Array<string>} branchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBuildsForBranches(
      projectID: string,
      branchID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBuildsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBuildsForBranches(
          projectID,
          branchID,
          pageSize,
          pageToken,
          orderBy,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the list of builds for a system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBuildsForSystem(
      projectID: string,
      systemID: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBuildsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBuildsForSystem(
          projectID,
          systemID,
          pageSize,
          pageToken,
          orderBy,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Updates the build.
     * @param {string} projectID
     * @param {string} buildID
     * @param {UpdateBuildInput} [updateBuildInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateBuild(
      projectID: string,
      buildID: string,
      updateBuildInput?: UpdateBuildInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateBuild(
        projectID,
        buildID,
        updateBuildInput,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * BuildsApi - factory interface
 * @export
 */
export const BuildsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BuildsApiFp(configuration)
  return {
    /**
     * Adds a build.
     * @param {string} projectID
     * @param {string} branchID
     * @param {CreateBuildForBranchInput | null} [createBuildForBranchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBuildForBranch(
      projectID: string,
      branchID: string,
      createBuildForBranchInput?: CreateBuildForBranchInput | null,
      options?: any
    ): AxiosPromise<Build> {
      return localVarFp
        .createBuildForBranch(
          projectID,
          branchID,
          createBuildForBranchInput,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Adds a build.
     * @param {string} projectID
     * @param {string} systemID
     * @param {CreateBuildForSystemInput | null} [createBuildForSystemInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBuildForSystem(
      projectID: string,
      systemID: string,
      createBuildForSystemInput?: CreateBuildForSystemInput | null,
      options?: any
    ): AxiosPromise<Build> {
      return localVarFp
        .createBuildForSystem(
          projectID,
          systemID,
          createBuildForSystemInput,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Delete a build.
     * @param {string} projectID
     * @param {string} branchID
     * @param {string} buildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBuildForBranch(
      projectID: string,
      branchID: string,
      buildID: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteBuildForBranch(projectID, branchID, buildID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a specific build.
     * @param {string} projectID
     * @param {string} buildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuild(
      projectID: string,
      buildID: string,
      options?: any
    ): AxiosPromise<Build> {
      return localVarFp
        .getBuild(projectID, buildID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a specific build for a branch.
     * @param {string} projectID
     * @param {string} branchID
     * @param {string} buildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildForBranch(
      projectID: string,
      branchID: string,
      buildID: string,
      options?: any
    ): AxiosPromise<Build> {
      return localVarFp
        .getBuildForBranch(projectID, branchID, buildID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a specific build for a system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {string} buildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildForSystem(
      projectID: string,
      systemID: string,
      buildID: string,
      options?: any
    ): AxiosPromise<Build> {
      return localVarFp
        .getBuildForSystem(projectID, systemID, buildID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Get all the account names that have created builds in the given project. These usernames are collected automatically from CI systems.
     * @param {string} projectID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBuildAccounts(
      projectID: string,
      options?: any
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listBuildAccounts(projectID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the list of builds.
     * @param {string} projectID
     * @param {string} [search] A search query. Supports searching by branch_id, system_id
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBuilds(
      projectID: string,
      search?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListBuildsOutput> {
      return localVarFp
        .listBuilds(projectID, search, pageSize, pageToken, orderBy, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the list of builds for a branch.
     * @param {string} projectID
     * @param {Array<string>} branchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBuildsForBranches(
      projectID: string,
      branchID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListBuildsOutput> {
      return localVarFp
        .listBuildsForBranches(
          projectID,
          branchID,
          pageSize,
          pageToken,
          orderBy,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the list of builds for a system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBuildsForSystem(
      projectID: string,
      systemID: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListBuildsOutput> {
      return localVarFp
        .listBuildsForSystem(
          projectID,
          systemID,
          pageSize,
          pageToken,
          orderBy,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Updates the build.
     * @param {string} projectID
     * @param {string} buildID
     * @param {UpdateBuildInput} [updateBuildInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBuild(
      projectID: string,
      buildID: string,
      updateBuildInput?: UpdateBuildInput,
      options?: any
    ): AxiosPromise<Build> {
      return localVarFp
        .updateBuild(projectID, buildID, updateBuildInput, options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * BuildsApi - object-oriented interface
 * @export
 * @class BuildsApi
 * @extends {BaseAPI}
 */
export class BuildsApi extends BaseAPI {
  /**
   * Adds a build.
   * @param {string} projectID
   * @param {string} branchID
   * @param {CreateBuildForBranchInput | null} [createBuildForBranchInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildsApi
   */
  public createBuildForBranch(
    projectID: string,
    branchID: string,
    createBuildForBranchInput?: CreateBuildForBranchInput | null,
    options?: AxiosRequestConfig
  ) {
    return BuildsApiFp(this.configuration)
      .createBuildForBranch(
        projectID,
        branchID,
        createBuildForBranchInput,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Adds a build.
   * @param {string} projectID
   * @param {string} systemID
   * @param {CreateBuildForSystemInput | null} [createBuildForSystemInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildsApi
   */
  public createBuildForSystem(
    projectID: string,
    systemID: string,
    createBuildForSystemInput?: CreateBuildForSystemInput | null,
    options?: AxiosRequestConfig
  ) {
    return BuildsApiFp(this.configuration)
      .createBuildForSystem(
        projectID,
        systemID,
        createBuildForSystemInput,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Delete a build.
   * @param {string} projectID
   * @param {string} branchID
   * @param {string} buildID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildsApi
   */
  public deleteBuildForBranch(
    projectID: string,
    branchID: string,
    buildID: string,
    options?: AxiosRequestConfig
  ) {
    return BuildsApiFp(this.configuration)
      .deleteBuildForBranch(projectID, branchID, buildID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a specific build.
   * @param {string} projectID
   * @param {string} buildID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildsApi
   */
  public getBuild(
    projectID: string,
    buildID: string,
    options?: AxiosRequestConfig
  ) {
    return BuildsApiFp(this.configuration)
      .getBuild(projectID, buildID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a specific build for a branch.
   * @param {string} projectID
   * @param {string} branchID
   * @param {string} buildID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildsApi
   */
  public getBuildForBranch(
    projectID: string,
    branchID: string,
    buildID: string,
    options?: AxiosRequestConfig
  ) {
    return BuildsApiFp(this.configuration)
      .getBuildForBranch(projectID, branchID, buildID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a specific build for a system.
   * @param {string} projectID
   * @param {string} systemID
   * @param {string} buildID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildsApi
   */
  public getBuildForSystem(
    projectID: string,
    systemID: string,
    buildID: string,
    options?: AxiosRequestConfig
  ) {
    return BuildsApiFp(this.configuration)
      .getBuildForSystem(projectID, systemID, buildID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Get all the account names that have created builds in the given project. These usernames are collected automatically from CI systems.
   * @param {string} projectID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildsApi
   */
  public listBuildAccounts(projectID: string, options?: AxiosRequestConfig) {
    return BuildsApiFp(this.configuration)
      .listBuildAccounts(projectID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the list of builds.
   * @param {string} projectID
   * @param {string} [search] A search query. Supports searching by branch_id, system_id
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildsApi
   */
  public listBuilds(
    projectID: string,
    search?: string,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return BuildsApiFp(this.configuration)
      .listBuilds(projectID, search, pageSize, pageToken, orderBy, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the list of builds for a branch.
   * @param {string} projectID
   * @param {Array<string>} branchID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildsApi
   */
  public listBuildsForBranches(
    projectID: string,
    branchID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return BuildsApiFp(this.configuration)
      .listBuildsForBranches(
        projectID,
        branchID,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the list of builds for a system.
   * @param {string} projectID
   * @param {string} systemID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildsApi
   */
  public listBuildsForSystem(
    projectID: string,
    systemID: string,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return BuildsApiFp(this.configuration)
      .listBuildsForSystem(
        projectID,
        systemID,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Updates the build.
   * @param {string} projectID
   * @param {string} buildID
   * @param {UpdateBuildInput} [updateBuildInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildsApi
   */
  public updateBuild(
    projectID: string,
    buildID: string,
    updateBuildInput?: UpdateBuildInput,
    options?: AxiosRequestConfig
  ) {
    return BuildsApiFp(this.configuration)
      .updateBuild(projectID, buildID, updateBuildInput, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Get current quota usage and limits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQuota: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/quota`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read', 'reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read', 'reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read', 'reports:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * Get current quota usage and limits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQuota(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetQuotaOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getQuota(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * Get current quota usage and limits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQuota(options?: any): AxiosPromise<GetQuotaOutput> {
      return localVarFp
        .getQuota(options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Get current quota usage and limits
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getQuota(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getQuota(options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * ExperienceTagsApi - axios parameter creator
 * @export
 */
export const ExperienceTagsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Adds the given experience tag to the given experience.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addExperienceTagToExperience: async (
      projectID: string,
      experienceTagID: string,
      experienceID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('addExperienceTagToExperience', 'projectID', projectID)
      // verify required parameter 'experienceTagID' is not null or undefined
      assertParamExists(
        'addExperienceTagToExperience',
        'experienceTagID',
        experienceTagID
      )
      // verify required parameter 'experienceID' is not null or undefined
      assertParamExists(
        'addExperienceTagToExperience',
        'experienceID',
        experienceID
      )
      const localVarPath =
        `/projects/{projectID}/experienceTags/{experienceTagID}/experiences/{experienceID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(
            `{${'experienceTagID'}}`,
            encodeURIComponent(String(experienceTagID))
          )
          .replace(
            `{${'experienceID'}}`,
            encodeURIComponent(String(experienceID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Registers the given experiences as applicable for the experience tags
     * @param {string} projectID
     * @param {AddTagsToExperiencesInput} [addTagsToExperiencesInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTagsToExperiences: async (
      projectID: string,
      addTagsToExperiencesInput?: AddTagsToExperiencesInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('addTagsToExperiences', 'projectID', projectID)
      const localVarPath =
        `/projects/{projectID}/experienceTags/addExperiences`.replace(
          `{${'projectID'}}`,
          encodeURIComponent(String(projectID))
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        addTagsToExperiencesInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Adds an experience tag.
     * @param {string} projectID
     * @param {CreateExperienceTagInput} [createExperienceTagInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExperienceTag: async (
      projectID: string,
      createExperienceTagInput?: CreateExperienceTagInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('createExperienceTag', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/experienceTags`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createExperienceTagInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Deletes an experience tag.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteExperienceTag: async (
      projectID: string,
      experienceTagID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('deleteExperienceTag', 'projectID', projectID)
      // verify required parameter 'experienceTagID' is not null or undefined
      assertParamExists(
        'deleteExperienceTag',
        'experienceTagID',
        experienceTagID
      )
      const localVarPath =
        `/projects/{projectID}/experienceTags/{experienceTagID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(
            `{${'experienceTagID'}}`,
            encodeURIComponent(String(experienceTagID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a specific experience tag.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExperienceTag: async (
      projectID: string,
      experienceTagID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getExperienceTag', 'projectID', projectID)
      // verify required parameter 'experienceTagID' is not null or undefined
      assertParamExists('getExperienceTag', 'experienceTagID', experienceTagID)
      const localVarPath =
        `/projects/{projectID}/experienceTags/{experienceTagID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(
            `{${'experienceTagID'}}`,
            encodeURIComponent(String(experienceTagID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a list of all experience tags.
     * @param {string} projectID
     * @param {string} [name] Filter experience tags by name. It is recommended to use orderBy&#x3D;rank, so you get the most relevant results first.
     * @param {ListExperienceTagsOrderByEnum} [orderBy]
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listExperienceTags: async (
      projectID: string,
      name?: string,
      orderBy?: ListExperienceTagsOrderByEnum,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listExperienceTags', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/experienceTags`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:read'],
        configuration
      )

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a list of all experiences with the given experience tag.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listExperiencesWithExperienceTag: async (
      projectID: string,
      experienceTagID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'listExperiencesWithExperienceTag',
        'projectID',
        projectID
      )
      // verify required parameter 'experienceTagID' is not null or undefined
      assertParamExists(
        'listExperiencesWithExperienceTag',
        'experienceTagID',
        experienceTagID
      )
      const localVarPath =
        `/projects/{projectID}/experienceTags/{experienceTagID}/experiences`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(
            `{${'experienceTagID'}}`,
            encodeURIComponent(String(experienceTagID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Removes the given experience tag from the given experience.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeExperienceTagFromExperience: async (
      projectID: string,
      experienceTagID: string,
      experienceID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'removeExperienceTagFromExperience',
        'projectID',
        projectID
      )
      // verify required parameter 'experienceTagID' is not null or undefined
      assertParamExists(
        'removeExperienceTagFromExperience',
        'experienceTagID',
        experienceTagID
      )
      // verify required parameter 'experienceID' is not null or undefined
      assertParamExists(
        'removeExperienceTagFromExperience',
        'experienceID',
        experienceID
      )
      const localVarPath =
        `/projects/{projectID}/experienceTags/{experienceTagID}/experiences/{experienceID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(
            `{${'experienceTagID'}}`,
            encodeURIComponent(String(experienceTagID))
          )
          .replace(
            `{${'experienceID'}}`,
            encodeURIComponent(String(experienceID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Updates the experience tag.  Experience membership cannot be changed with this method.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {UpdateExperienceTagInput} [updateExperienceTagInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateExperienceTag: async (
      projectID: string,
      experienceTagID: string,
      updateExperienceTagInput?: UpdateExperienceTagInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('updateExperienceTag', 'projectID', projectID)
      // verify required parameter 'experienceTagID' is not null or undefined
      assertParamExists(
        'updateExperienceTag',
        'experienceTagID',
        experienceTagID
      )
      const localVarPath =
        `/projects/{projectID}/experienceTags/{experienceTagID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(
            `{${'experienceTagID'}}`,
            encodeURIComponent(String(experienceTagID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experienceTags:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateExperienceTagInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * ExperienceTagsApi - functional programming interface
 * @export
 */
export const ExperienceTagsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ExperienceTagsApiAxiosParamCreator(configuration)
  return {
    /**
     * Adds the given experience tag to the given experience.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addExperienceTagToExperience(
      projectID: string,
      experienceTagID: string,
      experienceID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addExperienceTagToExperience(
          projectID,
          experienceTagID,
          experienceID,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Registers the given experiences as applicable for the experience tags
     * @param {string} projectID
     * @param {AddTagsToExperiencesInput} [addTagsToExperiencesInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTagsToExperiences(
      projectID: string,
      addTagsToExperiencesInput?: AddTagsToExperiencesInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addTagsToExperiences(
          projectID,
          addTagsToExperiencesInput,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Adds an experience tag.
     * @param {string} projectID
     * @param {CreateExperienceTagInput} [createExperienceTagInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createExperienceTag(
      projectID: string,
      createExperienceTagInput?: CreateExperienceTagInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperienceTag>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createExperienceTag(
          projectID,
          createExperienceTagInput,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Deletes an experience tag.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteExperienceTag(
      projectID: string,
      experienceTagID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteExperienceTag(
          projectID,
          experienceTagID,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a specific experience tag.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getExperienceTag(
      projectID: string,
      experienceTagID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperienceTag>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getExperienceTag(
          projectID,
          experienceTagID,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a list of all experience tags.
     * @param {string} projectID
     * @param {string} [name] Filter experience tags by name. It is recommended to use orderBy&#x3D;rank, so you get the most relevant results first.
     * @param {ListExperienceTagsOrderByEnum} [orderBy]
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listExperienceTags(
      projectID: string,
      name?: string,
      orderBy?: ListExperienceTagsOrderByEnum,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListExperienceTagsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listExperienceTags(
          projectID,
          name,
          orderBy,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a list of all experiences with the given experience tag.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listExperiencesWithExperienceTag(
      projectID: string,
      experienceTagID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListExperiencesOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listExperiencesWithExperienceTag(
          projectID,
          experienceTagID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Removes the given experience tag from the given experience.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeExperienceTagFromExperience(
      projectID: string,
      experienceTagID: string,
      experienceID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removeExperienceTagFromExperience(
          projectID,
          experienceTagID,
          experienceID,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Updates the experience tag.  Experience membership cannot be changed with this method.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {UpdateExperienceTagInput} [updateExperienceTagInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateExperienceTag(
      projectID: string,
      experienceTagID: string,
      updateExperienceTagInput?: UpdateExperienceTagInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperienceTag>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateExperienceTag(
          projectID,
          experienceTagID,
          updateExperienceTagInput,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * ExperienceTagsApi - factory interface
 * @export
 */
export const ExperienceTagsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ExperienceTagsApiFp(configuration)
  return {
    /**
     * Adds the given experience tag to the given experience.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addExperienceTagToExperience(
      projectID: string,
      experienceTagID: string,
      experienceID: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .addExperienceTagToExperience(
          projectID,
          experienceTagID,
          experienceID,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Registers the given experiences as applicable for the experience tags
     * @param {string} projectID
     * @param {AddTagsToExperiencesInput} [addTagsToExperiencesInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTagsToExperiences(
      projectID: string,
      addTagsToExperiencesInput?: AddTagsToExperiencesInput,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .addTagsToExperiences(projectID, addTagsToExperiencesInput, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Adds an experience tag.
     * @param {string} projectID
     * @param {CreateExperienceTagInput} [createExperienceTagInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExperienceTag(
      projectID: string,
      createExperienceTagInput?: CreateExperienceTagInput,
      options?: any
    ): AxiosPromise<ExperienceTag> {
      return localVarFp
        .createExperienceTag(projectID, createExperienceTagInput, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Deletes an experience tag.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteExperienceTag(
      projectID: string,
      experienceTagID: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteExperienceTag(projectID, experienceTagID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a specific experience tag.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExperienceTag(
      projectID: string,
      experienceTagID: string,
      options?: any
    ): AxiosPromise<ExperienceTag> {
      return localVarFp
        .getExperienceTag(projectID, experienceTagID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a list of all experience tags.
     * @param {string} projectID
     * @param {string} [name] Filter experience tags by name. It is recommended to use orderBy&#x3D;rank, so you get the most relevant results first.
     * @param {ListExperienceTagsOrderByEnum} [orderBy]
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listExperienceTags(
      projectID: string,
      name?: string,
      orderBy?: ListExperienceTagsOrderByEnum,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListExperienceTagsOutput> {
      return localVarFp
        .listExperienceTags(
          projectID,
          name,
          orderBy,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a list of all experiences with the given experience tag.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listExperiencesWithExperienceTag(
      projectID: string,
      experienceTagID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListExperiencesOutput> {
      return localVarFp
        .listExperiencesWithExperienceTag(
          projectID,
          experienceTagID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Removes the given experience tag from the given experience.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeExperienceTagFromExperience(
      projectID: string,
      experienceTagID: string,
      experienceID: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .removeExperienceTagFromExperience(
          projectID,
          experienceTagID,
          experienceID,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Updates the experience tag.  Experience membership cannot be changed with this method.
     * @param {string} projectID
     * @param {string} experienceTagID
     * @param {UpdateExperienceTagInput} [updateExperienceTagInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateExperienceTag(
      projectID: string,
      experienceTagID: string,
      updateExperienceTagInput?: UpdateExperienceTagInput,
      options?: any
    ): AxiosPromise<ExperienceTag> {
      return localVarFp
        .updateExperienceTag(
          projectID,
          experienceTagID,
          updateExperienceTagInput,
          options
        )
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * ExperienceTagsApi - object-oriented interface
 * @export
 * @class ExperienceTagsApi
 * @extends {BaseAPI}
 */
export class ExperienceTagsApi extends BaseAPI {
  /**
   * Adds the given experience tag to the given experience.
   * @param {string} projectID
   * @param {string} experienceTagID
   * @param {string} experienceID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperienceTagsApi
   */
  public addExperienceTagToExperience(
    projectID: string,
    experienceTagID: string,
    experienceID: string,
    options?: AxiosRequestConfig
  ) {
    return ExperienceTagsApiFp(this.configuration)
      .addExperienceTagToExperience(
        projectID,
        experienceTagID,
        experienceID,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Registers the given experiences as applicable for the experience tags
   * @param {string} projectID
   * @param {AddTagsToExperiencesInput} [addTagsToExperiencesInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperienceTagsApi
   */
  public addTagsToExperiences(
    projectID: string,
    addTagsToExperiencesInput?: AddTagsToExperiencesInput,
    options?: AxiosRequestConfig
  ) {
    return ExperienceTagsApiFp(this.configuration)
      .addTagsToExperiences(projectID, addTagsToExperiencesInput, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Adds an experience tag.
   * @param {string} projectID
   * @param {CreateExperienceTagInput} [createExperienceTagInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperienceTagsApi
   */
  public createExperienceTag(
    projectID: string,
    createExperienceTagInput?: CreateExperienceTagInput,
    options?: AxiosRequestConfig
  ) {
    return ExperienceTagsApiFp(this.configuration)
      .createExperienceTag(projectID, createExperienceTagInput, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Deletes an experience tag.
   * @param {string} projectID
   * @param {string} experienceTagID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperienceTagsApi
   */
  public deleteExperienceTag(
    projectID: string,
    experienceTagID: string,
    options?: AxiosRequestConfig
  ) {
    return ExperienceTagsApiFp(this.configuration)
      .deleteExperienceTag(projectID, experienceTagID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a specific experience tag.
   * @param {string} projectID
   * @param {string} experienceTagID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperienceTagsApi
   */
  public getExperienceTag(
    projectID: string,
    experienceTagID: string,
    options?: AxiosRequestConfig
  ) {
    return ExperienceTagsApiFp(this.configuration)
      .getExperienceTag(projectID, experienceTagID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of all experience tags.
   * @param {string} projectID
   * @param {string} [name] Filter experience tags by name. It is recommended to use orderBy&#x3D;rank, so you get the most relevant results first.
   * @param {ListExperienceTagsOrderByEnum} [orderBy]
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperienceTagsApi
   */
  public listExperienceTags(
    projectID: string,
    name?: string,
    orderBy?: ListExperienceTagsOrderByEnum,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return ExperienceTagsApiFp(this.configuration)
      .listExperienceTags(
        projectID,
        name,
        orderBy,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of all experiences with the given experience tag.
   * @param {string} projectID
   * @param {string} experienceTagID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperienceTagsApi
   */
  public listExperiencesWithExperienceTag(
    projectID: string,
    experienceTagID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return ExperienceTagsApiFp(this.configuration)
      .listExperiencesWithExperienceTag(
        projectID,
        experienceTagID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Removes the given experience tag from the given experience.
   * @param {string} projectID
   * @param {string} experienceTagID
   * @param {string} experienceID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperienceTagsApi
   */
  public removeExperienceTagFromExperience(
    projectID: string,
    experienceTagID: string,
    experienceID: string,
    options?: AxiosRequestConfig
  ) {
    return ExperienceTagsApiFp(this.configuration)
      .removeExperienceTagFromExperience(
        projectID,
        experienceTagID,
        experienceID,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Updates the experience tag.  Experience membership cannot be changed with this method.
   * @param {string} projectID
   * @param {string} experienceTagID
   * @param {UpdateExperienceTagInput} [updateExperienceTagInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperienceTagsApi
   */
  public updateExperienceTag(
    projectID: string,
    experienceTagID: string,
    updateExperienceTagInput?: UpdateExperienceTagInput,
    options?: AxiosRequestConfig
  ) {
    return ExperienceTagsApiFp(this.configuration)
      .updateExperienceTag(
        projectID,
        experienceTagID,
        updateExperienceTagInput,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const ListExperienceTagsOrderByEnum = {
  Id: 'id',
  Timestamp: 'timestamp',
  Rank: 'rank'
} as const
export type ListExperienceTagsOrderByEnum =
  (typeof ListExperienceTagsOrderByEnum)[keyof typeof ListExperienceTagsOrderByEnum]

/**
 * ExperiencesApi - axios parameter creator
 * @export
 */
export const ExperiencesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Adds an experience.
     * @param {string} projectID
     * @param {CreateExperienceInput} [createExperienceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExperience: async (
      projectID: string,
      createExperienceInput?: CreateExperienceInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('createExperience', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/experiences`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createExperienceInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Reruns an experience in debug mode.
     * @param {string} projectID
     * @param {string} experienceID
     * @param {DebugExperienceInput} [debugExperienceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    debugExperience: async (
      projectID: string,
      experienceID: string,
      debugExperienceInput?: DebugExperienceInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('debugExperience', 'projectID', projectID)
      // verify required parameter 'experienceID' is not null or undefined
      assertParamExists('debugExperience', 'experienceID', experienceID)
      const localVarPath =
        `/projects/{projectID}/experiences/{experienceID}/debug`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(
            `{${'experienceID'}}`,
            encodeURIComponent(String(experienceID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        debugExperienceInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Deletes an experience.
     * @param {string} projectID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteExperience: async (
      projectID: string,
      experienceID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('deleteExperience', 'projectID', projectID)
      // verify required parameter 'experienceID' is not null or undefined
      assertParamExists('deleteExperience', 'experienceID', experienceID)
      const localVarPath = `/projects/{projectID}/experiences/{experienceID}`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(
          `{${'experienceID'}}`,
          encodeURIComponent(String(experienceID))
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:write'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a specific experience.
     * @param {string} projectID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExperience: async (
      projectID: string,
      experienceID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getExperience', 'projectID', projectID)
      // verify required parameter 'experienceID' is not null or undefined
      assertParamExists('getExperience', 'experienceID', experienceID)
      const localVarPath = `/projects/{projectID}/experiences/{experienceID}`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(
          `{${'experienceID'}}`,
          encodeURIComponent(String(experienceID))
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the systems for a given experience
     * @param {string} projectID
     * @param {string} experienceID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemsForExperience: async (
      projectID: string,
      experienceID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getSystemsForExperience', 'projectID', projectID)
      // verify required parameter 'experienceID' is not null or undefined
      assertParamExists('getSystemsForExperience', 'experienceID', experienceID)
      const localVarPath =
        `/projects/{projectID}/experiences/{experienceID}/systems`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(
            `{${'experienceID'}}`,
            encodeURIComponent(String(experienceID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a list of experience tags associated with a given experience.
     * @param {string} projectID
     * @param {string} experienceID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listExperienceTagsForExperience: async (
      projectID: string,
      experienceID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'listExperienceTagsForExperience',
        'projectID',
        projectID
      )
      // verify required parameter 'experienceID' is not null or undefined
      assertParamExists(
        'listExperienceTagsForExperience',
        'experienceID',
        experienceID
      )
      const localVarPath =
        `/projects/{projectID}/experiences/{experienceID}/experienceTags`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(
            `{${'experienceID'}}`,
            encodeURIComponent(String(experienceID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the list of experiences.
     * @param {string} projectID
     * @param {string} [name] Filter experiences by name
     * @param {string} [text] Filter experiences by a text string on experience name, experience description, or experience tag name
     * @param {string} [search] A search query. Supports searching by tag_id, test_suite_id and system_id
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listExperiences: async (
      projectID: string,
      name?: string,
      text?: string,
      search?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listExperiences', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/experiences`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:read'],
        configuration
      )

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (text !== undefined) {
        localVarQueryParameter['text'] = text
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Updates the experience.
     * @param {string} projectID
     * @param {string} experienceID
     * @param {UpdateExperienceInput} [updateExperienceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateExperience: async (
      projectID: string,
      experienceID: string,
      updateExperienceInput?: UpdateExperienceInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('updateExperience', 'projectID', projectID)
      // verify required parameter 'experienceID' is not null or undefined
      assertParamExists('updateExperience', 'experienceID', experienceID)
      const localVarPath = `/projects/{projectID}/experiences/{experienceID}`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(
          `{${'experienceID'}}`,
          encodeURIComponent(String(experienceID))
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateExperienceInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Validates an experience location can be reached by ReSim.
     * @param {ExperienceLocation} [experienceLocation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateExperienceLocation: async (
      experienceLocation?: ExperienceLocation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/validateExperienceLocation`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['experiences:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        experienceLocation,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * ExperiencesApi - functional programming interface
 * @export
 */
export const ExperiencesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ExperiencesApiAxiosParamCreator(configuration)
  return {
    /**
     * Adds an experience.
     * @param {string} projectID
     * @param {CreateExperienceInput} [createExperienceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createExperience(
      projectID: string,
      createExperienceInput?: CreateExperienceInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experience>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createExperience(
          projectID,
          createExperienceInput,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Reruns an experience in debug mode.
     * @param {string} projectID
     * @param {string} experienceID
     * @param {DebugExperienceInput} [debugExperienceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async debugExperience(
      projectID: string,
      experienceID: string,
      debugExperienceInput?: DebugExperienceInput,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<DebugExperienceOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.debugExperience(
        projectID,
        experienceID,
        debugExperienceInput,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Deletes an experience.
     * @param {string} projectID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteExperience(
      projectID: string,
      experienceID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteExperience(
          projectID,
          experienceID,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a specific experience.
     * @param {string} projectID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getExperience(
      projectID: string,
      experienceID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experience>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getExperience(
        projectID,
        experienceID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the systems for a given experience
     * @param {string} projectID
     * @param {string} experienceID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSystemsForExperience(
      projectID: string,
      experienceID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListSystemsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSystemsForExperience(
          projectID,
          experienceID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a list of experience tags associated with a given experience.
     * @param {string} projectID
     * @param {string} experienceID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listExperienceTagsForExperience(
      projectID: string,
      experienceID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListExperienceTagsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listExperienceTagsForExperience(
          projectID,
          experienceID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the list of experiences.
     * @param {string} projectID
     * @param {string} [name] Filter experiences by name
     * @param {string} [text] Filter experiences by a text string on experience name, experience description, or experience tag name
     * @param {string} [search] A search query. Supports searching by tag_id, test_suite_id and system_id
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listExperiences(
      projectID: string,
      name?: string,
      text?: string,
      search?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListExperiencesOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listExperiences(
        projectID,
        name,
        text,
        search,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Updates the experience.
     * @param {string} projectID
     * @param {string} experienceID
     * @param {UpdateExperienceInput} [updateExperienceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateExperience(
      projectID: string,
      experienceID: string,
      updateExperienceInput?: UpdateExperienceInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experience>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateExperience(
          projectID,
          experienceID,
          updateExperienceInput,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Validates an experience location can be reached by ReSim.
     * @param {ExperienceLocation} [experienceLocation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateExperienceLocation(
      experienceLocation?: ExperienceLocation,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ExperienceLocationContents>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.validateExperienceLocation(
          experienceLocation,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * ExperiencesApi - factory interface
 * @export
 */
export const ExperiencesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ExperiencesApiFp(configuration)
  return {
    /**
     * Adds an experience.
     * @param {string} projectID
     * @param {CreateExperienceInput} [createExperienceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExperience(
      projectID: string,
      createExperienceInput?: CreateExperienceInput,
      options?: any
    ): AxiosPromise<Experience> {
      return localVarFp
        .createExperience(projectID, createExperienceInput, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Reruns an experience in debug mode.
     * @param {string} projectID
     * @param {string} experienceID
     * @param {DebugExperienceInput} [debugExperienceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    debugExperience(
      projectID: string,
      experienceID: string,
      debugExperienceInput?: DebugExperienceInput,
      options?: any
    ): AxiosPromise<DebugExperienceOutput> {
      return localVarFp
        .debugExperience(projectID, experienceID, debugExperienceInput, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Deletes an experience.
     * @param {string} projectID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteExperience(
      projectID: string,
      experienceID: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteExperience(projectID, experienceID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a specific experience.
     * @param {string} projectID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExperience(
      projectID: string,
      experienceID: string,
      options?: any
    ): AxiosPromise<Experience> {
      return localVarFp
        .getExperience(projectID, experienceID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the systems for a given experience
     * @param {string} projectID
     * @param {string} experienceID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemsForExperience(
      projectID: string,
      experienceID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListSystemsOutput> {
      return localVarFp
        .getSystemsForExperience(
          projectID,
          experienceID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a list of experience tags associated with a given experience.
     * @param {string} projectID
     * @param {string} experienceID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listExperienceTagsForExperience(
      projectID: string,
      experienceID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListExperienceTagsOutput> {
      return localVarFp
        .listExperienceTagsForExperience(
          projectID,
          experienceID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the list of experiences.
     * @param {string} projectID
     * @param {string} [name] Filter experiences by name
     * @param {string} [text] Filter experiences by a text string on experience name, experience description, or experience tag name
     * @param {string} [search] A search query. Supports searching by tag_id, test_suite_id and system_id
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listExperiences(
      projectID: string,
      name?: string,
      text?: string,
      search?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListExperiencesOutput> {
      return localVarFp
        .listExperiences(
          projectID,
          name,
          text,
          search,
          pageSize,
          pageToken,
          orderBy,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Updates the experience.
     * @param {string} projectID
     * @param {string} experienceID
     * @param {UpdateExperienceInput} [updateExperienceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateExperience(
      projectID: string,
      experienceID: string,
      updateExperienceInput?: UpdateExperienceInput,
      options?: any
    ): AxiosPromise<Experience> {
      return localVarFp
        .updateExperience(
          projectID,
          experienceID,
          updateExperienceInput,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Validates an experience location can be reached by ReSim.
     * @param {ExperienceLocation} [experienceLocation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateExperienceLocation(
      experienceLocation?: ExperienceLocation,
      options?: any
    ): AxiosPromise<ExperienceLocationContents> {
      return localVarFp
        .validateExperienceLocation(experienceLocation, options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * ExperiencesApi - object-oriented interface
 * @export
 * @class ExperiencesApi
 * @extends {BaseAPI}
 */
export class ExperiencesApi extends BaseAPI {
  /**
   * Adds an experience.
   * @param {string} projectID
   * @param {CreateExperienceInput} [createExperienceInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperiencesApi
   */
  public createExperience(
    projectID: string,
    createExperienceInput?: CreateExperienceInput,
    options?: AxiosRequestConfig
  ) {
    return ExperiencesApiFp(this.configuration)
      .createExperience(projectID, createExperienceInput, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Reruns an experience in debug mode.
   * @param {string} projectID
   * @param {string} experienceID
   * @param {DebugExperienceInput} [debugExperienceInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperiencesApi
   */
  public debugExperience(
    projectID: string,
    experienceID: string,
    debugExperienceInput?: DebugExperienceInput,
    options?: AxiosRequestConfig
  ) {
    return ExperiencesApiFp(this.configuration)
      .debugExperience(projectID, experienceID, debugExperienceInput, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Deletes an experience.
   * @param {string} projectID
   * @param {string} experienceID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperiencesApi
   */
  public deleteExperience(
    projectID: string,
    experienceID: string,
    options?: AxiosRequestConfig
  ) {
    return ExperiencesApiFp(this.configuration)
      .deleteExperience(projectID, experienceID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a specific experience.
   * @param {string} projectID
   * @param {string} experienceID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperiencesApi
   */
  public getExperience(
    projectID: string,
    experienceID: string,
    options?: AxiosRequestConfig
  ) {
    return ExperiencesApiFp(this.configuration)
      .getExperience(projectID, experienceID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the systems for a given experience
   * @param {string} projectID
   * @param {string} experienceID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperiencesApi
   */
  public getSystemsForExperience(
    projectID: string,
    experienceID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return ExperiencesApiFp(this.configuration)
      .getSystemsForExperience(
        projectID,
        experienceID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of experience tags associated with a given experience.
   * @param {string} projectID
   * @param {string} experienceID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperiencesApi
   */
  public listExperienceTagsForExperience(
    projectID: string,
    experienceID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return ExperiencesApiFp(this.configuration)
      .listExperienceTagsForExperience(
        projectID,
        experienceID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the list of experiences.
   * @param {string} projectID
   * @param {string} [name] Filter experiences by name
   * @param {string} [text] Filter experiences by a text string on experience name, experience description, or experience tag name
   * @param {string} [search] A search query. Supports searching by tag_id, test_suite_id and system_id
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperiencesApi
   */
  public listExperiences(
    projectID: string,
    name?: string,
    text?: string,
    search?: string,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return ExperiencesApiFp(this.configuration)
      .listExperiences(
        projectID,
        name,
        text,
        search,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Updates the experience.
   * @param {string} projectID
   * @param {string} experienceID
   * @param {UpdateExperienceInput} [updateExperienceInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperiencesApi
   */
  public updateExperience(
    projectID: string,
    experienceID: string,
    updateExperienceInput?: UpdateExperienceInput,
    options?: AxiosRequestConfig
  ) {
    return ExperiencesApiFp(this.configuration)
      .updateExperience(projectID, experienceID, updateExperienceInput, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Validates an experience location can be reached by ReSim.
   * @param {ExperienceLocation} [experienceLocation]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperiencesApi
   */
  public validateExperienceLocation(
    experienceLocation?: ExperienceLocation,
    options?: AxiosRequestConfig
  ) {
    return ExperiencesApiFp(this.configuration)
      .validateExperienceLocation(experienceLocation, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns whether the service is healthy or not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    health: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/health`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
  return {
    /**
     * Returns whether the service is healthy or not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async health(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.health(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = HealthApiFp(configuration)
  return {
    /**
     * Returns whether the service is healthy or not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    health(options?: any): AxiosPromise<void> {
      return localVarFp
        .health(options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   * Returns whether the service is healthy or not.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public health(options?: AxiosRequestConfig) {
    return HealthApiFp(this.configuration)
      .health(options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieve a single event. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} eventID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventForJob: async (
      projectID: string,
      batchID: string,
      jobID: string,
      eventID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getEventForJob', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('getEventForJob', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('getEventForJob', 'jobID', jobID)
      // verify required parameter 'eventID' is not null or undefined
      assertParamExists('getEventForJob', 'eventID', eventID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/events/{eventID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
          .replace(`{${'eventID'}}`, encodeURIComponent(String(eventID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the (batch) metrics for a given batch. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetrics: async (
      projectID: string,
      batchID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listBatchMetrics', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listBatchMetrics', 'batchID', batchID)
      const localVarPath = `/projects/{projectID}/batches/{batchID}/metrics`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the metrics data associated with a given batch ID
     * @param {string} projectID
     * @param {string} batchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetricsData: async (
      projectID: string,
      batchID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listBatchMetricsData', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listBatchMetricsData', 'batchID', batchID)
      const localVarPath = `/projects/{projectID}/batches/{batchID}/metricsData`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the batch metrics data associated with given batch metric ID(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetricsDataForBatchMetricIDs: async (
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'listBatchMetricsDataForBatchMetricIDs',
        'projectID',
        projectID
      )
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists(
        'listBatchMetricsDataForBatchMetricIDs',
        'batchID',
        batchID
      )
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists(
        'listBatchMetricsDataForBatchMetricIDs',
        'metricID',
        metricID
      )
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/metrics/{metricID}/metricsData`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the batch metrics data associated with given batch metrics data IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetricsDataForBatchMetricsDataIDs: async (
      projectID: string,
      batchID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'listBatchMetricsDataForBatchMetricsDataIDs',
        'projectID',
        projectID
      )
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists(
        'listBatchMetricsDataForBatchMetricsDataIDs',
        'batchID',
        batchID
      )
      // verify required parameter 'metricsDataID' is not null or undefined
      assertParamExists(
        'listBatchMetricsDataForBatchMetricsDataIDs',
        'metricsDataID',
        metricsDataID
      )
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/metricsData/{metricsDataID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(
            `{${'metricsDataID'}}`,
            encodeURIComponent(String(metricsDataID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the batch metrics associated with given batch metric IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetricsForBatchMetricIDs: async (
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'listBatchMetricsForBatchMetricIDs',
        'projectID',
        projectID
      )
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listBatchMetricsForBatchMetricIDs', 'batchID', batchID)
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists(
        'listBatchMetricsForBatchMetricIDs',
        'metricID',
        metricID
      )
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/metrics/{metricID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the events for a given job. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEventsForJob: async (
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listEventsForJob', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listEventsForJob', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('listEventsForJob', 'jobID', jobID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/events`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the metrics data associated with a given job ID
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsDataForJob: async (
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listMetricsDataForJob', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listMetricsDataForJob', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('listMetricsDataForJob', 'jobID', jobID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metricsData`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the metrics data associated with given metric ID(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsDataForMetricIDs: async (
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listMetricsDataForMetricIDs', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listMetricsDataForMetricIDs', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('listMetricsDataForMetricIDs', 'jobID', jobID)
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists('listMetricsDataForMetricIDs', 'metricID', metricID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics/{metricID}/metricsData`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the metrics data associated with given metrics data IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsDataForMetricsDataIDs: async (
      projectID: string,
      batchID: string,
      jobID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'listMetricsDataForMetricsDataIDs',
        'projectID',
        projectID
      )
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listMetricsDataForMetricsDataIDs', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('listMetricsDataForMetricsDataIDs', 'jobID', jobID)
      // verify required parameter 'metricsDataID' is not null or undefined
      assertParamExists(
        'listMetricsDataForMetricsDataIDs',
        'metricsDataID',
        metricsDataID
      )
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metricsData/{metricsDataID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
          .replace(
            `{${'metricsDataID'}}`,
            encodeURIComponent(String(metricsDataID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the metrics for a given job. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsForJob: async (
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listMetricsForJob', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listMetricsForJob', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('listMetricsForJob', 'jobID', jobID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the metrics associated with given metric IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsForMetricIDs: async (
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listMetricsForMetricIDs', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listMetricsForMetricIDs', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('listMetricsForMetricIDs', 'jobID', jobID)
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists('listMetricsForMetricIDs', 'metricID', metricID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics/{metricID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the metrics for a given report. Does not return associated data.
     * @param {string} projectID
     * @param {string} reportID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetrics: async (
      projectID: string,
      reportID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listReportMetrics', 'projectID', projectID)
      // verify required parameter 'reportID' is not null or undefined
      assertParamExists('listReportMetrics', 'reportID', reportID)
      const localVarPath = `/projects/{projectID}/reports/{reportID}/metrics`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'reportID'}}`, encodeURIComponent(String(reportID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the metrics data associated with a given report ID
     * @param {string} projectID
     * @param {string} reportID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetricsData: async (
      projectID: string,
      reportID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listReportMetricsData', 'projectID', projectID)
      // verify required parameter 'reportID' is not null or undefined
      assertParamExists('listReportMetricsData', 'reportID', reportID)
      const localVarPath =
        `/projects/{projectID}/reports/{reportID}/metricsData`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'reportID'}}`, encodeURIComponent(String(reportID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the report metrics data associated with given report metric ID(s)
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetricsDataForReportMetricIDs: async (
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'listReportMetricsDataForReportMetricIDs',
        'projectID',
        projectID
      )
      // verify required parameter 'reportID' is not null or undefined
      assertParamExists(
        'listReportMetricsDataForReportMetricIDs',
        'reportID',
        reportID
      )
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists(
        'listReportMetricsDataForReportMetricIDs',
        'metricID',
        metricID
      )
      const localVarPath =
        `/projects/{projectID}/reports/{reportID}/metrics/{metricID}/metricsData`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'reportID'}}`, encodeURIComponent(String(reportID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the report metrics data associated with given report metrics data IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetricsDataForReportMetricsDataIDs: async (
      projectID: string,
      reportID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'listReportMetricsDataForReportMetricsDataIDs',
        'projectID',
        projectID
      )
      // verify required parameter 'reportID' is not null or undefined
      assertParamExists(
        'listReportMetricsDataForReportMetricsDataIDs',
        'reportID',
        reportID
      )
      // verify required parameter 'metricsDataID' is not null or undefined
      assertParamExists(
        'listReportMetricsDataForReportMetricsDataIDs',
        'metricsDataID',
        metricsDataID
      )
      const localVarPath =
        `/projects/{projectID}/reports/{reportID}/metricsData/{metricsDataID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'reportID'}}`, encodeURIComponent(String(reportID)))
          .replace(
            `{${'metricsDataID'}}`,
            encodeURIComponent(String(metricsDataID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the report metrics associated with given report metric IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetricsForReportMetricIDs: async (
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'listReportMetricsForReportMetricIDs',
        'projectID',
        projectID
      )
      // verify required parameter 'reportID' is not null or undefined
      assertParamExists(
        'listReportMetricsForReportMetricIDs',
        'reportID',
        reportID
      )
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists(
        'listReportMetricsForReportMetricIDs',
        'metricID',
        metricID
      )
      const localVarPath =
        `/projects/{projectID}/reports/{reportID}/metrics/{metricID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'reportID'}}`, encodeURIComponent(String(reportID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * List the tags associated to the given metric id(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTagsForBatchMetrics: async (
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listTagsForBatchMetrics', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listTagsForBatchMetrics', 'batchID', batchID)
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists('listTagsForBatchMetrics', 'metricID', metricID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/metrics/{metricID}/tags`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * List the tags associated to the given job metric id(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTagsForJobMetrics: async (
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listTagsForJobMetrics', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listTagsForJobMetrics', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('listTagsForJobMetrics', 'jobID', jobID)
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists('listTagsForJobMetrics', 'metricID', metricID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics/{metricID}/tags`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the tags associated with given report metric IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTagsForReportMetrics: async (
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listTagsForReportMetrics', 'projectID', projectID)
      // verify required parameter 'reportID' is not null or undefined
      assertParamExists('listTagsForReportMetrics', 'reportID', reportID)
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists('listTagsForReportMetrics', 'metricID', metricID)
      const localVarPath =
        `/projects/{projectID}/reports/{reportID}/metrics/{metricID}/tags`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'reportID'}}`, encodeURIComponent(String(reportID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Updates the event.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} eventID
     * @param {UpdateEventInput} [updateEventInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEvent: async (
      projectID: string,
      batchID: string,
      jobID: string,
      eventID: string,
      updateEventInput?: UpdateEventInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('updateEvent', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('updateEvent', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('updateEvent', 'jobID', jobID)
      // verify required parameter 'eventID' is not null or undefined
      assertParamExists('updateEvent', 'eventID', eventID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/events/{eventID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
          .replace(`{${'eventID'}}`, encodeURIComponent(String(eventID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateEventInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
  return {
    /**
     * Retrieve a single event. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} eventID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      eventID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventForJob(
        projectID,
        batchID,
        jobID,
        eventID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the (batch) metrics for a given batch. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBatchMetrics(
      projectID: string,
      batchID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBatchMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBatchMetrics(
          projectID,
          batchID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the metrics data associated with a given batch ID
     * @param {string} projectID
     * @param {string} batchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBatchMetricsData(
      projectID: string,
      batchID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBatchMetricsDataOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBatchMetricsData(
          projectID,
          batchID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the batch metrics data associated with given batch metric ID(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBatchMetricsDataForBatchMetricIDs(
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBatchMetricsDataForBatchMetricIDsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBatchMetricsDataForBatchMetricIDs(
          projectID,
          batchID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the batch metrics data associated with given batch metrics data IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBatchMetricsDataForBatchMetricsDataIDs(
      projectID: string,
      batchID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBatchMetricsDataOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBatchMetricsDataForBatchMetricsDataIDs(
          projectID,
          batchID,
          metricsDataID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the batch metrics associated with given batch metric IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBatchMetricsForBatchMetricIDs(
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBatchMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBatchMetricsForBatchMetricIDs(
          projectID,
          batchID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the events for a given job. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listEventsForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListJobEventsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listEventsForJob(
          projectID,
          batchID,
          jobID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the metrics data associated with a given job ID
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMetricsDataForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListJobMetricsDataOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listMetricsDataForJob(
          projectID,
          batchID,
          jobID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the metrics data associated with given metric ID(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMetricsDataForMetricIDs(
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListMetricsDataAndMetricIDOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listMetricsDataForMetricIDs(
          projectID,
          batchID,
          jobID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the metrics data associated with given metrics data IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMetricsDataForMetricsDataIDs(
      projectID: string,
      batchID: string,
      jobID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListJobMetricsDataOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listMetricsDataForMetricsDataIDs(
          projectID,
          batchID,
          jobID,
          metricsDataID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the metrics for a given job. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMetricsForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListJobMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listMetricsForJob(
          projectID,
          batchID,
          jobID,
          pageSize,
          pageToken,
          orderBy,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the metrics associated with given metric IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMetricsForMetricIDs(
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListJobMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listMetricsForMetricIDs(
          projectID,
          batchID,
          jobID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the metrics for a given report. Does not return associated data.
     * @param {string} projectID
     * @param {string} reportID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listReportMetrics(
      projectID: string,
      reportID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListReportMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listReportMetrics(
          projectID,
          reportID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the metrics data associated with a given report ID
     * @param {string} projectID
     * @param {string} reportID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listReportMetricsData(
      projectID: string,
      reportID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListReportMetricsDataOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listReportMetricsData(
          projectID,
          reportID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the report metrics data associated with given report metric ID(s)
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listReportMetricsDataForReportMetricIDs(
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListReportMetricsDataForReportMetricIDsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listReportMetricsDataForReportMetricIDs(
          projectID,
          reportID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the report metrics data associated with given report metrics data IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listReportMetricsDataForReportMetricsDataIDs(
      projectID: string,
      reportID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListReportMetricsDataOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listReportMetricsDataForReportMetricsDataIDs(
          projectID,
          reportID,
          metricsDataID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the report metrics associated with given report metric IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listReportMetricsForReportMetricIDs(
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListReportMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listReportMetricsForReportMetricIDs(
          projectID,
          reportID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the tags associated to the given metric id(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTagsForBatchMetrics(
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListTagsForBatchMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listTagsForBatchMetrics(
          projectID,
          batchID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the tags associated to the given job metric id(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTagsForJobMetrics(
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListTagsForJobMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listTagsForJobMetrics(
          projectID,
          batchID,
          jobID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the tags associated with given report metric IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTagsForReportMetrics(
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListTagsForReportMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listTagsForReportMetrics(
          projectID,
          reportID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Updates the event.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} eventID
     * @param {UpdateEventInput} [updateEventInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEvent(
      projectID: string,
      batchID: string,
      jobID: string,
      eventID: string,
      updateEventInput?: UpdateEventInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(
        projectID,
        batchID,
        jobID,
        eventID,
        updateEventInput,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MetricsApiFp(configuration)
  return {
    /**
     * Retrieve a single event. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} eventID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      eventID: string,
      options?: any
    ): AxiosPromise<Event> {
      return localVarFp
        .getEventForJob(projectID, batchID, jobID, eventID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the (batch) metrics for a given batch. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetrics(
      projectID: string,
      batchID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListBatchMetricsOutput> {
      return localVarFp
        .listBatchMetrics(projectID, batchID, pageSize, pageToken, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the metrics data associated with a given batch ID
     * @param {string} projectID
     * @param {string} batchID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetricsData(
      projectID: string,
      batchID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListBatchMetricsDataOutput> {
      return localVarFp
        .listBatchMetricsData(projectID, batchID, pageSize, pageToken, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the batch metrics data associated with given batch metric ID(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetricsDataForBatchMetricIDs(
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListBatchMetricsDataForBatchMetricIDsOutput> {
      return localVarFp
        .listBatchMetricsDataForBatchMetricIDs(
          projectID,
          batchID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the batch metrics data associated with given batch metrics data IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetricsDataForBatchMetricsDataIDs(
      projectID: string,
      batchID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListBatchMetricsDataOutput> {
      return localVarFp
        .listBatchMetricsDataForBatchMetricsDataIDs(
          projectID,
          batchID,
          metricsDataID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the batch metrics associated with given batch metric IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBatchMetricsForBatchMetricIDs(
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListBatchMetricsOutput> {
      return localVarFp
        .listBatchMetricsForBatchMetricIDs(
          projectID,
          batchID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the events for a given job. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEventsForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListJobEventsOutput> {
      return localVarFp
        .listEventsForJob(
          projectID,
          batchID,
          jobID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the metrics data associated with a given job ID
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsDataForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListJobMetricsDataOutput> {
      return localVarFp
        .listMetricsDataForJob(
          projectID,
          batchID,
          jobID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the metrics data associated with given metric ID(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsDataForMetricIDs(
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListMetricsDataAndMetricIDOutput> {
      return localVarFp
        .listMetricsDataForMetricIDs(
          projectID,
          batchID,
          jobID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the metrics data associated with given metrics data IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsDataForMetricsDataIDs(
      projectID: string,
      batchID: string,
      jobID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListJobMetricsDataOutput> {
      return localVarFp
        .listMetricsDataForMetricsDataIDs(
          projectID,
          batchID,
          jobID,
          metricsDataID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the metrics for a given job. Does not return associated data.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsForJob(
      projectID: string,
      batchID: string,
      jobID: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListJobMetricsOutput> {
      return localVarFp
        .listMetricsForJob(
          projectID,
          batchID,
          jobID,
          pageSize,
          pageToken,
          orderBy,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the metrics associated with given metric IDs
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsForMetricIDs(
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListJobMetricsOutput> {
      return localVarFp
        .listMetricsForMetricIDs(
          projectID,
          batchID,
          jobID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the metrics for a given report. Does not return associated data.
     * @param {string} projectID
     * @param {string} reportID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetrics(
      projectID: string,
      reportID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListReportMetricsOutput> {
      return localVarFp
        .listReportMetrics(projectID, reportID, pageSize, pageToken, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the metrics data associated with a given report ID
     * @param {string} projectID
     * @param {string} reportID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetricsData(
      projectID: string,
      reportID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListReportMetricsDataOutput> {
      return localVarFp
        .listReportMetricsData(
          projectID,
          reportID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the report metrics data associated with given report metric ID(s)
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetricsDataForReportMetricIDs(
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListReportMetricsDataForReportMetricIDsOutput> {
      return localVarFp
        .listReportMetricsDataForReportMetricIDs(
          projectID,
          reportID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the report metrics data associated with given report metrics data IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetricsDataForReportMetricsDataIDs(
      projectID: string,
      reportID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListReportMetricsDataOutput> {
      return localVarFp
        .listReportMetricsDataForReportMetricsDataIDs(
          projectID,
          reportID,
          metricsDataID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the report metrics associated with given report metric IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetricsForReportMetricIDs(
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListReportMetricsOutput> {
      return localVarFp
        .listReportMetricsForReportMetricIDs(
          projectID,
          reportID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * List the tags associated to the given metric id(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTagsForBatchMetrics(
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListTagsForBatchMetricsOutput> {
      return localVarFp
        .listTagsForBatchMetrics(
          projectID,
          batchID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * List the tags associated to the given job metric id(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTagsForJobMetrics(
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListTagsForJobMetricsOutput> {
      return localVarFp
        .listTagsForJobMetrics(
          projectID,
          batchID,
          jobID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the tags associated with given report metric IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTagsForReportMetrics(
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListTagsForReportMetricsOutput> {
      return localVarFp
        .listTagsForReportMetrics(
          projectID,
          reportID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Updates the event.
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {string} eventID
     * @param {UpdateEventInput} [updateEventInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEvent(
      projectID: string,
      batchID: string,
      jobID: string,
      eventID: string,
      updateEventInput?: UpdateEventInput,
      options?: any
    ): AxiosPromise<Event> {
      return localVarFp
        .updateEvent(
          projectID,
          batchID,
          jobID,
          eventID,
          updateEventInput,
          options
        )
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
  /**
   * Retrieve a single event. Does not return associated data.
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {string} eventID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public getEventForJob(
    projectID: string,
    batchID: string,
    jobID: string,
    eventID: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .getEventForJob(projectID, batchID, jobID, eventID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the (batch) metrics for a given batch. Does not return associated data.
   * @param {string} projectID
   * @param {string} batchID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listBatchMetrics(
    projectID: string,
    batchID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listBatchMetrics(projectID, batchID, pageSize, pageToken, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the metrics data associated with a given batch ID
   * @param {string} projectID
   * @param {string} batchID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listBatchMetricsData(
    projectID: string,
    batchID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listBatchMetricsData(projectID, batchID, pageSize, pageToken, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the batch metrics data associated with given batch metric ID(s)
   * @param {string} projectID
   * @param {string} batchID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listBatchMetricsDataForBatchMetricIDs(
    projectID: string,
    batchID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listBatchMetricsDataForBatchMetricIDs(
        projectID,
        batchID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the batch metrics data associated with given batch metrics data IDs
   * @param {string} projectID
   * @param {string} batchID
   * @param {Array<string>} metricsDataID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listBatchMetricsDataForBatchMetricsDataIDs(
    projectID: string,
    batchID: string,
    metricsDataID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listBatchMetricsDataForBatchMetricsDataIDs(
        projectID,
        batchID,
        metricsDataID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the batch metrics associated with given batch metric IDs
   * @param {string} projectID
   * @param {string} batchID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listBatchMetricsForBatchMetricIDs(
    projectID: string,
    batchID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listBatchMetricsForBatchMetricIDs(
        projectID,
        batchID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the events for a given job. Does not return associated data.
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listEventsForJob(
    projectID: string,
    batchID: string,
    jobID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listEventsForJob(projectID, batchID, jobID, pageSize, pageToken, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the metrics data associated with a given job ID
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listMetricsDataForJob(
    projectID: string,
    batchID: string,
    jobID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listMetricsDataForJob(
        projectID,
        batchID,
        jobID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the metrics data associated with given metric ID(s)
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listMetricsDataForMetricIDs(
    projectID: string,
    batchID: string,
    jobID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listMetricsDataForMetricIDs(
        projectID,
        batchID,
        jobID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the metrics data associated with given metrics data IDs
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {Array<string>} metricsDataID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listMetricsDataForMetricsDataIDs(
    projectID: string,
    batchID: string,
    jobID: string,
    metricsDataID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listMetricsDataForMetricsDataIDs(
        projectID,
        batchID,
        jobID,
        metricsDataID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the metrics for a given job. Does not return associated data.
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listMetricsForJob(
    projectID: string,
    batchID: string,
    jobID: string,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listMetricsForJob(
        projectID,
        batchID,
        jobID,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the metrics associated with given metric IDs
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listMetricsForMetricIDs(
    projectID: string,
    batchID: string,
    jobID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listMetricsForMetricIDs(
        projectID,
        batchID,
        jobID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the metrics for a given report. Does not return associated data.
   * @param {string} projectID
   * @param {string} reportID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listReportMetrics(
    projectID: string,
    reportID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listReportMetrics(projectID, reportID, pageSize, pageToken, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the metrics data associated with a given report ID
   * @param {string} projectID
   * @param {string} reportID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listReportMetricsData(
    projectID: string,
    reportID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listReportMetricsData(projectID, reportID, pageSize, pageToken, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the report metrics data associated with given report metric ID(s)
   * @param {string} projectID
   * @param {string} reportID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listReportMetricsDataForReportMetricIDs(
    projectID: string,
    reportID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listReportMetricsDataForReportMetricIDs(
        projectID,
        reportID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the report metrics data associated with given report metrics data IDs
   * @param {string} projectID
   * @param {string} reportID
   * @param {Array<string>} metricsDataID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listReportMetricsDataForReportMetricsDataIDs(
    projectID: string,
    reportID: string,
    metricsDataID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listReportMetricsDataForReportMetricsDataIDs(
        projectID,
        reportID,
        metricsDataID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the report metrics associated with given report metric IDs
   * @param {string} projectID
   * @param {string} reportID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listReportMetricsForReportMetricIDs(
    projectID: string,
    reportID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listReportMetricsForReportMetricIDs(
        projectID,
        reportID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * List the tags associated to the given metric id(s)
   * @param {string} projectID
   * @param {string} batchID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listTagsForBatchMetrics(
    projectID: string,
    batchID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listTagsForBatchMetrics(
        projectID,
        batchID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * List the tags associated to the given job metric id(s)
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listTagsForJobMetrics(
    projectID: string,
    batchID: string,
    jobID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listTagsForJobMetrics(
        projectID,
        batchID,
        jobID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the tags associated with given report metric IDs
   * @param {string} projectID
   * @param {string} reportID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public listTagsForReportMetrics(
    projectID: string,
    reportID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .listTagsForReportMetrics(
        projectID,
        reportID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Updates the event.
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {string} eventID
   * @param {UpdateEventInput} [updateEventInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsApi
   */
  public updateEvent(
    projectID: string,
    batchID: string,
    jobID: string,
    eventID: string,
    updateEventInput?: UpdateEventInput,
    options?: AxiosRequestConfig
  ) {
    return MetricsApiFp(this.configuration)
      .updateEvent(
        projectID,
        batchID,
        jobID,
        eventID,
        updateEventInput,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * MetricsBuildsApi - axios parameter creator
 * @export
 */
export const MetricsBuildsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Adds a metrics build.
     * @param {string} projectID
     * @param {CreateMetricsBuildInput} [createMetricsBuildInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMetricsBuild: async (
      projectID: string,
      createMetricsBuildInput?: CreateMetricsBuildInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('createMetricsBuild', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/metricsBuilds`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createMetricsBuildInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a specific metrics build.
     * @param {string} projectID
     * @param {string} metricsBuildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetricsBuild: async (
      projectID: string,
      metricsBuildID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getMetricsBuild', 'projectID', projectID)
      // verify required parameter 'metricsBuildID' is not null or undefined
      assertParamExists('getMetricsBuild', 'metricsBuildID', metricsBuildID)
      const localVarPath =
        `/projects/{projectID}/metricsBuilds/{metricsBuildID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(
            `{${'metricsBuildID'}}`,
            encodeURIComponent(String(metricsBuildID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the systems for a given metrics build
     * @param {string} projectID
     * @param {string} metricsBuildID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemsForMetricsBuild: async (
      projectID: string,
      metricsBuildID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getSystemsForMetricsBuild', 'projectID', projectID)
      // verify required parameter 'metricsBuildID' is not null or undefined
      assertParamExists(
        'getSystemsForMetricsBuild',
        'metricsBuildID',
        metricsBuildID
      )
      const localVarPath =
        `/projects/{projectID}/metricsBuilds/{metricsBuildID}/systems`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(
            `{${'metricsBuildID'}}`,
            encodeURIComponent(String(metricsBuildID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the list of metrics builds.
     * @param {string} projectID
     * @param {string} [systemID] A search query. Supports searching by system_id
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsBuilds: async (
      projectID: string,
      systemID?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listMetricsBuilds', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/metricsBuilds`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['builds:read'],
        configuration
      )

      if (systemID !== undefined) {
        localVarQueryParameter['systemID'] = systemID
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * MetricsBuildsApi - functional programming interface
 * @export
 */
export const MetricsBuildsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    MetricsBuildsApiAxiosParamCreator(configuration)
  return {
    /**
     * Adds a metrics build.
     * @param {string} projectID
     * @param {CreateMetricsBuildInput} [createMetricsBuildInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createMetricsBuild(
      projectID: string,
      createMetricsBuildInput?: CreateMetricsBuildInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsBuild>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createMetricsBuild(
          projectID,
          createMetricsBuildInput,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a specific metrics build.
     * @param {string} projectID
     * @param {string} metricsBuildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMetricsBuild(
      projectID: string,
      metricsBuildID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsBuild>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricsBuild(
        projectID,
        metricsBuildID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the systems for a given metrics build
     * @param {string} projectID
     * @param {string} metricsBuildID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSystemsForMetricsBuild(
      projectID: string,
      metricsBuildID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListSystemsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSystemsForMetricsBuild(
          projectID,
          metricsBuildID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the list of metrics builds.
     * @param {string} projectID
     * @param {string} [systemID] A search query. Supports searching by system_id
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMetricsBuilds(
      projectID: string,
      systemID?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListMetricsBuildOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listMetricsBuilds(
          projectID,
          systemID,
          pageSize,
          pageToken,
          orderBy,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * MetricsBuildsApi - factory interface
 * @export
 */
export const MetricsBuildsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MetricsBuildsApiFp(configuration)
  return {
    /**
     * Adds a metrics build.
     * @param {string} projectID
     * @param {CreateMetricsBuildInput} [createMetricsBuildInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMetricsBuild(
      projectID: string,
      createMetricsBuildInput?: CreateMetricsBuildInput,
      options?: any
    ): AxiosPromise<MetricsBuild> {
      return localVarFp
        .createMetricsBuild(projectID, createMetricsBuildInput, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a specific metrics build.
     * @param {string} projectID
     * @param {string} metricsBuildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetricsBuild(
      projectID: string,
      metricsBuildID: string,
      options?: any
    ): AxiosPromise<MetricsBuild> {
      return localVarFp
        .getMetricsBuild(projectID, metricsBuildID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the systems for a given metrics build
     * @param {string} projectID
     * @param {string} metricsBuildID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemsForMetricsBuild(
      projectID: string,
      metricsBuildID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListSystemsOutput> {
      return localVarFp
        .getSystemsForMetricsBuild(
          projectID,
          metricsBuildID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the list of metrics builds.
     * @param {string} projectID
     * @param {string} [systemID] A search query. Supports searching by system_id
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMetricsBuilds(
      projectID: string,
      systemID?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListMetricsBuildOutput> {
      return localVarFp
        .listMetricsBuilds(
          projectID,
          systemID,
          pageSize,
          pageToken,
          orderBy,
          options
        )
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * MetricsBuildsApi - object-oriented interface
 * @export
 * @class MetricsBuildsApi
 * @extends {BaseAPI}
 */
export class MetricsBuildsApi extends BaseAPI {
  /**
   * Adds a metrics build.
   * @param {string} projectID
   * @param {CreateMetricsBuildInput} [createMetricsBuildInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsBuildsApi
   */
  public createMetricsBuild(
    projectID: string,
    createMetricsBuildInput?: CreateMetricsBuildInput,
    options?: AxiosRequestConfig
  ) {
    return MetricsBuildsApiFp(this.configuration)
      .createMetricsBuild(projectID, createMetricsBuildInput, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a specific metrics build.
   * @param {string} projectID
   * @param {string} metricsBuildID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsBuildsApi
   */
  public getMetricsBuild(
    projectID: string,
    metricsBuildID: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsBuildsApiFp(this.configuration)
      .getMetricsBuild(projectID, metricsBuildID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the systems for a given metrics build
   * @param {string} projectID
   * @param {string} metricsBuildID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsBuildsApi
   */
  public getSystemsForMetricsBuild(
    projectID: string,
    metricsBuildID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsBuildsApiFp(this.configuration)
      .getSystemsForMetricsBuild(
        projectID,
        metricsBuildID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the list of metrics builds.
   * @param {string} projectID
   * @param {string} [systemID] A search query. Supports searching by system_id
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetricsBuildsApi
   */
  public listMetricsBuilds(
    projectID: string,
    systemID?: string,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return MetricsBuildsApiFp(this.configuration)
      .listMetricsBuilds(
        projectID,
        systemID,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * ParameterSweepsApi - axios parameter creator
 * @export
 */
export const ParameterSweepsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Cancels a parameter sweep.
     * @param {string} projectID
     * @param {string} sweepID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelParameterSweep: async (
      projectID: string,
      sweepID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('cancelParameterSweep', 'projectID', projectID)
      // verify required parameter 'sweepID' is not null or undefined
      assertParamExists('cancelParameterSweep', 'sweepID', sweepID)
      const localVarPath = `/projects/{projectID}/sweeps/{sweepID}/:cancel`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'sweepID'}}`, encodeURIComponent(String(sweepID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['sweeps:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['sweeps:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['sweeps:write'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Adds a parameter sweep.  ID should be omitted and will be returned in the response.
     * @param {string} projectID
     * @param {ParameterSweepInput} [parameterSweepInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createParameterSweep: async (
      projectID: string,
      parameterSweepInput?: ParameterSweepInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('createParameterSweep', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/sweeps`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['sweeps:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['sweeps:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['sweeps:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        parameterSweepInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a specific parameter sweep.
     * @param {string} projectID
     * @param {string} sweepID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParameterSweep: async (
      projectID: string,
      sweepID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getParameterSweep', 'projectID', projectID)
      // verify required parameter 'sweepID' is not null or undefined
      assertParamExists('getParameterSweep', 'sweepID', sweepID)
      const localVarPath = `/projects/{projectID}/sweeps/{sweepID}`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'sweepID'}}`, encodeURIComponent(String(sweepID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['sweeps:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['sweeps:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['sweeps:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the list of parameter sweeps.
     * @param {string} projectID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listParameterSweeps: async (
      projectID: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listParameterSweeps', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/sweeps`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['sweeps:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['sweeps:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['sweeps:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Get all the account names that have triggered sweeps in the given project. These usernames are collected automatically from CI systems.
     * @param {string} projectID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSweepAccounts: async (
      projectID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listSweepAccounts', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/sweeps/accounts`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['sweeps:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['sweeps:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['sweeps:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * ParameterSweepsApi - functional programming interface
 * @export
 */
export const ParameterSweepsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ParameterSweepsApiAxiosParamCreator(configuration)
  return {
    /**
     * Cancels a parameter sweep.
     * @param {string} projectID
     * @param {string} sweepID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelParameterSweep(
      projectID: string,
      sweepID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.cancelParameterSweep(
          projectID,
          sweepID,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Adds a parameter sweep.  ID should be omitted and will be returned in the response.
     * @param {string} projectID
     * @param {ParameterSweepInput} [parameterSweepInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createParameterSweep(
      projectID: string,
      parameterSweepInput?: ParameterSweepInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParameterSweep>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createParameterSweep(
          projectID,
          parameterSweepInput,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a specific parameter sweep.
     * @param {string} projectID
     * @param {string} sweepID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getParameterSweep(
      projectID: string,
      sweepID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParameterSweep>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getParameterSweep(
          projectID,
          sweepID,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the list of parameter sweeps.
     * @param {string} projectID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listParameterSweeps(
      projectID: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListParameterSweepsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listParameterSweeps(
          projectID,
          pageSize,
          pageToken,
          orderBy,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Get all the account names that have triggered sweeps in the given project. These usernames are collected automatically from CI systems.
     * @param {string} projectID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listSweepAccounts(
      projectID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listSweepAccounts(projectID, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * ParameterSweepsApi - factory interface
 * @export
 */
export const ParameterSweepsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ParameterSweepsApiFp(configuration)
  return {
    /**
     * Cancels a parameter sweep.
     * @param {string} projectID
     * @param {string} sweepID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelParameterSweep(
      projectID: string,
      sweepID: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .cancelParameterSweep(projectID, sweepID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Adds a parameter sweep.  ID should be omitted and will be returned in the response.
     * @param {string} projectID
     * @param {ParameterSweepInput} [parameterSweepInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createParameterSweep(
      projectID: string,
      parameterSweepInput?: ParameterSweepInput,
      options?: any
    ): AxiosPromise<ParameterSweep> {
      return localVarFp
        .createParameterSweep(projectID, parameterSweepInput, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a specific parameter sweep.
     * @param {string} projectID
     * @param {string} sweepID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParameterSweep(
      projectID: string,
      sweepID: string,
      options?: any
    ): AxiosPromise<ParameterSweep> {
      return localVarFp
        .getParameterSweep(projectID, sweepID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the list of parameter sweeps.
     * @param {string} projectID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listParameterSweeps(
      projectID: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListParameterSweepsOutput> {
      return localVarFp
        .listParameterSweeps(projectID, pageSize, pageToken, orderBy, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Get all the account names that have triggered sweeps in the given project. These usernames are collected automatically from CI systems.
     * @param {string} projectID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSweepAccounts(
      projectID: string,
      options?: any
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listSweepAccounts(projectID, options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * ParameterSweepsApi - object-oriented interface
 * @export
 * @class ParameterSweepsApi
 * @extends {BaseAPI}
 */
export class ParameterSweepsApi extends BaseAPI {
  /**
   * Cancels a parameter sweep.
   * @param {string} projectID
   * @param {string} sweepID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ParameterSweepsApi
   */
  public cancelParameterSweep(
    projectID: string,
    sweepID: string,
    options?: AxiosRequestConfig
  ) {
    return ParameterSweepsApiFp(this.configuration)
      .cancelParameterSweep(projectID, sweepID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Adds a parameter sweep.  ID should be omitted and will be returned in the response.
   * @param {string} projectID
   * @param {ParameterSweepInput} [parameterSweepInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ParameterSweepsApi
   */
  public createParameterSweep(
    projectID: string,
    parameterSweepInput?: ParameterSweepInput,
    options?: AxiosRequestConfig
  ) {
    return ParameterSweepsApiFp(this.configuration)
      .createParameterSweep(projectID, parameterSweepInput, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a specific parameter sweep.
   * @param {string} projectID
   * @param {string} sweepID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ParameterSweepsApi
   */
  public getParameterSweep(
    projectID: string,
    sweepID: string,
    options?: AxiosRequestConfig
  ) {
    return ParameterSweepsApiFp(this.configuration)
      .getParameterSweep(projectID, sweepID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the list of parameter sweeps.
   * @param {string} projectID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ParameterSweepsApi
   */
  public listParameterSweeps(
    projectID: string,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return ParameterSweepsApiFp(this.configuration)
      .listParameterSweeps(projectID, pageSize, pageToken, orderBy, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Get all the account names that have triggered sweeps in the given project. These usernames are collected automatically from CI systems.
   * @param {string} projectID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ParameterSweepsApi
   */
  public listSweepAccounts(projectID: string, options?: AxiosRequestConfig) {
    return ParameterSweepsApiFp(this.configuration)
      .listSweepAccounts(projectID, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Archived a project.
     * @param {string} projectID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archiveProject: async (
      projectID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('archiveProject', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:write'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Adds a branch for a project.
     * @param {string} projectID
     * @param {CreateBranchInput} [createBranchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBranchForProject: async (
      projectID: string,
      createBranchInput?: CreateBranchInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('createBranchForProject', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/branches`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createBranchInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Adds a project.
     * @param {CreateProjectInput} [createProjectInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProject: async (
      createProjectInput?: CreateProjectInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/projects`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createProjectInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Deletes a branch for a project.
     * @param {string} projectID
     * @param {string} branchID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBranchForProject: async (
      projectID: string,
      branchID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('deleteBranchForProject', 'projectID', projectID)
      // verify required parameter 'branchID' is not null or undefined
      assertParamExists('deleteBranchForProject', 'branchID', branchID)
      const localVarPath = `/projects/{projectID}/branches/{branchID}`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'branchID'}}`, encodeURIComponent(String(branchID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:write'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a specific branch for a project.
     * @param {string} projectID
     * @param {string} branchID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBranchForProject: async (
      projectID: string,
      branchID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getBranchForProject', 'projectID', projectID)
      // verify required parameter 'branchID' is not null or undefined
      assertParamExists('getBranchForProject', 'branchID', branchID)
      const localVarPath = `/projects/{projectID}/branches/{branchID}`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'branchID'}}`, encodeURIComponent(String(branchID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a specific project.
     * @param {string} projectID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProject: async (
      projectID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getProject', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the list of branches for a project.
     * @param {string} projectID
     * @param {string} [name] Filter branches by name
     * @param {BranchType} [branchType] Filter branches by branchType
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBranchesForProject: async (
      projectID: string,
      name?: string,
      branchType?: BranchType,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listBranchesForProject', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/branches`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:read'],
        configuration
      )

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (branchType !== undefined) {
        localVarQueryParameter['branchType'] = branchType
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the list of projects.
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProjects: async (
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/projects`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Updates the project.
     * @param {string} projectID
     * @param {UpdateProjectInput} [updateProjectInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProject: async (
      projectID: string,
      updateProjectInput?: UpdateProjectInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('updateProject', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['projects:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateProjectInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
  return {
    /**
     * Archived a project.
     * @param {string} projectID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async archiveProject(
      projectID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.archiveProject(
        projectID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Adds a branch for a project.
     * @param {string} projectID
     * @param {CreateBranchInput} [createBranchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createBranchForProject(
      projectID: string,
      createBranchInput?: CreateBranchInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createBranchForProject(
          projectID,
          createBranchInput,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Adds a project.
     * @param {CreateProjectInput} [createProjectInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createProject(
      createProjectInput?: CreateProjectInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(
        createProjectInput,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Deletes a branch for a project.
     * @param {string} projectID
     * @param {string} branchID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteBranchForProject(
      projectID: string,
      branchID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteBranchForProject(
          projectID,
          branchID,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a specific branch for a project.
     * @param {string} projectID
     * @param {string} branchID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBranchForProject(
      projectID: string,
      branchID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getBranchForProject(
          projectID,
          branchID,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a specific project.
     * @param {string} projectID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProject(
      projectID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(
        projectID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the list of branches for a project.
     * @param {string} projectID
     * @param {string} [name] Filter branches by name
     * @param {BranchType} [branchType] Filter branches by branchType
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBranchesForProject(
      projectID: string,
      name?: string,
      branchType?: BranchType,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListBranchesOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBranchesForProject(
          projectID,
          name,
          branchType,
          pageSize,
          pageToken,
          orderBy,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the list of projects.
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listProjects(
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListProjectsOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(
        pageSize,
        pageToken,
        orderBy,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Updates the project.
     * @param {string} projectID
     * @param {UpdateProjectInput} [updateProjectInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProject(
      projectID: string,
      updateProjectInput?: UpdateProjectInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(
        projectID,
        updateProjectInput,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ProjectsApiFp(configuration)
  return {
    /**
     * Archived a project.
     * @param {string} projectID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archiveProject(projectID: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .archiveProject(projectID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Adds a branch for a project.
     * @param {string} projectID
     * @param {CreateBranchInput} [createBranchInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBranchForProject(
      projectID: string,
      createBranchInput?: CreateBranchInput,
      options?: any
    ): AxiosPromise<Branch> {
      return localVarFp
        .createBranchForProject(projectID, createBranchInput, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Adds a project.
     * @param {CreateProjectInput} [createProjectInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProject(
      createProjectInput?: CreateProjectInput,
      options?: any
    ): AxiosPromise<Project> {
      return localVarFp
        .createProject(createProjectInput, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Deletes a branch for a project.
     * @param {string} projectID
     * @param {string} branchID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBranchForProject(
      projectID: string,
      branchID: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteBranchForProject(projectID, branchID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a specific branch for a project.
     * @param {string} projectID
     * @param {string} branchID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBranchForProject(
      projectID: string,
      branchID: string,
      options?: any
    ): AxiosPromise<Branch> {
      return localVarFp
        .getBranchForProject(projectID, branchID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a specific project.
     * @param {string} projectID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProject(projectID: string, options?: any): AxiosPromise<Project> {
      return localVarFp
        .getProject(projectID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the list of branches for a project.
     * @param {string} projectID
     * @param {string} [name] Filter branches by name
     * @param {BranchType} [branchType] Filter branches by branchType
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBranchesForProject(
      projectID: string,
      name?: string,
      branchType?: BranchType,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListBranchesOutput> {
      return localVarFp
        .listBranchesForProject(
          projectID,
          name,
          branchType,
          pageSize,
          pageToken,
          orderBy,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the list of projects.
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProjects(
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListProjectsOutput> {
      return localVarFp
        .listProjects(pageSize, pageToken, orderBy, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Updates the project.
     * @param {string} projectID
     * @param {UpdateProjectInput} [updateProjectInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProject(
      projectID: string,
      updateProjectInput?: UpdateProjectInput,
      options?: any
    ): AxiosPromise<Project> {
      return localVarFp
        .updateProject(projectID, updateProjectInput, options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
  /**
   * Archived a project.
   * @param {string} projectID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public archiveProject(projectID: string, options?: AxiosRequestConfig) {
    return ProjectsApiFp(this.configuration)
      .archiveProject(projectID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Adds a branch for a project.
   * @param {string} projectID
   * @param {CreateBranchInput} [createBranchInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public createBranchForProject(
    projectID: string,
    createBranchInput?: CreateBranchInput,
    options?: AxiosRequestConfig
  ) {
    return ProjectsApiFp(this.configuration)
      .createBranchForProject(projectID, createBranchInput, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Adds a project.
   * @param {CreateProjectInput} [createProjectInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public createProject(
    createProjectInput?: CreateProjectInput,
    options?: AxiosRequestConfig
  ) {
    return ProjectsApiFp(this.configuration)
      .createProject(createProjectInput, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Deletes a branch for a project.
   * @param {string} projectID
   * @param {string} branchID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public deleteBranchForProject(
    projectID: string,
    branchID: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsApiFp(this.configuration)
      .deleteBranchForProject(projectID, branchID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a specific branch for a project.
   * @param {string} projectID
   * @param {string} branchID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public getBranchForProject(
    projectID: string,
    branchID: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsApiFp(this.configuration)
      .getBranchForProject(projectID, branchID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a specific project.
   * @param {string} projectID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public getProject(projectID: string, options?: AxiosRequestConfig) {
    return ProjectsApiFp(this.configuration)
      .getProject(projectID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the list of branches for a project.
   * @param {string} projectID
   * @param {string} [name] Filter branches by name
   * @param {BranchType} [branchType] Filter branches by branchType
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public listBranchesForProject(
    projectID: string,
    name?: string,
    branchType?: BranchType,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsApiFp(this.configuration)
      .listBranchesForProject(
        projectID,
        name,
        branchType,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the list of projects.
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public listProjects(
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsApiFp(this.configuration)
      .listProjects(pageSize, pageToken, orderBy, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Updates the project.
   * @param {string} projectID
   * @param {UpdateProjectInput} [updateProjectInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public updateProject(
    projectID: string,
    updateProjectInput?: UpdateProjectInput,
    options?: AxiosRequestConfig
  ) {
    return ProjectsApiFp(this.configuration)
      .updateProject(projectID, updateProjectInput, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Adds a report. If the user supplies a name parameter, that name will be used, otherwise a name will be generated. The end timestamp is optional and will default to now(). The respectRevisionBoundary field enables strict report generation from only the defined testSuiteRevision.
     * @param {string} projectID
     * @param {ReportInput} [reportInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createReport: async (
      projectID: string,
      reportInput?: ReportInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('createReport', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/reports`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        reportInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a report.
     * @param {string} projectID
     * @param {string} reportID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReport: async (
      projectID: string,
      reportID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getReport', 'projectID', projectID)
      // verify required parameter 'reportID' is not null or undefined
      assertParamExists('getReport', 'reportID', reportID)
      const localVarPath = `/projects/{projectID}/reports/{reportID}`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'reportID'}}`, encodeURIComponent(String(reportID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Get an individual log file
     * @param {string} projectID
     * @param {string} reportID
     * @param {string} logID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportLog: async (
      projectID: string,
      reportID: string,
      logID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getReportLog', 'projectID', projectID)
      // verify required parameter 'reportID' is not null or undefined
      assertParamExists('getReportLog', 'reportID', reportID)
      // verify required parameter 'logID' is not null or undefined
      assertParamExists('getReportLog', 'logID', logID)
      const localVarPath =
        `/projects/{projectID}/reports/{reportID}/logs/{logID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'reportID'}}`, encodeURIComponent(String(reportID)))
          .replace(`{${'logID'}}`, encodeURIComponent(String(logID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * List the logs associated with a given report
     * @param {string} projectID
     * @param {string} reportID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLogsForReport: async (
      projectID: string,
      reportID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listLogsForReport', 'projectID', projectID)
      // verify required parameter 'reportID' is not null or undefined
      assertParamExists('listLogsForReport', 'reportID', reportID)
      const localVarPath = `/projects/{projectID}/reports/{reportID}/logs`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'reportID'}}`, encodeURIComponent(String(reportID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Get all the account names that have triggered reports in the given project. These usernames are collected automatically from CI systems.
     * @param {string} projectID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportAccounts: async (
      projectID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listReportAccounts', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/reports/accounts`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the metrics for a given report. Does not return associated data.
     * @param {string} projectID
     * @param {string} reportID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetrics: async (
      projectID: string,
      reportID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listReportMetrics', 'projectID', projectID)
      // verify required parameter 'reportID' is not null or undefined
      assertParamExists('listReportMetrics', 'reportID', reportID)
      const localVarPath = `/projects/{projectID}/reports/{reportID}/metrics`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'reportID'}}`, encodeURIComponent(String(reportID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the metrics data associated with a given report ID
     * @param {string} projectID
     * @param {string} reportID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetricsData: async (
      projectID: string,
      reportID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listReportMetricsData', 'projectID', projectID)
      // verify required parameter 'reportID' is not null or undefined
      assertParamExists('listReportMetricsData', 'reportID', reportID)
      const localVarPath =
        `/projects/{projectID}/reports/{reportID}/metricsData`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'reportID'}}`, encodeURIComponent(String(reportID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the report metrics data associated with given report metric ID(s)
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetricsDataForReportMetricIDs: async (
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'listReportMetricsDataForReportMetricIDs',
        'projectID',
        projectID
      )
      // verify required parameter 'reportID' is not null or undefined
      assertParamExists(
        'listReportMetricsDataForReportMetricIDs',
        'reportID',
        reportID
      )
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists(
        'listReportMetricsDataForReportMetricIDs',
        'metricID',
        metricID
      )
      const localVarPath =
        `/projects/{projectID}/reports/{reportID}/metrics/{metricID}/metricsData`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'reportID'}}`, encodeURIComponent(String(reportID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the report metrics data associated with given report metrics data IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetricsDataForReportMetricsDataIDs: async (
      projectID: string,
      reportID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'listReportMetricsDataForReportMetricsDataIDs',
        'projectID',
        projectID
      )
      // verify required parameter 'reportID' is not null or undefined
      assertParamExists(
        'listReportMetricsDataForReportMetricsDataIDs',
        'reportID',
        reportID
      )
      // verify required parameter 'metricsDataID' is not null or undefined
      assertParamExists(
        'listReportMetricsDataForReportMetricsDataIDs',
        'metricsDataID',
        metricsDataID
      )
      const localVarPath =
        `/projects/{projectID}/reports/{reportID}/metricsData/{metricsDataID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'reportID'}}`, encodeURIComponent(String(reportID)))
          .replace(
            `{${'metricsDataID'}}`,
            encodeURIComponent(String(metricsDataID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the report metrics associated with given report metric IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetricsForReportMetricIDs: async (
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'listReportMetricsForReportMetricIDs',
        'projectID',
        projectID
      )
      // verify required parameter 'reportID' is not null or undefined
      assertParamExists(
        'listReportMetricsForReportMetricIDs',
        'reportID',
        reportID
      )
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists(
        'listReportMetricsForReportMetricIDs',
        'metricID',
        metricID
      )
      const localVarPath =
        `/projects/{projectID}/reports/{reportID}/metrics/{metricID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'reportID'}}`, encodeURIComponent(String(reportID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * List the reports.
     * @param {string} projectID
     * @param {string} [search] Filter based on branch_id, test_suite_id, created_at, status, associated_account
     * @param {string} [text] Filter reports by a text string (only supports batch id as of 3/21/2025)
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReports: async (
      projectID: string,
      search?: string,
      text?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listReports', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/reports`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      if (text !== undefined) {
        localVarQueryParameter['text'] = text
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the tags associated with given report metric IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTagsForReportMetrics: async (
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listTagsForReportMetrics', 'projectID', projectID)
      // verify required parameter 'reportID' is not null or undefined
      assertParamExists('listTagsForReportMetrics', 'reportID', reportID)
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists('listTagsForReportMetrics', 'metricID', metricID)
      const localVarPath =
        `/projects/{projectID}/reports/{reportID}/metrics/{metricID}/tags`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'reportID'}}`, encodeURIComponent(String(reportID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['reports:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
  return {
    /**
     * Adds a report. If the user supplies a name parameter, that name will be used, otherwise a name will be generated. The end timestamp is optional and will default to now(). The respectRevisionBoundary field enables strict report generation from only the defined testSuiteRevision.
     * @param {string} projectID
     * @param {ReportInput} [reportInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createReport(
      projectID: string,
      reportInput?: ReportInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createReport(
        projectID,
        reportInput,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a report.
     * @param {string} projectID
     * @param {string} reportID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReport(
      projectID: string,
      reportID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getReport(
        projectID,
        reportID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Get an individual log file
     * @param {string} projectID
     * @param {string} reportID
     * @param {string} logID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReportLog(
      projectID: string,
      reportID: string,
      logID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportLog>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getReportLog(
        projectID,
        reportID,
        logID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the logs associated with a given report
     * @param {string} projectID
     * @param {string} reportID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listLogsForReport(
      projectID: string,
      reportID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListReportLogsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listLogsForReport(
          projectID,
          reportID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Get all the account names that have triggered reports in the given project. These usernames are collected automatically from CI systems.
     * @param {string} projectID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listReportAccounts(
      projectID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listReportAccounts(projectID, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the metrics for a given report. Does not return associated data.
     * @param {string} projectID
     * @param {string} reportID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listReportMetrics(
      projectID: string,
      reportID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListReportMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listReportMetrics(
          projectID,
          reportID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the metrics data associated with a given report ID
     * @param {string} projectID
     * @param {string} reportID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listReportMetricsData(
      projectID: string,
      reportID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListReportMetricsDataOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listReportMetricsData(
          projectID,
          reportID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the report metrics data associated with given report metric ID(s)
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listReportMetricsDataForReportMetricIDs(
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListReportMetricsDataForReportMetricIDsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listReportMetricsDataForReportMetricIDs(
          projectID,
          reportID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the report metrics data associated with given report metrics data IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listReportMetricsDataForReportMetricsDataIDs(
      projectID: string,
      reportID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListReportMetricsDataOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listReportMetricsDataForReportMetricsDataIDs(
          projectID,
          reportID,
          metricsDataID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the report metrics associated with given report metric IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listReportMetricsForReportMetricIDs(
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListReportMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listReportMetricsForReportMetricIDs(
          projectID,
          reportID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the reports.
     * @param {string} projectID
     * @param {string} [search] Filter based on branch_id, test_suite_id, created_at, status, associated_account
     * @param {string} [text] Filter reports by a text string (only supports batch id as of 3/21/2025)
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listReports(
      projectID: string,
      search?: string,
      text?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListReportsOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listReports(
        projectID,
        search,
        text,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the tags associated with given report metric IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTagsForReportMetrics(
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListTagsForReportMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listTagsForReportMetrics(
          projectID,
          reportID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ReportsApiFp(configuration)
  return {
    /**
     * Adds a report. If the user supplies a name parameter, that name will be used, otherwise a name will be generated. The end timestamp is optional and will default to now(). The respectRevisionBoundary field enables strict report generation from only the defined testSuiteRevision.
     * @param {string} projectID
     * @param {ReportInput} [reportInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createReport(
      projectID: string,
      reportInput?: ReportInput,
      options?: any
    ): AxiosPromise<Report> {
      return localVarFp
        .createReport(projectID, reportInput, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a report.
     * @param {string} projectID
     * @param {string} reportID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReport(
      projectID: string,
      reportID: string,
      options?: any
    ): AxiosPromise<Report> {
      return localVarFp
        .getReport(projectID, reportID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Get an individual log file
     * @param {string} projectID
     * @param {string} reportID
     * @param {string} logID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportLog(
      projectID: string,
      reportID: string,
      logID: string,
      options?: any
    ): AxiosPromise<ReportLog> {
      return localVarFp
        .getReportLog(projectID, reportID, logID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * List the logs associated with a given report
     * @param {string} projectID
     * @param {string} reportID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLogsForReport(
      projectID: string,
      reportID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListReportLogsOutput> {
      return localVarFp
        .listLogsForReport(projectID, reportID, pageSize, pageToken, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Get all the account names that have triggered reports in the given project. These usernames are collected automatically from CI systems.
     * @param {string} projectID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportAccounts(
      projectID: string,
      options?: any
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .listReportAccounts(projectID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the metrics for a given report. Does not return associated data.
     * @param {string} projectID
     * @param {string} reportID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetrics(
      projectID: string,
      reportID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListReportMetricsOutput> {
      return localVarFp
        .listReportMetrics(projectID, reportID, pageSize, pageToken, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the metrics data associated with a given report ID
     * @param {string} projectID
     * @param {string} reportID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetricsData(
      projectID: string,
      reportID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListReportMetricsDataOutput> {
      return localVarFp
        .listReportMetricsData(
          projectID,
          reportID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the report metrics data associated with given report metric ID(s)
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetricsDataForReportMetricIDs(
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListReportMetricsDataForReportMetricIDsOutput> {
      return localVarFp
        .listReportMetricsDataForReportMetricIDs(
          projectID,
          reportID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the report metrics data associated with given report metrics data IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricsDataID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetricsDataForReportMetricsDataIDs(
      projectID: string,
      reportID: string,
      metricsDataID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListReportMetricsDataOutput> {
      return localVarFp
        .listReportMetricsDataForReportMetricsDataIDs(
          projectID,
          reportID,
          metricsDataID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the report metrics associated with given report metric IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReportMetricsForReportMetricIDs(
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListReportMetricsOutput> {
      return localVarFp
        .listReportMetricsForReportMetricIDs(
          projectID,
          reportID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * List the reports.
     * @param {string} projectID
     * @param {string} [search] Filter based on branch_id, test_suite_id, created_at, status, associated_account
     * @param {string} [text] Filter reports by a text string (only supports batch id as of 3/21/2025)
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReports(
      projectID: string,
      search?: string,
      text?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListReportsOutput> {
      return localVarFp
        .listReports(
          projectID,
          search,
          text,
          pageSize,
          pageToken,
          orderBy,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the tags associated with given report metric IDs
     * @param {string} projectID
     * @param {string} reportID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTagsForReportMetrics(
      projectID: string,
      reportID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListTagsForReportMetricsOutput> {
      return localVarFp
        .listTagsForReportMetrics(
          projectID,
          reportID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
  /**
   * Adds a report. If the user supplies a name parameter, that name will be used, otherwise a name will be generated. The end timestamp is optional and will default to now(). The respectRevisionBoundary field enables strict report generation from only the defined testSuiteRevision.
   * @param {string} projectID
   * @param {ReportInput} [reportInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public createReport(
    projectID: string,
    reportInput?: ReportInput,
    options?: AxiosRequestConfig
  ) {
    return ReportsApiFp(this.configuration)
      .createReport(projectID, reportInput, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a report.
   * @param {string} projectID
   * @param {string} reportID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public getReport(
    projectID: string,
    reportID: string,
    options?: AxiosRequestConfig
  ) {
    return ReportsApiFp(this.configuration)
      .getReport(projectID, reportID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Get an individual log file
   * @param {string} projectID
   * @param {string} reportID
   * @param {string} logID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public getReportLog(
    projectID: string,
    reportID: string,
    logID: string,
    options?: AxiosRequestConfig
  ) {
    return ReportsApiFp(this.configuration)
      .getReportLog(projectID, reportID, logID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * List the logs associated with a given report
   * @param {string} projectID
   * @param {string} reportID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public listLogsForReport(
    projectID: string,
    reportID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return ReportsApiFp(this.configuration)
      .listLogsForReport(projectID, reportID, pageSize, pageToken, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Get all the account names that have triggered reports in the given project. These usernames are collected automatically from CI systems.
   * @param {string} projectID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public listReportAccounts(projectID: string, options?: AxiosRequestConfig) {
    return ReportsApiFp(this.configuration)
      .listReportAccounts(projectID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the metrics for a given report. Does not return associated data.
   * @param {string} projectID
   * @param {string} reportID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public listReportMetrics(
    projectID: string,
    reportID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return ReportsApiFp(this.configuration)
      .listReportMetrics(projectID, reportID, pageSize, pageToken, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the metrics data associated with a given report ID
   * @param {string} projectID
   * @param {string} reportID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public listReportMetricsData(
    projectID: string,
    reportID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return ReportsApiFp(this.configuration)
      .listReportMetricsData(projectID, reportID, pageSize, pageToken, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the report metrics data associated with given report metric ID(s)
   * @param {string} projectID
   * @param {string} reportID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public listReportMetricsDataForReportMetricIDs(
    projectID: string,
    reportID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return ReportsApiFp(this.configuration)
      .listReportMetricsDataForReportMetricIDs(
        projectID,
        reportID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the report metrics data associated with given report metrics data IDs
   * @param {string} projectID
   * @param {string} reportID
   * @param {Array<string>} metricsDataID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public listReportMetricsDataForReportMetricsDataIDs(
    projectID: string,
    reportID: string,
    metricsDataID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return ReportsApiFp(this.configuration)
      .listReportMetricsDataForReportMetricsDataIDs(
        projectID,
        reportID,
        metricsDataID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the report metrics associated with given report metric IDs
   * @param {string} projectID
   * @param {string} reportID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public listReportMetricsForReportMetricIDs(
    projectID: string,
    reportID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return ReportsApiFp(this.configuration)
      .listReportMetricsForReportMetricIDs(
        projectID,
        reportID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * List the reports.
   * @param {string} projectID
   * @param {string} [search] Filter based on branch_id, test_suite_id, created_at, status, associated_account
   * @param {string} [text] Filter reports by a text string (only supports batch id as of 3/21/2025)
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public listReports(
    projectID: string,
    search?: string,
    text?: string,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return ReportsApiFp(this.configuration)
      .listReports(
        projectID,
        search,
        text,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the tags associated with given report metric IDs
   * @param {string} projectID
   * @param {string} reportID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public listTagsForReportMetrics(
    projectID: string,
    reportID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return ReportsApiFp(this.configuration)
      .listTagsForReportMetrics(
        projectID,
        reportID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * SystemsApi - axios parameter creator
 * @export
 */
export const SystemsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Registers the given experience as applicable for the system
     * @param {string} projectID
     * @param {string} systemID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSystemToExperience: async (
      projectID: string,
      systemID: string,
      experienceID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('addSystemToExperience', 'projectID', projectID)
      // verify required parameter 'systemID' is not null or undefined
      assertParamExists('addSystemToExperience', 'systemID', systemID)
      // verify required parameter 'experienceID' is not null or undefined
      assertParamExists('addSystemToExperience', 'experienceID', experienceID)
      const localVarPath =
        `/projects/{projectID}/systems/{systemID}/experiences/{experienceID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'systemID'}}`, encodeURIComponent(String(systemID)))
          .replace(
            `{${'experienceID'}}`,
            encodeURIComponent(String(experienceID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Registers the given metrics build as applicable for the system
     * @param {string} projectID
     * @param {string} systemID
     * @param {string} metricsBuildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSystemToMetricsBuild: async (
      projectID: string,
      systemID: string,
      metricsBuildID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('addSystemToMetricsBuild', 'projectID', projectID)
      // verify required parameter 'systemID' is not null or undefined
      assertParamExists('addSystemToMetricsBuild', 'systemID', systemID)
      // verify required parameter 'metricsBuildID' is not null or undefined
      assertParamExists(
        'addSystemToMetricsBuild',
        'metricsBuildID',
        metricsBuildID
      )
      const localVarPath =
        `/projects/{projectID}/systems/{systemID}/metricsBuilds/{metricsBuildID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'systemID'}}`, encodeURIComponent(String(systemID)))
          .replace(
            `{${'metricsBuildID'}}`,
            encodeURIComponent(String(metricsBuildID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Registers the given experiences as applicable for the systems
     * @param {string} projectID
     * @param {MutateSystemsToExperienceInput} [mutateSystemsToExperienceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSystemsToExperiences: async (
      projectID: string,
      mutateSystemsToExperienceInput?: MutateSystemsToExperienceInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('addSystemsToExperiences', 'projectID', projectID)
      const localVarPath =
        `/projects/{projectID}/systems/addExperiences`.replace(
          `{${'projectID'}}`,
          encodeURIComponent(String(projectID))
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutateSystemsToExperienceInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Archives a system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archiveSystem: async (
      projectID: string,
      systemID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('archiveSystem', 'projectID', projectID)
      // verify required parameter 'systemID' is not null or undefined
      assertParamExists('archiveSystem', 'systemID', systemID)
      const localVarPath = `/projects/{projectID}/systems/{systemID}`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'systemID'}}`, encodeURIComponent(String(systemID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Adds a system.
     * @param {string} projectID
     * @param {CreateSystemInput} [createSystemInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSystem: async (
      projectID: string,
      createSystemInput?: CreateSystemInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('createSystem', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/systems`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createSystemInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a specific system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystem: async (
      projectID: string,
      systemID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getSystem', 'projectID', projectID)
      // verify required parameter 'systemID' is not null or undefined
      assertParamExists('getSystem', 'systemID', systemID)
      const localVarPath = `/projects/{projectID}/systems/{systemID}`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'systemID'}}`, encodeURIComponent(String(systemID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a list of all experiences applicable to the system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listExperiencesForSystem: async (
      projectID: string,
      systemID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listExperiencesForSystem', 'projectID', projectID)
      // verify required parameter 'systemID' is not null or undefined
      assertParamExists('listExperiencesForSystem', 'systemID', systemID)
      const localVarPath =
        `/projects/{projectID}/systems/{systemID}/experiences`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'systemID'}}`, encodeURIComponent(String(systemID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the list of systems.
     * @param {string} projectID
     * @param {string} [name] Filter systems by name
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSystems: async (
      projectID: string,
      name?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listSystems', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/systems`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:read'],
        configuration
      )

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Deregisters the given experience as applicable for the system
     * @param {string} projectID
     * @param {string} systemID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeSystemFromExperience: async (
      projectID: string,
      systemID: string,
      experienceID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('removeSystemFromExperience', 'projectID', projectID)
      // verify required parameter 'systemID' is not null or undefined
      assertParamExists('removeSystemFromExperience', 'systemID', systemID)
      // verify required parameter 'experienceID' is not null or undefined
      assertParamExists(
        'removeSystemFromExperience',
        'experienceID',
        experienceID
      )
      const localVarPath =
        `/projects/{projectID}/systems/{systemID}/experiences/{experienceID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'systemID'}}`, encodeURIComponent(String(systemID)))
          .replace(
            `{${'experienceID'}}`,
            encodeURIComponent(String(experienceID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Deregisters the given metrics build as applicable for the system
     * @param {string} projectID
     * @param {string} systemID
     * @param {string} metricsBuildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeSystemFromMetricsBuild: async (
      projectID: string,
      systemID: string,
      metricsBuildID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('removeSystemFromMetricsBuild', 'projectID', projectID)
      // verify required parameter 'systemID' is not null or undefined
      assertParamExists('removeSystemFromMetricsBuild', 'systemID', systemID)
      // verify required parameter 'metricsBuildID' is not null or undefined
      assertParamExists(
        'removeSystemFromMetricsBuild',
        'metricsBuildID',
        metricsBuildID
      )
      const localVarPath =
        `/projects/{projectID}/systems/{systemID}/metricsBuilds/{metricsBuildID}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'systemID'}}`, encodeURIComponent(String(systemID)))
          .replace(
            `{${'metricsBuildID'}}`,
            encodeURIComponent(String(metricsBuildID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Removes the given experiences from association with the systems
     * @param {string} projectID
     * @param {MutateSystemsToExperienceInput} [mutateSystemsToExperienceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeSystemsFromExperiences: async (
      projectID: string,
      mutateSystemsToExperienceInput?: MutateSystemsToExperienceInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('removeSystemsFromExperiences', 'projectID', projectID)
      const localVarPath =
        `/projects/{projectID}/systems/removeExperiences`.replace(
          `{${'projectID'}}`,
          encodeURIComponent(String(projectID))
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutateSystemsToExperienceInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Updates the system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {UpdateSystemInput} [updateSystemInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSystem: async (
      projectID: string,
      systemID: string,
      updateSystemInput?: UpdateSystemInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('updateSystem', 'projectID', projectID)
      // verify required parameter 'systemID' is not null or undefined
      assertParamExists('updateSystem', 'systemID', systemID)
      const localVarPath = `/projects/{projectID}/systems/{systemID}`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'systemID'}}`, encodeURIComponent(String(systemID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['systems:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateSystemInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * SystemsApi - functional programming interface
 * @export
 */
export const SystemsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SystemsApiAxiosParamCreator(configuration)
  return {
    /**
     * Registers the given experience as applicable for the system
     * @param {string} projectID
     * @param {string} systemID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addSystemToExperience(
      projectID: string,
      systemID: string,
      experienceID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addSystemToExperience(
          projectID,
          systemID,
          experienceID,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Registers the given metrics build as applicable for the system
     * @param {string} projectID
     * @param {string} systemID
     * @param {string} metricsBuildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addSystemToMetricsBuild(
      projectID: string,
      systemID: string,
      metricsBuildID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addSystemToMetricsBuild(
          projectID,
          systemID,
          metricsBuildID,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Registers the given experiences as applicable for the systems
     * @param {string} projectID
     * @param {MutateSystemsToExperienceInput} [mutateSystemsToExperienceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addSystemsToExperiences(
      projectID: string,
      mutateSystemsToExperienceInput?: MutateSystemsToExperienceInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addSystemsToExperiences(
          projectID,
          mutateSystemsToExperienceInput,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Archives a system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async archiveSystem(
      projectID: string,
      systemID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.archiveSystem(
        projectID,
        systemID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Adds a system.
     * @param {string} projectID
     * @param {CreateSystemInput} [createSystemInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSystem(
      projectID: string,
      createSystemInput?: CreateSystemInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<System>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createSystem(
        projectID,
        createSystemInput,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a specific system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSystem(
      projectID: string,
      systemID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<System>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSystem(
        projectID,
        systemID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a list of all experiences applicable to the system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listExperiencesForSystem(
      projectID: string,
      systemID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListExperiencesOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listExperiencesForSystem(
          projectID,
          systemID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the list of systems.
     * @param {string} projectID
     * @param {string} [name] Filter systems by name
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listSystems(
      projectID: string,
      name?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListSystemsOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listSystems(
        projectID,
        name,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Deregisters the given experience as applicable for the system
     * @param {string} projectID
     * @param {string} systemID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeSystemFromExperience(
      projectID: string,
      systemID: string,
      experienceID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removeSystemFromExperience(
          projectID,
          systemID,
          experienceID,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Deregisters the given metrics build as applicable for the system
     * @param {string} projectID
     * @param {string} systemID
     * @param {string} metricsBuildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeSystemFromMetricsBuild(
      projectID: string,
      systemID: string,
      metricsBuildID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removeSystemFromMetricsBuild(
          projectID,
          systemID,
          metricsBuildID,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Removes the given experiences from association with the systems
     * @param {string} projectID
     * @param {MutateSystemsToExperienceInput} [mutateSystemsToExperienceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeSystemsFromExperiences(
      projectID: string,
      mutateSystemsToExperienceInput?: MutateSystemsToExperienceInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removeSystemsFromExperiences(
          projectID,
          mutateSystemsToExperienceInput,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Updates the system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {UpdateSystemInput} [updateSystemInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSystem(
      projectID: string,
      systemID: string,
      updateSystemInput?: UpdateSystemInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<System>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateSystem(
        projectID,
        systemID,
        updateSystemInput,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * SystemsApi - factory interface
 * @export
 */
export const SystemsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SystemsApiFp(configuration)
  return {
    /**
     * Registers the given experience as applicable for the system
     * @param {string} projectID
     * @param {string} systemID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSystemToExperience(
      projectID: string,
      systemID: string,
      experienceID: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .addSystemToExperience(projectID, systemID, experienceID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Registers the given metrics build as applicable for the system
     * @param {string} projectID
     * @param {string} systemID
     * @param {string} metricsBuildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSystemToMetricsBuild(
      projectID: string,
      systemID: string,
      metricsBuildID: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .addSystemToMetricsBuild(projectID, systemID, metricsBuildID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Registers the given experiences as applicable for the systems
     * @param {string} projectID
     * @param {MutateSystemsToExperienceInput} [mutateSystemsToExperienceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSystemsToExperiences(
      projectID: string,
      mutateSystemsToExperienceInput?: MutateSystemsToExperienceInput,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .addSystemsToExperiences(
          projectID,
          mutateSystemsToExperienceInput,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Archives a system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archiveSystem(
      projectID: string,
      systemID: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .archiveSystem(projectID, systemID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Adds a system.
     * @param {string} projectID
     * @param {CreateSystemInput} [createSystemInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSystem(
      projectID: string,
      createSystemInput?: CreateSystemInput,
      options?: any
    ): AxiosPromise<System> {
      return localVarFp
        .createSystem(projectID, createSystemInput, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a specific system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystem(
      projectID: string,
      systemID: string,
      options?: any
    ): AxiosPromise<System> {
      return localVarFp
        .getSystem(projectID, systemID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a list of all experiences applicable to the system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listExperiencesForSystem(
      projectID: string,
      systemID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListExperiencesOutput> {
      return localVarFp
        .listExperiencesForSystem(
          projectID,
          systemID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the list of systems.
     * @param {string} projectID
     * @param {string} [name] Filter systems by name
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSystems(
      projectID: string,
      name?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListSystemsOutput> {
      return localVarFp
        .listSystems(projectID, name, pageSize, pageToken, orderBy, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Deregisters the given experience as applicable for the system
     * @param {string} projectID
     * @param {string} systemID
     * @param {string} experienceID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeSystemFromExperience(
      projectID: string,
      systemID: string,
      experienceID: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .removeSystemFromExperience(projectID, systemID, experienceID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Deregisters the given metrics build as applicable for the system
     * @param {string} projectID
     * @param {string} systemID
     * @param {string} metricsBuildID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeSystemFromMetricsBuild(
      projectID: string,
      systemID: string,
      metricsBuildID: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .removeSystemFromMetricsBuild(
          projectID,
          systemID,
          metricsBuildID,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Removes the given experiences from association with the systems
     * @param {string} projectID
     * @param {MutateSystemsToExperienceInput} [mutateSystemsToExperienceInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeSystemsFromExperiences(
      projectID: string,
      mutateSystemsToExperienceInput?: MutateSystemsToExperienceInput,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .removeSystemsFromExperiences(
          projectID,
          mutateSystemsToExperienceInput,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Updates the system.
     * @param {string} projectID
     * @param {string} systemID
     * @param {UpdateSystemInput} [updateSystemInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSystem(
      projectID: string,
      systemID: string,
      updateSystemInput?: UpdateSystemInput,
      options?: any
    ): AxiosPromise<System> {
      return localVarFp
        .updateSystem(projectID, systemID, updateSystemInput, options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * SystemsApi - object-oriented interface
 * @export
 * @class SystemsApi
 * @extends {BaseAPI}
 */
export class SystemsApi extends BaseAPI {
  /**
   * Registers the given experience as applicable for the system
   * @param {string} projectID
   * @param {string} systemID
   * @param {string} experienceID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public addSystemToExperience(
    projectID: string,
    systemID: string,
    experienceID: string,
    options?: AxiosRequestConfig
  ) {
    return SystemsApiFp(this.configuration)
      .addSystemToExperience(projectID, systemID, experienceID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Registers the given metrics build as applicable for the system
   * @param {string} projectID
   * @param {string} systemID
   * @param {string} metricsBuildID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public addSystemToMetricsBuild(
    projectID: string,
    systemID: string,
    metricsBuildID: string,
    options?: AxiosRequestConfig
  ) {
    return SystemsApiFp(this.configuration)
      .addSystemToMetricsBuild(projectID, systemID, metricsBuildID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Registers the given experiences as applicable for the systems
   * @param {string} projectID
   * @param {MutateSystemsToExperienceInput} [mutateSystemsToExperienceInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public addSystemsToExperiences(
    projectID: string,
    mutateSystemsToExperienceInput?: MutateSystemsToExperienceInput,
    options?: AxiosRequestConfig
  ) {
    return SystemsApiFp(this.configuration)
      .addSystemsToExperiences(
        projectID,
        mutateSystemsToExperienceInput,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Archives a system.
   * @param {string} projectID
   * @param {string} systemID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public archiveSystem(
    projectID: string,
    systemID: string,
    options?: AxiosRequestConfig
  ) {
    return SystemsApiFp(this.configuration)
      .archiveSystem(projectID, systemID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Adds a system.
   * @param {string} projectID
   * @param {CreateSystemInput} [createSystemInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public createSystem(
    projectID: string,
    createSystemInput?: CreateSystemInput,
    options?: AxiosRequestConfig
  ) {
    return SystemsApiFp(this.configuration)
      .createSystem(projectID, createSystemInput, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a specific system.
   * @param {string} projectID
   * @param {string} systemID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public getSystem(
    projectID: string,
    systemID: string,
    options?: AxiosRequestConfig
  ) {
    return SystemsApiFp(this.configuration)
      .getSystem(projectID, systemID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of all experiences applicable to the system.
   * @param {string} projectID
   * @param {string} systemID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public listExperiencesForSystem(
    projectID: string,
    systemID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return SystemsApiFp(this.configuration)
      .listExperiencesForSystem(
        projectID,
        systemID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the list of systems.
   * @param {string} projectID
   * @param {string} [name] Filter systems by name
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public listSystems(
    projectID: string,
    name?: string,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return SystemsApiFp(this.configuration)
      .listSystems(projectID, name, pageSize, pageToken, orderBy, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Deregisters the given experience as applicable for the system
   * @param {string} projectID
   * @param {string} systemID
   * @param {string} experienceID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public removeSystemFromExperience(
    projectID: string,
    systemID: string,
    experienceID: string,
    options?: AxiosRequestConfig
  ) {
    return SystemsApiFp(this.configuration)
      .removeSystemFromExperience(projectID, systemID, experienceID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Deregisters the given metrics build as applicable for the system
   * @param {string} projectID
   * @param {string} systemID
   * @param {string} metricsBuildID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public removeSystemFromMetricsBuild(
    projectID: string,
    systemID: string,
    metricsBuildID: string,
    options?: AxiosRequestConfig
  ) {
    return SystemsApiFp(this.configuration)
      .removeSystemFromMetricsBuild(
        projectID,
        systemID,
        metricsBuildID,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Removes the given experiences from association with the systems
   * @param {string} projectID
   * @param {MutateSystemsToExperienceInput} [mutateSystemsToExperienceInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public removeSystemsFromExperiences(
    projectID: string,
    mutateSystemsToExperienceInput?: MutateSystemsToExperienceInput,
    options?: AxiosRequestConfig
  ) {
    return SystemsApiFp(this.configuration)
      .removeSystemsFromExperiences(
        projectID,
        mutateSystemsToExperienceInput,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Updates the system.
   * @param {string} projectID
   * @param {string} systemID
   * @param {UpdateSystemInput} [updateSystemInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public updateSystem(
    projectID: string,
    systemID: string,
    updateSystemInput?: UpdateSystemInput,
    options?: AxiosRequestConfig
  ) {
    return SystemsApiFp(this.configuration)
      .updateSystem(projectID, systemID, updateSystemInput, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * List the tags associated to the given metric id(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTagsForBatchMetrics: async (
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listTagsForBatchMetrics', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listTagsForBatchMetrics', 'batchID', batchID)
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists('listTagsForBatchMetrics', 'metricID', metricID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/metrics/{metricID}/tags`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * List the tags associated to the given job metric id(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTagsForJobMetrics: async (
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listTagsForJobMetrics', 'projectID', projectID)
      // verify required parameter 'batchID' is not null or undefined
      assertParamExists('listTagsForJobMetrics', 'batchID', batchID)
      // verify required parameter 'jobID' is not null or undefined
      assertParamExists('listTagsForJobMetrics', 'jobID', jobID)
      // verify required parameter 'metricID' is not null or undefined
      assertParamExists('listTagsForJobMetrics', 'metricID', metricID)
      const localVarPath =
        `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics/{metricID}/tags`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(`{${'batchID'}}`, encodeURIComponent(String(batchID)))
          .replace(`{${'jobID'}}`, encodeURIComponent(String(jobID)))
          .replace(`{${'metricID'}}`, encodeURIComponent(String(metricID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
  return {
    /**
     * List the tags associated to the given metric id(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTagsForBatchMetrics(
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListTagsForBatchMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listTagsForBatchMetrics(
          projectID,
          batchID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the tags associated to the given job metric id(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTagsForJobMetrics(
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListTagsForJobMetricsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listTagsForJobMetrics(
          projectID,
          batchID,
          jobID,
          metricID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TagsApiFp(configuration)
  return {
    /**
     * List the tags associated to the given metric id(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTagsForBatchMetrics(
      projectID: string,
      batchID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListTagsForBatchMetricsOutput> {
      return localVarFp
        .listTagsForBatchMetrics(
          projectID,
          batchID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * List the tags associated to the given job metric id(s)
     * @param {string} projectID
     * @param {string} batchID
     * @param {string} jobID
     * @param {Array<string>} metricID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTagsForJobMetrics(
      projectID: string,
      batchID: string,
      jobID: string,
      metricID: Array<string>,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListTagsForJobMetricsOutput> {
      return localVarFp
        .listTagsForJobMetrics(
          projectID,
          batchID,
          jobID,
          metricID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
  /**
   * List the tags associated to the given metric id(s)
   * @param {string} projectID
   * @param {string} batchID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagsApi
   */
  public listTagsForBatchMetrics(
    projectID: string,
    batchID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return TagsApiFp(this.configuration)
      .listTagsForBatchMetrics(
        projectID,
        batchID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * List the tags associated to the given job metric id(s)
   * @param {string} projectID
   * @param {string} batchID
   * @param {string} jobID
   * @param {Array<string>} metricID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagsApi
   */
  public listTagsForJobMetrics(
    projectID: string,
    batchID: string,
    jobID: string,
    metricID: Array<string>,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return TagsApiFp(this.configuration)
      .listTagsForJobMetrics(
        projectID,
        batchID,
        jobID,
        metricID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * TestSuitesApi - axios parameter creator
 * @export
 */
export const TestSuitesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Add experiences to a test suite. This will generate a new test suite revision.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {SelectExperiencesInput} [selectExperiencesInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addExperiencesToTestSuite: async (
      projectID: string,
      testSuiteID: string,
      selectExperiencesInput?: SelectExperiencesInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('addExperiencesToTestSuite', 'projectID', projectID)
      // verify required parameter 'testSuiteID' is not null or undefined
      assertParamExists('addExperiencesToTestSuite', 'testSuiteID', testSuiteID)
      const localVarPath =
        `/projects/{projectID}/suites/{testSuiteID}/addExperiences`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(
            `{${'testSuiteID'}}`,
            encodeURIComponent(String(testSuiteID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        selectExperiencesInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Add experiences to test suites. This will generate a new test suite revision.
     * @param {string} projectID
     * @param {AddSuitesToExperiencesInput} [addSuitesToExperiencesInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestSuitesToExperiences: async (
      projectID: string,
      addSuitesToExperiencesInput?: AddSuitesToExperiencesInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('addTestSuitesToExperiences', 'projectID', projectID)
      const localVarPath =
        `/projects/{projectID}/suites/addExperiences`.replace(
          `{${'projectID'}}`,
          encodeURIComponent(String(projectID))
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        addSuitesToExperiencesInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Adds a test suite for a project.
     * @param {string} projectID
     * @param {CreateTestSuiteInput} [createTestSuiteInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTestSuite: async (
      projectID: string,
      createTestSuiteInput?: CreateTestSuiteInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('createTestSuite', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/suites`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createTestSuiteInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a specific test suite\'s latest revision.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTestSuite: async (
      projectID: string,
      testSuiteID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getTestSuite', 'projectID', projectID)
      // verify required parameter 'testSuiteID' is not null or undefined
      assertParamExists('getTestSuite', 'testSuiteID', testSuiteID)
      const localVarPath = `/projects/{projectID}/suites/{testSuiteID}`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'testSuiteID'}}`, encodeURIComponent(String(testSuiteID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns a specified revision of a test suite.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {number} revision
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTestSuiteRevision: async (
      projectID: string,
      testSuiteID: string,
      revision: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getTestSuiteRevision', 'projectID', projectID)
      // verify required parameter 'testSuiteID' is not null or undefined
      assertParamExists('getTestSuiteRevision', 'testSuiteID', testSuiteID)
      // verify required parameter 'revision' is not null or undefined
      assertParamExists('getTestSuiteRevision', 'revision', revision)
      const localVarPath =
        `/projects/{projectID}/suites/{testSuiteID}/revisions/{revision}`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(
            `{${'testSuiteID'}}`,
            encodeURIComponent(String(testSuiteID))
          )
          .replace(`{${'revision'}}`, encodeURIComponent(String(revision)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns an overview of test suites and high-level performance data. A test suite will only be returned if it has 1 or more reports on the main branch assocated to it.
     * @param {string} projectID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTestSuiteSummary: async (
      projectID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('getTestSuiteSummary', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/suites/summary`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns all the revisions of a specific test suite.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTestSuiteRevisions: async (
      projectID: string,
      testSuiteID: string,
      pageSize?: number,
      pageToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listTestSuiteRevisions', 'projectID', projectID)
      // verify required parameter 'testSuiteID' is not null or undefined
      assertParamExists('listTestSuiteRevisions', 'testSuiteID', testSuiteID)
      const localVarPath =
        `/projects/{projectID}/suites/{testSuiteID}/revisions`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(
            `{${'testSuiteID'}}`,
            encodeURIComponent(String(testSuiteID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Returns the list of test suites at their latest revision
     * @param {string} projectID
     * @param {Array<string>} [experienceIDs] Only return test suites that contain the given experience id(s)
     * @param {string} [systemID] Only return test suites that contain the given system id
     * @param {string} [name] Filter test suites by name
     * @param {string} [text] Filter test suites by a text string on name and description
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTestSuites: async (
      projectID: string,
      experienceIDs?: Array<string>,
      systemID?: string,
      name?: string,
      text?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('listTestSuites', 'projectID', projectID)
      const localVarPath = `/projects/{projectID}/suites`.replace(
        `{${'projectID'}}`,
        encodeURIComponent(String(projectID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:read'],
        configuration
      )

      if (experienceIDs) {
        localVarQueryParameter['experienceIDs'] = experienceIDs.join(
          COLLECTION_FORMATS.csv
        )
      }

      if (systemID !== undefined) {
        localVarQueryParameter['systemID'] = systemID
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (text !== undefined) {
        localVarQueryParameter['text'] = text
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Remove experiences from a test suite. This will generate a new test suite revision.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {SelectExperiencesInput} [selectExperiencesInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeExperiencesFromTestSuite: async (
      projectID: string,
      testSuiteID: string,
      selectExperiencesInput?: SelectExperiencesInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists(
        'removeExperiencesFromTestSuite',
        'projectID',
        projectID
      )
      // verify required parameter 'testSuiteID' is not null or undefined
      assertParamExists(
        'removeExperiencesFromTestSuite',
        'testSuiteID',
        testSuiteID
      )
      const localVarPath =
        `/projects/{projectID}/suites/{testSuiteID}/removeExperiences`
          .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
          .replace(
            `{${'testSuiteID'}}`,
            encodeURIComponent(String(testSuiteID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        selectExperiencesInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Revise a test suite, generating a new revision. Supply a false value for ad-hoc to convert an existing ad hoc test suite to a full test suite.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {ReviseTestSuiteInput} [reviseTestSuiteInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reviseTestSuite: async (
      projectID: string,
      testSuiteID: string,
      reviseTestSuiteInput?: ReviseTestSuiteInput,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectID' is not null or undefined
      assertParamExists('reviseTestSuite', 'projectID', projectID)
      // verify required parameter 'testSuiteID' is not null or undefined
      assertParamExists('reviseTestSuite', 'testSuiteID', testSuiteID)
      const localVarPath = `/projects/{projectID}/suites/{testSuiteID}`
        .replace(`{${'projectID'}}`, encodeURIComponent(String(projectID)))
        .replace(`{${'testSuiteID'}}`, encodeURIComponent(String(testSuiteID)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['batches:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        reviseTestSuiteInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * TestSuitesApi - functional programming interface
 * @export
 */
export const TestSuitesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TestSuitesApiAxiosParamCreator(configuration)
  return {
    /**
     * Add experiences to a test suite. This will generate a new test suite revision.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {SelectExperiencesInput} [selectExperiencesInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addExperiencesToTestSuite(
      projectID: string,
      testSuiteID: string,
      selectExperiencesInput?: SelectExperiencesInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestSuite>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addExperiencesToTestSuite(
          projectID,
          testSuiteID,
          selectExperiencesInput,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Add experiences to test suites. This will generate a new test suite revision.
     * @param {string} projectID
     * @param {AddSuitesToExperiencesInput} [addSuitesToExperiencesInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTestSuitesToExperiences(
      projectID: string,
      addSuitesToExperiencesInput?: AddSuitesToExperiencesInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addTestSuitesToExperiences(
          projectID,
          addSuitesToExperiencesInput,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Adds a test suite for a project.
     * @param {string} projectID
     * @param {CreateTestSuiteInput} [createTestSuiteInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTestSuite(
      projectID: string,
      createTestSuiteInput?: CreateTestSuiteInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestSuite>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createTestSuite(
        projectID,
        createTestSuiteInput,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a specific test suite\'s latest revision.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTestSuite(
      projectID: string,
      testSuiteID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestSuite>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTestSuite(
        projectID,
        testSuiteID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a specified revision of a test suite.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {number} revision
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTestSuiteRevision(
      projectID: string,
      testSuiteID: string,
      revision: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestSuite>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTestSuiteRevision(
          projectID,
          testSuiteID,
          revision,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns an overview of test suites and high-level performance data. A test suite will only be returned if it has 1 or more reports on the main branch assocated to it.
     * @param {string} projectID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTestSuiteSummary(
      projectID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TestSuiteSummaryOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTestSuiteSummary(
          projectID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns all the revisions of a specific test suite.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTestSuiteRevisions(
      projectID: string,
      testSuiteID: string,
      pageSize?: number,
      pageToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListTestSuiteRevisionsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listTestSuiteRevisions(
          projectID,
          testSuiteID,
          pageSize,
          pageToken,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns the list of test suites at their latest revision
     * @param {string} projectID
     * @param {Array<string>} [experienceIDs] Only return test suites that contain the given experience id(s)
     * @param {string} [systemID] Only return test suites that contain the given system id
     * @param {string} [name] Filter test suites by name
     * @param {string} [text] Filter test suites by a text string on name and description
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTestSuites(
      projectID: string,
      experienceIDs?: Array<string>,
      systemID?: string,
      name?: string,
      text?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListTestSuiteOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTestSuites(
        projectID,
        experienceIDs,
        systemID,
        name,
        text,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Remove experiences from a test suite. This will generate a new test suite revision.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {SelectExperiencesInput} [selectExperiencesInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeExperiencesFromTestSuite(
      projectID: string,
      testSuiteID: string,
      selectExperiencesInput?: SelectExperiencesInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestSuite>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removeExperiencesFromTestSuite(
          projectID,
          testSuiteID,
          selectExperiencesInput,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Revise a test suite, generating a new revision. Supply a false value for ad-hoc to convert an existing ad hoc test suite to a full test suite.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {ReviseTestSuiteInput} [reviseTestSuiteInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async reviseTestSuite(
      projectID: string,
      testSuiteID: string,
      reviseTestSuiteInput?: ReviseTestSuiteInput,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestSuite>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.reviseTestSuite(
        projectID,
        testSuiteID,
        reviseTestSuiteInput,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * TestSuitesApi - factory interface
 * @export
 */
export const TestSuitesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TestSuitesApiFp(configuration)
  return {
    /**
     * Add experiences to a test suite. This will generate a new test suite revision.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {SelectExperiencesInput} [selectExperiencesInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addExperiencesToTestSuite(
      projectID: string,
      testSuiteID: string,
      selectExperiencesInput?: SelectExperiencesInput,
      options?: any
    ): AxiosPromise<TestSuite> {
      return localVarFp
        .addExperiencesToTestSuite(
          projectID,
          testSuiteID,
          selectExperiencesInput,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Add experiences to test suites. This will generate a new test suite revision.
     * @param {string} projectID
     * @param {AddSuitesToExperiencesInput} [addSuitesToExperiencesInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTestSuitesToExperiences(
      projectID: string,
      addSuitesToExperiencesInput?: AddSuitesToExperiencesInput,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .addTestSuitesToExperiences(
          projectID,
          addSuitesToExperiencesInput,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Adds a test suite for a project.
     * @param {string} projectID
     * @param {CreateTestSuiteInput} [createTestSuiteInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTestSuite(
      projectID: string,
      createTestSuiteInput?: CreateTestSuiteInput,
      options?: any
    ): AxiosPromise<TestSuite> {
      return localVarFp
        .createTestSuite(projectID, createTestSuiteInput, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a specific test suite\'s latest revision.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTestSuite(
      projectID: string,
      testSuiteID: string,
      options?: any
    ): AxiosPromise<TestSuite> {
      return localVarFp
        .getTestSuite(projectID, testSuiteID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns a specified revision of a test suite.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {number} revision
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTestSuiteRevision(
      projectID: string,
      testSuiteID: string,
      revision: number,
      options?: any
    ): AxiosPromise<TestSuite> {
      return localVarFp
        .getTestSuiteRevision(projectID, testSuiteID, revision, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns an overview of test suites and high-level performance data. A test suite will only be returned if it has 1 or more reports on the main branch assocated to it.
     * @param {string} projectID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTestSuiteSummary(
      projectID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<TestSuiteSummaryOutput> {
      return localVarFp
        .getTestSuiteSummary(projectID, pageSize, pageToken, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns all the revisions of a specific test suite.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTestSuiteRevisions(
      projectID: string,
      testSuiteID: string,
      pageSize?: number,
      pageToken?: string,
      options?: any
    ): AxiosPromise<ListTestSuiteRevisionsOutput> {
      return localVarFp
        .listTestSuiteRevisions(
          projectID,
          testSuiteID,
          pageSize,
          pageToken,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the list of test suites at their latest revision
     * @param {string} projectID
     * @param {Array<string>} [experienceIDs] Only return test suites that contain the given experience id(s)
     * @param {string} [systemID] Only return test suites that contain the given system id
     * @param {string} [name] Filter test suites by name
     * @param {string} [text] Filter test suites by a text string on name and description
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTestSuites(
      projectID: string,
      experienceIDs?: Array<string>,
      systemID?: string,
      name?: string,
      text?: string,
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListTestSuiteOutput> {
      return localVarFp
        .listTestSuites(
          projectID,
          experienceIDs,
          systemID,
          name,
          text,
          pageSize,
          pageToken,
          orderBy,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Remove experiences from a test suite. This will generate a new test suite revision.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {SelectExperiencesInput} [selectExperiencesInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeExperiencesFromTestSuite(
      projectID: string,
      testSuiteID: string,
      selectExperiencesInput?: SelectExperiencesInput,
      options?: any
    ): AxiosPromise<TestSuite> {
      return localVarFp
        .removeExperiencesFromTestSuite(
          projectID,
          testSuiteID,
          selectExperiencesInput,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Revise a test suite, generating a new revision. Supply a false value for ad-hoc to convert an existing ad hoc test suite to a full test suite.
     * @param {string} projectID
     * @param {string} testSuiteID
     * @param {ReviseTestSuiteInput} [reviseTestSuiteInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reviseTestSuite(
      projectID: string,
      testSuiteID: string,
      reviseTestSuiteInput?: ReviseTestSuiteInput,
      options?: any
    ): AxiosPromise<TestSuite> {
      return localVarFp
        .reviseTestSuite(projectID, testSuiteID, reviseTestSuiteInput, options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * TestSuitesApi - object-oriented interface
 * @export
 * @class TestSuitesApi
 * @extends {BaseAPI}
 */
export class TestSuitesApi extends BaseAPI {
  /**
   * Add experiences to a test suite. This will generate a new test suite revision.
   * @param {string} projectID
   * @param {string} testSuiteID
   * @param {SelectExperiencesInput} [selectExperiencesInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuitesApi
   */
  public addExperiencesToTestSuite(
    projectID: string,
    testSuiteID: string,
    selectExperiencesInput?: SelectExperiencesInput,
    options?: AxiosRequestConfig
  ) {
    return TestSuitesApiFp(this.configuration)
      .addExperiencesToTestSuite(
        projectID,
        testSuiteID,
        selectExperiencesInput,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Add experiences to test suites. This will generate a new test suite revision.
   * @param {string} projectID
   * @param {AddSuitesToExperiencesInput} [addSuitesToExperiencesInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuitesApi
   */
  public addTestSuitesToExperiences(
    projectID: string,
    addSuitesToExperiencesInput?: AddSuitesToExperiencesInput,
    options?: AxiosRequestConfig
  ) {
    return TestSuitesApiFp(this.configuration)
      .addTestSuitesToExperiences(
        projectID,
        addSuitesToExperiencesInput,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Adds a test suite for a project.
   * @param {string} projectID
   * @param {CreateTestSuiteInput} [createTestSuiteInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuitesApi
   */
  public createTestSuite(
    projectID: string,
    createTestSuiteInput?: CreateTestSuiteInput,
    options?: AxiosRequestConfig
  ) {
    return TestSuitesApiFp(this.configuration)
      .createTestSuite(projectID, createTestSuiteInput, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a specific test suite\'s latest revision.
   * @param {string} projectID
   * @param {string} testSuiteID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuitesApi
   */
  public getTestSuite(
    projectID: string,
    testSuiteID: string,
    options?: AxiosRequestConfig
  ) {
    return TestSuitesApiFp(this.configuration)
      .getTestSuite(projectID, testSuiteID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns a specified revision of a test suite.
   * @param {string} projectID
   * @param {string} testSuiteID
   * @param {number} revision
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuitesApi
   */
  public getTestSuiteRevision(
    projectID: string,
    testSuiteID: string,
    revision: number,
    options?: AxiosRequestConfig
  ) {
    return TestSuitesApiFp(this.configuration)
      .getTestSuiteRevision(projectID, testSuiteID, revision, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns an overview of test suites and high-level performance data. A test suite will only be returned if it has 1 or more reports on the main branch assocated to it.
   * @param {string} projectID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuitesApi
   */
  public getTestSuiteSummary(
    projectID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return TestSuitesApiFp(this.configuration)
      .getTestSuiteSummary(projectID, pageSize, pageToken, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns all the revisions of a specific test suite.
   * @param {string} projectID
   * @param {string} testSuiteID
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuitesApi
   */
  public listTestSuiteRevisions(
    projectID: string,
    testSuiteID: string,
    pageSize?: number,
    pageToken?: string,
    options?: AxiosRequestConfig
  ) {
    return TestSuitesApiFp(this.configuration)
      .listTestSuiteRevisions(
        projectID,
        testSuiteID,
        pageSize,
        pageToken,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the list of test suites at their latest revision
   * @param {string} projectID
   * @param {Array<string>} [experienceIDs] Only return test suites that contain the given experience id(s)
   * @param {string} [systemID] Only return test suites that contain the given system id
   * @param {string} [name] Filter test suites by name
   * @param {string} [text] Filter test suites by a text string on name and description
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuitesApi
   */
  public listTestSuites(
    projectID: string,
    experienceIDs?: Array<string>,
    systemID?: string,
    name?: string,
    text?: string,
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return TestSuitesApiFp(this.configuration)
      .listTestSuites(
        projectID,
        experienceIDs,
        systemID,
        name,
        text,
        pageSize,
        pageToken,
        orderBy,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Remove experiences from a test suite. This will generate a new test suite revision.
   * @param {string} projectID
   * @param {string} testSuiteID
   * @param {SelectExperiencesInput} [selectExperiencesInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuitesApi
   */
  public removeExperiencesFromTestSuite(
    projectID: string,
    testSuiteID: string,
    selectExperiencesInput?: SelectExperiencesInput,
    options?: AxiosRequestConfig
  ) {
    return TestSuitesApiFp(this.configuration)
      .removeExperiencesFromTestSuite(
        projectID,
        testSuiteID,
        selectExperiencesInput,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Revise a test suite, generating a new revision. Supply a false value for ad-hoc to convert an existing ad hoc test suite to a full test suite.
   * @param {string} projectID
   * @param {string} testSuiteID
   * @param {ReviseTestSuiteInput} [reviseTestSuiteInput]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TestSuitesApi
   */
  public reviseTestSuite(
    projectID: string,
    testSuiteID: string,
    reviseTestSuiteInput?: ReviseTestSuiteInput,
    options?: AxiosRequestConfig
  ) {
    return TestSuitesApiFp(this.configuration)
      .reviseTestSuite(projectID, testSuiteID, reviseTestSuiteInput, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * ViewApi - axios parameter creator
 * @export
 */
export const ViewApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates a new View session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createViewSession: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/view/sessions`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['view:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['view:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['view:write'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Adds an update to the View session.  Updates will be serialized sequentially by ID.
     * @param {string} viewSessionID
     * @param {number} viewUpdateID
     * @param {File} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createViewUpdate: async (
      viewSessionID: string,
      viewUpdateID: number,
      body?: File,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'viewSessionID' is not null or undefined
      assertParamExists('createViewUpdate', 'viewSessionID', viewSessionID)
      // verify required parameter 'viewUpdateID' is not null or undefined
      assertParamExists('createViewUpdate', 'viewUpdateID', viewUpdateID)
      const localVarPath =
        `/view/sessions/{viewSessionID}/updates/{viewUpdateID}`
          .replace(
            `{${'viewSessionID'}}`,
            encodeURIComponent(String(viewSessionID))
          )
          .replace(
            `{${'viewUpdateID'}}`,
            encodeURIComponent(String(viewUpdateID))
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['view:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['view:write'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['view:write'],
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/octet-stream'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists the view object and metadata associated with a specific view.
     * @param {string} viewSessionID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getViewSession: async (
      viewSessionID: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'viewSessionID' is not null or undefined
      assertParamExists('getViewSession', 'viewSessionID', viewSessionID)
      const localVarPath = `/view/sessions/{viewSessionID}`.replace(
        `{${'viewSessionID'}}`,
        encodeURIComponent(String(viewSessionID))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['view:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['view:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['view:read'],
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Lists all View sessions.
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listViewSessions: async (
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/view/sessions`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['view:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['view:read'],
        configuration
      )

      // authentication OAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth',
        ['view:read'],
        configuration
      )

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * ViewApi - functional programming interface
 * @export
 */
export const ViewApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ViewApiAxiosParamCreator(configuration)
  return {
    /**
     * Creates a new View session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createViewSession(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createViewSession(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Adds an update to the View session.  Updates will be serialized sequentially by ID.
     * @param {string} viewSessionID
     * @param {number} viewUpdateID
     * @param {File} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createViewUpdate(
      viewSessionID: string,
      viewUpdateID: number,
      body?: File,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ViewSessionUpdate>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createViewUpdate(
          viewSessionID,
          viewUpdateID,
          body,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists the view object and metadata associated with a specific view.
     * @param {string} viewSessionID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getViewSession(
      viewSessionID: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ViewObjectAndMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getViewSession(
        viewSessionID,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Lists all View sessions.
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listViewSessions(
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListViewObjectsOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listViewSessions(
          pageSize,
          pageToken,
          orderBy,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    }
  }
}

/**
 * ViewApi - factory interface
 * @export
 */
export const ViewApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ViewApiFp(configuration)
  return {
    /**
     * Creates a new View session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createViewSession(options?: any): AxiosPromise<string> {
      return localVarFp
        .createViewSession(options)
        .then(request => request(axios, basePath))
    },
    /**
     * Adds an update to the View session.  Updates will be serialized sequentially by ID.
     * @param {string} viewSessionID
     * @param {number} viewUpdateID
     * @param {File} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createViewUpdate(
      viewSessionID: string,
      viewUpdateID: number,
      body?: File,
      options?: any
    ): AxiosPromise<ViewSessionUpdate> {
      return localVarFp
        .createViewUpdate(viewSessionID, viewUpdateID, body, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Lists the view object and metadata associated with a specific view.
     * @param {string} viewSessionID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getViewSession(
      viewSessionID: string,
      options?: any
    ): AxiosPromise<ViewObjectAndMetadata> {
      return localVarFp
        .getViewSession(viewSessionID, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Lists all View sessions.
     * @param {number} [pageSize]
     * @param {string} [pageToken]
     * @param {string} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listViewSessions(
      pageSize?: number,
      pageToken?: string,
      orderBy?: string,
      options?: any
    ): AxiosPromise<ListViewObjectsOutput> {
      return localVarFp
        .listViewSessions(pageSize, pageToken, orderBy, options)
        .then(request => request(axios, basePath))
    }
  }
}

/**
 * ViewApi - object-oriented interface
 * @export
 * @class ViewApi
 * @extends {BaseAPI}
 */
export class ViewApi extends BaseAPI {
  /**
   * Creates a new View session.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ViewApi
   */
  public createViewSession(options?: AxiosRequestConfig) {
    return ViewApiFp(this.configuration)
      .createViewSession(options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Adds an update to the View session.  Updates will be serialized sequentially by ID.
   * @param {string} viewSessionID
   * @param {number} viewUpdateID
   * @param {File} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ViewApi
   */
  public createViewUpdate(
    viewSessionID: string,
    viewUpdateID: number,
    body?: File,
    options?: AxiosRequestConfig
  ) {
    return ViewApiFp(this.configuration)
      .createViewUpdate(viewSessionID, viewUpdateID, body, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists the view object and metadata associated with a specific view.
   * @param {string} viewSessionID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ViewApi
   */
  public getViewSession(viewSessionID: string, options?: AxiosRequestConfig) {
    return ViewApiFp(this.configuration)
      .getViewSession(viewSessionID, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Lists all View sessions.
   * @param {number} [pageSize]
   * @param {string} [pageToken]
   * @param {string} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ViewApi
   */
  public listViewSessions(
    pageSize?: number,
    pageToken?: string,
    orderBy?: string,
    options?: AxiosRequestConfig
  ) {
    return ViewApiFp(this.configuration)
      .listViewSessions(pageSize, pageToken, orderBy, options)
      .then(request => request(this.axios, this.basePath))
  }
}
