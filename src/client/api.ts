/* tslint:disable */
/* eslint-disable */
/**
 * ReRun API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Batch
 */
export interface Batch {
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'batchID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'projectID'?: string;
    /**
     * 
     * @type {BatchStatus}
     * @memberof Batch
     */
    'status'?: BatchStatus;
    /**
     * 
     * @type {MetricStatus}
     * @memberof Batch
     */
    'batchMetricsStatus'?: MetricStatus;
    /**
     * 
     * @type {MetricStatus}
     * @memberof Batch
     */
    'jobsMetricsStatus'?: MetricStatus;
    /**
     * 
     * @type {MetricStatus}
     * @memberof Batch
     */
    'overallMetricsStatus'?: MetricStatus;
    /**
     * 
     * @type {Array<BatchStatusHistoryType>}
     * @memberof Batch
     */
    'statusHistory'?: Array<BatchStatusHistoryType>;
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'lastUpdatedTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'friendlyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'systemID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'buildID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'metricsBuildID'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Batch
     */
    'instantiatedExperienceIDs'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Batch
     */
    'instantiatedExperienceTagIDs'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Batch
     */
    'parameters'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'orgID'?: string;
    /**
     * 
     * @type {number}
     * @memberof Batch
     */
    'totalJobs'?: number;
    /**
     * 
     * @type {BatchJobStatusCounts}
     * @memberof Batch
     */
    'jobStatusCounts'?: BatchJobStatusCounts;
    /**
     * 
     * @type {JobMetricsStatusCounts}
     * @memberof Batch
     */
    'jobMetricsStatusCounts'?: JobMetricsStatusCounts;
}


/**
 * 
 * @export
 * @interface BatchInput
 */
export interface BatchInput {
    /**
     * 
     * @type {Array<string>}
     * @memberof BatchInput
     */
    'experienceIDs'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BatchInput
     */
    'experienceTagIDs'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BatchInput
     */
    'experienceNames'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BatchInput
     */
    'experienceTagNames'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof BatchInput
     */
    'buildID'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchInput
     */
    'metricsBuildID'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BatchInput
     */
    'parameters'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface BatchJobStatusCounts
 */
export interface BatchJobStatusCounts {
    /**
     * 
     * @type {number}
     * @memberof BatchJobStatusCounts
     */
    'submitted': number;
    /**
     * 
     * @type {number}
     * @memberof BatchJobStatusCounts
     */
    'running': number;
    /**
     * 
     * @type {number}
     * @memberof BatchJobStatusCounts
     */
    'succeeded': number;
    /**
     * 
     * @type {number}
     * @memberof BatchJobStatusCounts
     */
    'error': number;
    /**
     * 
     * @type {number}
     * @memberof BatchJobStatusCounts
     */
    'cancelled': number;
    /**
     * 
     * @type {number}
     * @memberof BatchJobStatusCounts
     */
    'metricsQueued': number;
    /**
     * 
     * @type {number}
     * @memberof BatchJobStatusCounts
     */
    'metricsRunning': number;
}
/**
 * 
 * @export
 * @interface BatchLog
 */
export interface BatchLog {
    /**
     * 
     * @type {string}
     * @memberof BatchLog
     */
    'logID'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchLog
     */
    'fileName'?: string;
    /**
     * 
     * @type {number}
     * @memberof BatchLog
     */
    'fileSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchLog
     */
    'checksum'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchLog
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchLog
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchLog
     */
    'logOutputLocation'?: string;
    /**
     * 
     * @type {ExecutionStep}
     * @memberof BatchLog
     */
    'executionStep'?: ExecutionStep;
    /**
     * 
     * @type {LogType}
     * @memberof BatchLog
     */
    'logType'?: LogType;
    /**
     * 
     * @type {string}
     * @memberof BatchLog
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchLog
     */
    'orgID'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchLog
     */
    'batchID'?: string;
}


/**
 * 
 * @export
 * @interface BatchMetric
 */
export interface BatchMetric {
    /**
     * 
     * @type {string}
     * @memberof BatchMetric
     */
    'metricID'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMetric
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMetric
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMetric
     */
    'fileLocation'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMetric
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMetric
     */
    'orgID'?: string;
    /**
     * 
     * @type {MetricStatus}
     * @memberof BatchMetric
     */
    'status'?: MetricStatus;
    /**
     * 
     * @type {MetricType}
     * @memberof BatchMetric
     */
    'type'?: MetricType;
    /**
     * 
     * @type {Array<string>}
     * @memberof BatchMetric
     */
    'dataIDs'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof BatchMetric
     */
    'value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BatchMetric
     */
    'metricURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMetric
     */
    'batchID'?: string;
}


/**
 * 
 * @export
 * @interface BatchMetricsData
 */
export interface BatchMetricsData {
    /**
     * 
     * @type {string}
     * @memberof BatchMetricsData
     */
    'dataID'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMetricsData
     */
    'fileLocation'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMetricsData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMetricsData
     */
    'orgID'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMetricsData
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMetricsData
     */
    'metricsDataURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMetricsData
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchMetricsData
     */
    'batchID'?: string;
}
/**
 * 
 * @export
 * @interface BatchMetricsDataAndIDs
 */
export interface BatchMetricsDataAndIDs {
    /**
     * 
     * @type {string}
     * @memberof BatchMetricsDataAndIDs
     */
    'batchMetricID'?: string;
    /**
     * 
     * @type {BatchMetricsData}
     * @memberof BatchMetricsDataAndIDs
     */
    'batchMetricsData'?: BatchMetricsData;
}
/**
 * 
 * @export
 * @interface BatchMetricsDataToBatchMetric
 */
export interface BatchMetricsDataToBatchMetric {
    /**
     * 
     * @type {string}
     * @memberof BatchMetricsDataToBatchMetric
     */
    'batchMetricID'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BatchMetricsDataToBatchMetric
     */
    'batchMetricsDataIDs'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BatchStatus = {
    Submitted: 'SUBMITTED',
    ExperiencesRunning: 'EXPERIENCES_RUNNING',
    BatchMetricsQueued: 'BATCH_METRICS_QUEUED',
    BatchMetricsRunning: 'BATCH_METRICS_RUNNING',
    Error: 'ERROR',
    Succeeded: 'SUCCEEDED',
    Cancelled: 'CANCELLED'
} as const;

export type BatchStatus = typeof BatchStatus[keyof typeof BatchStatus];


/**
 * 
 * @export
 * @interface BatchStatusHistoryType
 */
export interface BatchStatusHistoryType {
    /**
     * 
     * @type {BatchStatus}
     * @memberof BatchStatusHistoryType
     */
    'status'?: BatchStatus;
    /**
     * 
     * @type {string}
     * @memberof BatchStatusHistoryType
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @interface Branch
 */
export interface Branch {
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'branchID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'projectID'?: string;
    /**
     * 
     * @type {BranchType}
     * @memberof Branch
     */
    'branchType'?: BranchType;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'orgID'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const BranchType = {
    ChangeRequest: 'CHANGE_REQUEST',
    Main: 'MAIN',
    Release: 'RELEASE'
} as const;

export type BranchType = typeof BranchType[keyof typeof BranchType];


/**
 * 
 * @export
 * @interface Build
 */
export interface Build {
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'buildID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'branchID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'projectID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'systemID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'imageUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'orgID'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ExecutionStep = {
    Experience: 'EXPERIENCE',
    Metrics: 'METRICS',
    BatchMetrics: 'BATCH_METRICS'
} as const;

export type ExecutionStep = typeof ExecutionStep[keyof typeof ExecutionStep];


/**
 * 
 * @export
 * @interface Experience
 */
export interface Experience {
    /**
     * 
     * @type {string}
     * @memberof Experience
     */
    'experienceID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Experience
     */
    'projectID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Experience
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Experience
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Experience
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof Experience
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Experience
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Experience
     */
    'orgID'?: string;
}
/**
 * 
 * @export
 * @interface ExperienceInput
 */
export interface ExperienceInput {
    /**
     * 
     * @type {Array<string>}
     * @memberof ExperienceInput
     */
    'updateMask'?: Array<string>;
    /**
     * 
     * @type {Experience}
     * @memberof ExperienceInput
     */
    'experience'?: Experience;
}
/**
 * 
 * @export
 * @interface ExperienceLocation
 */
export interface ExperienceLocation {
    /**
     * 
     * @type {string}
     * @memberof ExperienceLocation
     */
    'location'?: string;
}
/**
 * 
 * @export
 * @interface ExperienceLocationContents
 */
export interface ExperienceLocationContents {
    /**
     * 
     * @type {Array<string>}
     * @memberof ExperienceLocationContents
     */
    'objects'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ExperienceLocationContents
     */
    'objectCount'?: number;
}
/**
 * 
 * @export
 * @interface ExperienceTag
 */
export interface ExperienceTag {
    /**
     * 
     * @type {string}
     * @memberof ExperienceTag
     */
    'experienceTagID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExperienceTag
     */
    'projectID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExperienceTag
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExperienceTag
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExperienceTag
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExperienceTag
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExperienceTag
     */
    'orgID'?: string;
}
/**
 * 
 * @export
 * @interface ExperienceTagInput
 */
export interface ExperienceTagInput {
    /**
     * 
     * @type {Array<string>}
     * @memberof ExperienceTagInput
     */
    'updateMask'?: Array<string>;
    /**
     * 
     * @type {ExperienceTag}
     * @memberof ExperienceTagInput
     */
    'experienceTag'?: ExperienceTag;
}
/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'jobID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'projectID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'batchID'?: string;
    /**
     * 
     * @type {JobStatus}
     * @memberof Job
     */
    'jobStatus'?: JobStatus;
    /**
     * 
     * @type {MetricStatus}
     * @memberof Job
     */
    'jobMetricsStatus'?: MetricStatus;
    /**
     * 
     * @type {Array<JobStatusHistoryType>}
     * @memberof Job
     */
    'statusHistory'?: Array<JobStatusHistoryType>;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'lastUpdatedTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'outputLocation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'experienceID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'experienceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'buildID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Job
     */
    'parameters'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'orgID'?: string;
}


/**
 * 
 * @export
 * @interface JobLog
 */
export interface JobLog {
    /**
     * 
     * @type {string}
     * @memberof JobLog
     */
    'logID'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobLog
     */
    'fileName'?: string;
    /**
     * 
     * @type {number}
     * @memberof JobLog
     */
    'fileSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof JobLog
     */
    'checksum'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobLog
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobLog
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobLog
     */
    'logOutputLocation'?: string;
    /**
     * 
     * @type {ExecutionStep}
     * @memberof JobLog
     */
    'executionStep'?: ExecutionStep;
    /**
     * 
     * @type {LogType}
     * @memberof JobLog
     */
    'logType'?: LogType;
    /**
     * 
     * @type {string}
     * @memberof JobLog
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobLog
     */
    'orgID'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobLog
     */
    'jobID'?: string;
}


/**
 * 
 * @export
 * @interface JobMetric
 */
export interface JobMetric {
    /**
     * 
     * @type {string}
     * @memberof JobMetric
     */
    'metricID'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobMetric
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobMetric
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobMetric
     */
    'fileLocation'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobMetric
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobMetric
     */
    'orgID'?: string;
    /**
     * 
     * @type {MetricStatus}
     * @memberof JobMetric
     */
    'status'?: MetricStatus;
    /**
     * 
     * @type {MetricType}
     * @memberof JobMetric
     */
    'type'?: MetricType;
    /**
     * 
     * @type {Array<string>}
     * @memberof JobMetric
     */
    'dataIDs'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof JobMetric
     */
    'value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof JobMetric
     */
    'metricURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobMetric
     */
    'jobID'?: string;
}


/**
 * 
 * @export
 * @interface JobMetricsData
 */
export interface JobMetricsData {
    /**
     * 
     * @type {string}
     * @memberof JobMetricsData
     */
    'dataID'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobMetricsData
     */
    'fileLocation'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobMetricsData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobMetricsData
     */
    'orgID'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobMetricsData
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobMetricsData
     */
    'metricsDataURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobMetricsData
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobMetricsData
     */
    'jobID'?: string;
}
/**
 * 
 * @export
 * @interface JobMetricsStatusCounts
 */
export interface JobMetricsStatusCounts {
    /**
     * 
     * @type {number}
     * @memberof JobMetricsStatusCounts
     */
    'passed': number;
    /**
     * 
     * @type {number}
     * @memberof JobMetricsStatusCounts
     */
    'raw': number;
    /**
     * 
     * @type {number}
     * @memberof JobMetricsStatusCounts
     */
    'noStatusReported': number;
    /**
     * 
     * @type {number}
     * @memberof JobMetricsStatusCounts
     */
    'notApplicable': number;
    /**
     * 
     * @type {number}
     * @memberof JobMetricsStatusCounts
     */
    'failWarn': number;
    /**
     * 
     * @type {number}
     * @memberof JobMetricsStatusCounts
     */
    'failBlock': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JobStatus = {
    Submitted: 'SUBMITTED',
    ExperienceRunning: 'EXPERIENCE_RUNNING',
    MetricsQueued: 'METRICS_QUEUED',
    MetricsRunning: 'METRICS_RUNNING',
    Error: 'ERROR',
    Succeeded: 'SUCCEEDED',
    Cancelled: 'CANCELLED'
} as const;

export type JobStatus = typeof JobStatus[keyof typeof JobStatus];


/**
 * 
 * @export
 * @interface JobStatusHistoryType
 */
export interface JobStatusHistoryType {
    /**
     * 
     * @type {JobStatus}
     * @memberof JobStatusHistoryType
     */
    'status'?: JobStatus;
    /**
     * 
     * @type {string}
     * @memberof JobStatusHistoryType
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @interface ListBatchLogsOutput
 */
export interface ListBatchLogsOutput {
    /**
     * 
     * @type {Array<BatchLog>}
     * @memberof ListBatchLogsOutput
     */
    'logs'?: Array<BatchLog>;
    /**
     * 
     * @type {string}
     * @memberof ListBatchLogsOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListBatchMetricsDataForBatchMetricIDsOutput
 */
export interface ListBatchMetricsDataForBatchMetricIDsOutput {
    /**
     * 
     * @type {Array<BatchMetricsDataAndIDs>}
     * @memberof ListBatchMetricsDataForBatchMetricIDsOutput
     */
    'batchMetricsDataAndIDs'?: Array<BatchMetricsDataAndIDs>;
    /**
     * 
     * @type {string}
     * @memberof ListBatchMetricsDataForBatchMetricIDsOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListBatchMetricsDataOutput
 */
export interface ListBatchMetricsDataOutput {
    /**
     * 
     * @type {Array<BatchMetricsData>}
     * @memberof ListBatchMetricsDataOutput
     */
    'batchMetricsData'?: Array<BatchMetricsData>;
    /**
     * 
     * @type {string}
     * @memberof ListBatchMetricsDataOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListBatchMetricsOutput
 */
export interface ListBatchMetricsOutput {
    /**
     * 
     * @type {Array<BatchMetric>}
     * @memberof ListBatchMetricsOutput
     */
    'batchMetrics'?: Array<BatchMetric>;
    /**
     * 
     * @type {string}
     * @memberof ListBatchMetricsOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListBatchesOutput
 */
export interface ListBatchesOutput {
    /**
     * 
     * @type {Array<Batch>}
     * @memberof ListBatchesOutput
     */
    'batches'?: Array<Batch>;
    /**
     * 
     * @type {string}
     * @memberof ListBatchesOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListBranchesOutput
 */
export interface ListBranchesOutput {
    /**
     * 
     * @type {Array<Branch>}
     * @memberof ListBranchesOutput
     */
    'branches'?: Array<Branch>;
    /**
     * 
     * @type {string}
     * @memberof ListBranchesOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListBuildsOutput
 */
export interface ListBuildsOutput {
    /**
     * 
     * @type {Array<Build>}
     * @memberof ListBuildsOutput
     */
    'builds'?: Array<Build>;
    /**
     * 
     * @type {string}
     * @memberof ListBuildsOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListExperienceTagsOutput
 */
export interface ListExperienceTagsOutput {
    /**
     * 
     * @type {Array<ExperienceTag>}
     * @memberof ListExperienceTagsOutput
     */
    'experienceTags'?: Array<ExperienceTag>;
    /**
     * 
     * @type {string}
     * @memberof ListExperienceTagsOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListExperiencesOutput
 */
export interface ListExperiencesOutput {
    /**
     * 
     * @type {Array<Experience>}
     * @memberof ListExperiencesOutput
     */
    'experiences'?: Array<Experience>;
    /**
     * 
     * @type {string}
     * @memberof ListExperiencesOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListJobLogsOutput
 */
export interface ListJobLogsOutput {
    /**
     * 
     * @type {Array<JobLog>}
     * @memberof ListJobLogsOutput
     */
    'logs'?: Array<JobLog>;
    /**
     * 
     * @type {string}
     * @memberof ListJobLogsOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListJobMetricsDataOutput
 */
export interface ListJobMetricsDataOutput {
    /**
     * 
     * @type {Array<JobMetricsData>}
     * @memberof ListJobMetricsDataOutput
     */
    'metricsData'?: Array<JobMetricsData>;
    /**
     * 
     * @type {string}
     * @memberof ListJobMetricsDataOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListJobMetricsOutput
 */
export interface ListJobMetricsOutput {
    /**
     * 
     * @type {Array<JobMetric>}
     * @memberof ListJobMetricsOutput
     */
    'metrics'?: Array<JobMetric>;
    /**
     * 
     * @type {string}
     * @memberof ListJobMetricsOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListJobsOutput
 */
export interface ListJobsOutput {
    /**
     * 
     * @type {Array<Job>}
     * @memberof ListJobsOutput
     */
    'jobs'?: Array<Job>;
    /**
     * 
     * @type {string}
     * @memberof ListJobsOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListMetricsBuildOutput
 */
export interface ListMetricsBuildOutput {
    /**
     * 
     * @type {Array<MetricsBuild>}
     * @memberof ListMetricsBuildOutput
     */
    'metricsBuilds'?: Array<MetricsBuild>;
    /**
     * 
     * @type {string}
     * @memberof ListMetricsBuildOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListMetricsDataAndMetricIDOutput
 */
export interface ListMetricsDataAndMetricIDOutput {
    /**
     * 
     * @type {Array<MetricsDataAndMetricID>}
     * @memberof ListMetricsDataAndMetricIDOutput
     */
    'metricsDataAndIDs'?: Array<MetricsDataAndMetricID>;
    /**
     * 
     * @type {string}
     * @memberof ListMetricsDataAndMetricIDOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListParameterSweepsOutput
 */
export interface ListParameterSweepsOutput {
    /**
     * 
     * @type {Array<ParameterSweep>}
     * @memberof ListParameterSweepsOutput
     */
    'sweeps'?: Array<ParameterSweep>;
    /**
     * 
     * @type {string}
     * @memberof ListParameterSweepsOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListProjectsOutput
 */
export interface ListProjectsOutput {
    /**
     * 
     * @type {Array<Project>}
     * @memberof ListProjectsOutput
     */
    'projects'?: Array<Project>;
    /**
     * 
     * @type {string}
     * @memberof ListProjectsOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListSystemsOutput
 */
export interface ListSystemsOutput {
    /**
     * 
     * @type {Array<System>}
     * @memberof ListSystemsOutput
     */
    'systems'?: Array<System>;
    /**
     * 
     * @type {string}
     * @memberof ListSystemsOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListViewObjectsOutput
 */
export interface ListViewObjectsOutput {
    /**
     * 
     * @type {Array<ViewObject>}
     * @memberof ListViewObjectsOutput
     */
    'viewSessions'?: Array<ViewObject>;
    /**
     * 
     * @type {string}
     * @memberof ListViewObjectsOutput
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface Log
 */
export interface Log {
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'logID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'fileName'?: string;
    /**
     * 
     * @type {number}
     * @memberof Log
     */
    'fileSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'checksum'?: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'logOutputLocation'?: string;
    /**
     * 
     * @type {ExecutionStep}
     * @memberof Log
     */
    'executionStep'?: ExecutionStep;
    /**
     * 
     * @type {LogType}
     * @memberof Log
     */
    'logType'?: LogType;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'orgID'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const LogType = {
    OtherLog: 'OTHER_LOG',
    MetricsOutputLog: 'METRICS_OUTPUT_LOG',
    ContainerLog: 'CONTAINER_LOG',
    ExecutionLog: 'EXECUTION_LOG',
    McapLog: 'MCAP_LOG',
    Mp4Log: 'MP4_LOG',
    ArchiveLog: 'ARCHIVE_LOG'
} as const;

export type LogType = typeof LogType[keyof typeof LogType];


/**
 * 
 * @export
 * @interface Metric
 */
export interface Metric {
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'metricID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'fileLocation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'orgID'?: string;
    /**
     * 
     * @type {MetricStatus}
     * @memberof Metric
     */
    'status'?: MetricStatus;
    /**
     * 
     * @type {MetricType}
     * @memberof Metric
     */
    'type'?: MetricType;
    /**
     * 
     * @type {Array<string>}
     * @memberof Metric
     */
    'dataIDs'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    'value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'metricURL'?: string;
}


/**
 * 
 * @export
 * @interface MetricDataToMetric
 */
export interface MetricDataToMetric {
    /**
     * 
     * @type {string}
     * @memberof MetricDataToMetric
     */
    'metricID'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetricDataToMetric
     */
    'metricsDataIDs'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MetricStatus = {
    Passed: 'PASSED',
    FailWarn: 'FAIL_WARN',
    Raw: 'RAW',
    NotApplicable: 'NOT_APPLICABLE',
    FailBlock: 'FAIL_BLOCK',
    NoStatusReported: 'NO_STATUS_REPORTED'
} as const;

export type MetricStatus = typeof MetricStatus[keyof typeof MetricStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const MetricType = {
    Scalar: 'SCALAR',
    Composite: 'COMPOSITE'
} as const;

export type MetricType = typeof MetricType[keyof typeof MetricType];


/**
 * 
 * @export
 * @interface MetricsBuild
 */
export interface MetricsBuild {
    /**
     * 
     * @type {string}
     * @memberof MetricsBuild
     */
    'metricsBuildID'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsBuild
     */
    'projectID'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsBuild
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsBuild
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsBuild
     */
    'imageUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsBuild
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsBuild
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsBuild
     */
    'orgID'?: string;
}
/**
 * 
 * @export
 * @interface MetricsData
 */
export interface MetricsData {
    /**
     * 
     * @type {string}
     * @memberof MetricsData
     */
    'dataID'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsData
     */
    'fileLocation'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsData
     */
    'orgID'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsData
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsData
     */
    'metricsDataURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsData
     */
    'creationTimestamp'?: string;
}
/**
 * 
 * @export
 * @interface MetricsDataAndMetricID
 */
export interface MetricsDataAndMetricID {
    /**
     * 
     * @type {string}
     * @memberof MetricsDataAndMetricID
     */
    'metricID'?: string;
    /**
     * 
     * @type {JobMetricsData}
     * @memberof MetricsDataAndMetricID
     */
    'metricsData'?: JobMetricsData;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ObjectType = {
    Frame: 'TYPE_FRAME',
    Se3: 'TYPE_SE3',
    So3: 'TYPE_SO3',
    DcurveSe3: 'TYPE_DCURVE_SE3',
    TcurveSe3: 'TYPE_TCURVE_SE3',
    Trajectory: 'TYPE_TRAJECTORY',
    FramedVector: 'TYPE_FRAMED_VECTOR'
} as const;

export type ObjectType = typeof ObjectType[keyof typeof ObjectType];


/**
 * 
 * @export
 * @interface ParameterSweep
 */
export interface ParameterSweep {
    /**
     * 
     * @type {string}
     * @memberof ParameterSweep
     */
    'parameterSweepID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterSweep
     */
    'projectID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterSweep
     */
    'name'?: string;
    /**
     * 
     * @type {ParameterSweepStatus}
     * @memberof ParameterSweep
     */
    'status'?: ParameterSweepStatus;
    /**
     * 
     * @type {Array<ParameterSweepStatusHistoryType>}
     * @memberof ParameterSweep
     */
    'statusHistory'?: Array<ParameterSweepStatusHistoryType>;
    /**
     * 
     * @type {string}
     * @memberof ParameterSweep
     */
    'lastUpdatedTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterSweep
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {Array<SweepParameter>}
     * @memberof ParameterSweep
     */
    'parameters'?: Array<SweepParameter>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ParameterSweep
     */
    'batches'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ParameterSweep
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterSweep
     */
    'orgID'?: string;
}


/**
 * 
 * @export
 * @interface ParameterSweepInput
 */
export interface ParameterSweepInput {
    /**
     * 
     * @type {Array<SweepParameter>}
     * @memberof ParameterSweepInput
     */
    'parameters'?: Array<SweepParameter>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ParameterSweepInput
     */
    'experienceIDs'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ParameterSweepInput
     */
    'experienceTagIDs'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ParameterSweepInput
     */
    'experienceNames'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ParameterSweepInput
     */
    'experienceTagNames'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ParameterSweepInput
     */
    'buildID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterSweepInput
     */
    'metricsBuildID'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ParameterSweepStatus = {
    Submitted: 'SUBMITTED',
    Running: 'RUNNING',
    Succeeded: 'SUCCEEDED',
    Error: 'ERROR'
} as const;

export type ParameterSweepStatus = typeof ParameterSweepStatus[keyof typeof ParameterSweepStatus];


/**
 * 
 * @export
 * @interface ParameterSweepStatusHistoryType
 */
export interface ParameterSweepStatusHistoryType {
    /**
     * 
     * @type {ParameterSweepStatus}
     * @memberof ParameterSweepStatusHistoryType
     */
    'status'?: ParameterSweepStatus;
    /**
     * 
     * @type {string}
     * @memberof ParameterSweepStatusHistoryType
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'projectID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'orgID'?: string;
}
/**
 * 
 * @export
 * @interface ProjectUpdateInput
 */
export interface ProjectUpdateInput {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProjectUpdateInput
     */
    'updateMask'?: Array<string>;
    /**
     * 
     * @type {Project}
     * @memberof ProjectUpdateInput
     */
    'project'?: Project;
}
/**
 * 
 * @export
 * @interface SandboxInput
 */
export interface SandboxInput {
    /**
     * 
     * @type {string}
     * @memberof SandboxInput
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof SandboxInput
     */
    'orgID'?: string;
}
/**
 * 
 * @export
 * @interface SweepParameter
 */
export interface SweepParameter {
    /**
     * 
     * @type {string}
     * @memberof SweepParameter
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SweepParameter
     */
    'values'?: Array<string>;
}
/**
 * 
 * @export
 * @interface System
 */
export interface System {
    /**
     * 
     * @type {string}
     * @memberof System
     */
    'systemID'?: string;
    /**
     * 
     * @type {string}
     * @memberof System
     */
    'projectID'?: string;
    /**
     * 
     * @type {string}
     * @memberof System
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof System
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof System
     */
    'build_vcpus'?: number;
    /**
     * 
     * @type {number}
     * @memberof System
     */
    'build_memory_mib'?: number;
    /**
     * 
     * @type {number}
     * @memberof System
     */
    'build_gpus'?: number;
    /**
     * 
     * @type {number}
     * @memberof System
     */
    'build_shared_memory_mb'?: number;
    /**
     * 
     * @type {number}
     * @memberof System
     */
    'metrics_build_vcpus'?: number;
    /**
     * 
     * @type {number}
     * @memberof System
     */
    'metrics_build_memory_mib'?: number;
    /**
     * 
     * @type {number}
     * @memberof System
     */
    'metrics_build_gpus'?: number;
    /**
     * 
     * @type {number}
     * @memberof System
     */
    'metrics_build_shared_memory_mb'?: number;
    /**
     * 
     * @type {string}
     * @memberof System
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof System
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof System
     */
    'orgID'?: string;
}
/**
 * 
 * @export
 * @interface SystemInput
 */
export interface SystemInput {
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemInput
     */
    'updateMask'?: Array<string>;
    /**
     * 
     * @type {System}
     * @memberof SystemInput
     */
    'system'?: System;
}
/**
 * 
 * @export
 * @interface ViewMetadata
 */
export interface ViewMetadata {
    /**
     * 
     * @type {string}
     * @memberof ViewMetadata
     */
    'objectName'?: string;
    /**
     * 
     * @type {ObjectType}
     * @memberof ViewMetadata
     */
    'objectType'?: ObjectType;
    /**
     * 
     * @type {string}
     * @memberof ViewMetadata
     */
    'fileName'?: string;
    /**
     * 
     * @type {number}
     * @memberof ViewMetadata
     */
    'lineNumber'?: number;
}


/**
 * 
 * @export
 * @interface ViewObject
 */
export interface ViewObject {
    /**
     * 
     * @type {string}
     * @memberof ViewObject
     */
    'viewSessionID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewObject
     */
    'friendlyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewObject
     */
    'viewTimestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof ViewObject
     */
    'objectCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ViewObject
     */
    'mcapURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewObject
     */
    'viewURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewObject
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewObject
     */
    'orgID'?: string;
}
/**
 * 
 * @export
 * @interface ViewObjectAndMetadata
 */
export interface ViewObjectAndMetadata {
    /**
     * 
     * @type {ViewObject}
     * @memberof ViewObjectAndMetadata
     */
    'viewObject'?: ViewObject;
    /**
     * 
     * @type {Array<ViewMetadata>}
     * @memberof ViewObjectAndMetadata
     */
    'viewMetadata'?: Array<ViewMetadata>;
}
/**
 * 
 * @export
 * @interface ViewSessionUpdate
 */
export interface ViewSessionUpdate {
    /**
     * 
     * @type {string}
     * @memberof ViewSessionUpdate
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewSessionUpdate
     */
    'mcap'?: string;
    /**
     * A link to view the session.
     * @type {string}
     * @memberof ViewSessionUpdate
     */
    'view'?: string;
}

/**
 * BatchesApi - axios parameter creator
 * @export
 */
export const BatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds batch metrics data (IDs) to a given batch metric
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBatchMetricsDataToBatchMetric: async (projectID: string, batchID: string, metricID: string, requestBody?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('addBatchMetricsDataToBatchMetric', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('addBatchMetricsDataToBatchMetric', 'batchID', batchID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('addBatchMetricsDataToBatchMetric', 'metricID', metricID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metrics/{metricID}/metricsData`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds metrics data (IDs) to a given metric
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetricsDataToMetric: async (projectID: string, batchID: string, jobID: string, metricID: string, requestBody?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('addMetricsDataToMetric', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('addMetricsDataToMetric', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('addMetricsDataToMetric', 'jobID', jobID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('addMetricsDataToMetric', 'metricID', metricID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics/{metricID}/metricsData`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels a batch.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelBatch: async (projectID: string, batchID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('cancelBatch', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('cancelBatch', 'batchID', batchID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/:cancel`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a batch.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {BatchInput} [batchInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch: async (projectID: string, batchInput?: BatchInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createBatch', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}/batches`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a log.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {BatchLog} [batchLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchLog: async (projectID: string, batchID: string, batchLog?: BatchLog, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createBatchLog', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('createBatchLog', 'batchID', batchID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/logs`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a batch metric. ID and location should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {BatchMetric} [batchMetric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchMetric: async (projectID: string, batchID: string, batchMetric?: BatchMetric, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createBatchMetric', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('createBatchMetric', 'batchID', batchID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metrics`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchMetric, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new metrics data associated with a batch
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {BatchMetricsData} [batchMetricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchMetricsData: async (projectID: string, batchID: string, batchMetricsData?: BatchMetricsData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createBatchMetricsData', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('createBatchMetricsData', 'batchID', batchID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metricsData`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchMetricsData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a log.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {JobLog} [jobLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobLog: async (projectID: string, batchID: string, jobID: string, jobLog?: JobLog, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createJobLog', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('createJobLog', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('createJobLog', 'jobID', jobID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/logs`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a metric. ID and location should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {JobMetric} [jobMetric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetric: async (projectID: string, batchID: string, jobID: string, jobMetric?: JobMetric, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createMetric', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('createMetric', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('createMetric', 'jobID', jobID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobMetric, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new metrics data associated with a job
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {JobMetricsData} [jobMetricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricsData: async (projectID: string, batchID: string, jobID: string, jobMetricsData?: JobMetricsData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createMetricsData', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('createMetricsData', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('createMetricsData', 'jobID', jobID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metricsData`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobMetricsData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a log.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatchLog: async (projectID: string, batchID: string, logID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('deleteBatchLog', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('deleteBatchLog', 'batchID', batchID)
            // verify required parameter 'logID' is not null or undefined
            assertParamExists('deleteBatchLog', 'logID', logID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/logs/{logID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"logID"}}`, encodeURIComponent(String(logID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a log.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobLog: async (projectID: string, batchID: string, jobID: string, logID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('deleteJobLog', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('deleteJobLog', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('deleteJobLog', 'jobID', jobID)
            // verify required parameter 'logID' is not null or undefined
            assertParamExists('deleteJobLog', 'logID', logID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/logs/{logID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"logID"}}`, encodeURIComponent(String(logID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a batch.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatch: async (projectID: string, batchID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getBatch', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('getBatch', 'batchID', batchID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an individual log file
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchLog: async (projectID: string, batchID: string, logID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getBatchLog', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('getBatchLog', 'batchID', batchID)
            // verify required parameter 'logID' is not null or undefined
            assertParamExists('getBatchLog', 'logID', logID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/logs/{logID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"logID"}}`, encodeURIComponent(String(logID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the given job.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob: async (projectID: string, batchID: string, jobID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getJob', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('getJob', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('getJob', 'jobID', jobID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an individual log file
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobLog: async (projectID: string, batchID: string, jobID: string, logID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getJobLog', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('getJobLog', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('getJobLog', 'jobID', jobID)
            // verify required parameter 'logID' is not null or undefined
            assertParamExists('getJobLog', 'logID', logID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/logs/{logID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"logID"}}`, encodeURIComponent(String(logID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the logs associated with a given batch
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchLogsForBatch: async (projectID: string, batchID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBatchLogsForBatch', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listBatchLogsForBatch', 'batchID', batchID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/logs`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the (batch) metrics for a given batch. Does not return associated data.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetrics: async (projectID: string, batchID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBatchMetrics', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listBatchMetrics', 'batchID', batchID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metrics`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metrics data associated with a given batch ID
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetricsData: async (projectID: string, batchID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBatchMetricsData', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listBatchMetricsData', 'batchID', batchID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metricsData`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the batch metrics data associated with given batch metric ID(s)
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetricsDataForBatchMetricIDs: async (projectID: string, batchID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBatchMetricsDataForBatchMetricIDs', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listBatchMetricsDataForBatchMetricIDs', 'batchID', batchID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('listBatchMetricsDataForBatchMetricIDs', 'metricID', metricID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metrics/{metricID}/metricsData`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the batch metrics data associated with given batch metrics data IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetricsDataForBatchMetricsDataIDs: async (projectID: string, batchID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBatchMetricsDataForBatchMetricsDataIDs', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listBatchMetricsDataForBatchMetricsDataIDs', 'batchID', batchID)
            // verify required parameter 'metricsDataID' is not null or undefined
            assertParamExists('listBatchMetricsDataForBatchMetricsDataIDs', 'metricsDataID', metricsDataID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metricsData/{metricsDataID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"metricsDataID"}}`, encodeURIComponent(String(metricsDataID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the batch metrics associated with given batch metric IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetricsForBatchMetricIDs: async (projectID: string, batchID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBatchMetricsForBatchMetricIDs', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listBatchMetricsForBatchMetricIDs', 'batchID', batchID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('listBatchMetricsForBatchMetricIDs', 'metricID', metricID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metrics/{metricID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the batches.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatches: async (projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBatches', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}/batches`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the batches for a build.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {Array<string>} buildID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchesForBuilds: async (projectID: string, branchID: string, buildID: Array<string>, pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBatchesForBuilds', 'projectID', projectID)
            // verify required parameter 'branchID' is not null or undefined
            assertParamExists('listBatchesForBuilds', 'branchID', branchID)
            // verify required parameter 'buildID' is not null or undefined
            assertParamExists('listBatchesForBuilds', 'buildID', buildID)
            const localVarPath = `/projects/{projectID}/branches/{branchID}/builds/{buildID}/batches`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"branchID"}}`, encodeURIComponent(String(branchID)))
                .replace(`{${"buildID"}}`, encodeURIComponent(String(buildID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the logs associated with a given job
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobLogsForJob: async (projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listJobLogsForJob', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listJobLogsForJob', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listJobLogsForJob', 'jobID', jobID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/logs`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the jobs in the given batch.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs: async (projectID: string, batchID: string, pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listJobs', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listJobs', 'batchID', batchID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metrics data associated with a given job ID
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForJob: async (projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listMetricsDataForJob', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsDataForJob', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsDataForJob', 'jobID', jobID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metricsData`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metrics data associated with given metric ID(s)
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForMetricIDs: async (projectID: string, batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listMetricsDataForMetricIDs', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsDataForMetricIDs', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsDataForMetricIDs', 'jobID', jobID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('listMetricsDataForMetricIDs', 'metricID', metricID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics/{metricID}/metricsData`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the metrics data associated with given metrics data IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForMetricsDataIDs: async (projectID: string, batchID: string, jobID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listMetricsDataForMetricsDataIDs', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsDataForMetricsDataIDs', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsDataForMetricsDataIDs', 'jobID', jobID)
            // verify required parameter 'metricsDataID' is not null or undefined
            assertParamExists('listMetricsDataForMetricsDataIDs', 'metricsDataID', metricsDataID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metricsData/{metricsDataID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"metricsDataID"}}`, encodeURIComponent(String(metricsDataID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the metrics for a given job. Does not return associated data.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsForJob: async (projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listMetricsForJob', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsForJob', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsForJob', 'jobID', jobID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the metrics associated with given metric IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsForMetricIDs: async (projectID: string, batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listMetricsForMetricIDs', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsForMetricIDs', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsForMetricIDs', 'jobID', jobID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('listMetricsForMetricIDs', 'metricID', metricID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics/{metricID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a batch\'s metrics status.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatchMetricsStatus: async (projectID: string, batchID: string, body?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('updateBatchMetricsStatus', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('updateBatchMetricsStatus', 'batchID', batchID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metricsStatus`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a job\'s metrics status.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobMetricsStatus: async (projectID: string, batchID: string, jobID: string, body?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('updateJobMetricsStatus', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('updateJobMetricsStatus', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('updateJobMetricsStatus', 'jobID', jobID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metricsStatus`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatchesApi - functional programming interface
 * @export
 */
export const BatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BatchesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds batch metrics data (IDs) to a given batch metric
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBatchMetricsDataToBatchMetric(projectID: string, batchID: string, metricID: string, requestBody?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchMetricsDataToBatchMetric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBatchMetricsDataToBatchMetric(projectID, batchID, metricID, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds metrics data (IDs) to a given metric
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMetricsDataToMetric(projectID: string, batchID: string, jobID: string, metricID: string, requestBody?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricDataToMetric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMetricsDataToMetric(projectID, batchID, jobID, metricID, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancels a batch.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelBatch(projectID: string, batchID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelBatch(projectID, batchID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a batch.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {BatchInput} [batchInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatch(projectID: string, batchInput?: BatchInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatch(projectID, batchInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a log.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {BatchLog} [batchLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatchLog(projectID: string, batchID: string, batchLog?: BatchLog, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatchLog(projectID, batchID, batchLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a batch metric. ID and location should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {BatchMetric} [batchMetric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatchMetric(projectID: string, batchID: string, batchMetric?: BatchMetric, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchMetric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatchMetric(projectID, batchID, batchMetric, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new metrics data associated with a batch
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {BatchMetricsData} [batchMetricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatchMetricsData(projectID: string, batchID: string, batchMetricsData?: BatchMetricsData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchMetricsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatchMetricsData(projectID, batchID, batchMetricsData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a log.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {JobLog} [jobLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobLog(projectID: string, batchID: string, jobID: string, jobLog?: JobLog, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobLog(projectID, batchID, jobID, jobLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a metric. ID and location should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {JobMetric} [jobMetric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMetric(projectID: string, batchID: string, jobID: string, jobMetric?: JobMetric, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobMetric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMetric(projectID, batchID, jobID, jobMetric, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates new metrics data associated with a job
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {JobMetricsData} [jobMetricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMetricsData(projectID: string, batchID: string, jobID: string, jobMetricsData?: JobMetricsData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobMetricsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMetricsData(projectID, batchID, jobID, jobMetricsData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a log.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBatchLog(projectID: string, batchID: string, logID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBatchLog(projectID, batchID, logID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a log.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobLog(projectID: string, batchID: string, jobID: string, logID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobLog(projectID, batchID, jobID, logID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a batch.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatch(projectID: string, batchID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatch(projectID, batchID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an individual log file
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchLog(projectID: string, batchID: string, logID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchLog(projectID, batchID, logID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the given job.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJob(projectID: string, batchID: string, jobID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJob(projectID, batchID, jobID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an individual log file
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobLog(projectID: string, batchID: string, jobID: string, logID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobLog(projectID, batchID, jobID, logID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the logs associated with a given batch
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchLogsForBatch(projectID: string, batchID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatchLogsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchLogsForBatch(projectID, batchID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the (batch) metrics for a given batch. Does not return associated data.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchMetrics(projectID: string, batchID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatchMetricsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchMetrics(projectID, batchID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the metrics data associated with a given batch ID
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchMetricsData(projectID: string, batchID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatchMetricsDataOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchMetricsData(projectID, batchID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the batch metrics data associated with given batch metric ID(s)
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchMetricsDataForBatchMetricIDs(projectID: string, batchID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatchMetricsDataForBatchMetricIDsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchMetricsDataForBatchMetricIDs(projectID, batchID, metricID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the batch metrics data associated with given batch metrics data IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchMetricsDataForBatchMetricsDataIDs(projectID: string, batchID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatchMetricsDataOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchMetricsDataForBatchMetricsDataIDs(projectID, batchID, metricsDataID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the batch metrics associated with given batch metric IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchMetricsForBatchMetricIDs(projectID: string, batchID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatchMetricsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchMetricsForBatchMetricIDs(projectID, batchID, metricID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the batches.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatches(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatchesOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatches(projectID, pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the batches for a build.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {Array<string>} buildID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchesForBuilds(projectID: string, branchID: string, buildID: Array<string>, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatchesOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchesForBuilds(projectID, branchID, buildID, pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the logs associated with a given job
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobLogsForJob(projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListJobLogsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobLogsForJob(projectID, batchID, jobID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the jobs in the given batch.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobs(projectID: string, batchID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListJobsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobs(projectID, batchID, pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the metrics data associated with a given job ID
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsDataForJob(projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListJobMetricsDataOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsDataForJob(projectID, batchID, jobID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the metrics data associated with given metric ID(s)
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsDataForMetricIDs(projectID: string, batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMetricsDataAndMetricIDOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsDataForMetricIDs(projectID, batchID, jobID, metricID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the metrics data associated with given metrics data IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsDataForMetricsDataIDs(projectID: string, batchID: string, jobID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListJobMetricsDataOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsDataForMetricsDataIDs(projectID, batchID, jobID, metricsDataID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the metrics for a given job. Does not return associated data.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsForJob(projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListJobMetricsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsForJob(projectID, batchID, jobID, pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the metrics associated with given metric IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsForMetricIDs(projectID: string, batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListJobMetricsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsForMetricIDs(projectID, batchID, jobID, metricID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a batch\'s metrics status.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBatchMetricsStatus(projectID: string, batchID: string, body?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBatchMetricsStatus(projectID, batchID, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a job\'s metrics status.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateJobMetricsStatus(projectID: string, batchID: string, jobID: string, body?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateJobMetricsStatus(projectID, batchID, jobID, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BatchesApi - factory interface
 * @export
 */
export const BatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BatchesApiFp(configuration)
    return {
        /**
         * Adds batch metrics data (IDs) to a given batch metric
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBatchMetricsDataToBatchMetric(projectID: string, batchID: string, metricID: string, requestBody?: Array<string>, options?: any): AxiosPromise<BatchMetricsDataToBatchMetric> {
            return localVarFp.addBatchMetricsDataToBatchMetric(projectID, batchID, metricID, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds metrics data (IDs) to a given metric
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetricsDataToMetric(projectID: string, batchID: string, jobID: string, metricID: string, requestBody?: Array<string>, options?: any): AxiosPromise<MetricDataToMetric> {
            return localVarFp.addMetricsDataToMetric(projectID, batchID, jobID, metricID, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels a batch.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelBatch(projectID: string, batchID: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelBatch(projectID, batchID, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a batch.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {BatchInput} [batchInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch(projectID: string, batchInput?: BatchInput, options?: any): AxiosPromise<Batch> {
            return localVarFp.createBatch(projectID, batchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a log.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {BatchLog} [batchLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchLog(projectID: string, batchID: string, batchLog?: BatchLog, options?: any): AxiosPromise<BatchLog> {
            return localVarFp.createBatchLog(projectID, batchID, batchLog, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a batch metric. ID and location should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {BatchMetric} [batchMetric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchMetric(projectID: string, batchID: string, batchMetric?: BatchMetric, options?: any): AxiosPromise<BatchMetric> {
            return localVarFp.createBatchMetric(projectID, batchID, batchMetric, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new metrics data associated with a batch
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {BatchMetricsData} [batchMetricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchMetricsData(projectID: string, batchID: string, batchMetricsData?: BatchMetricsData, options?: any): AxiosPromise<BatchMetricsData> {
            return localVarFp.createBatchMetricsData(projectID, batchID, batchMetricsData, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a log.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {JobLog} [jobLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobLog(projectID: string, batchID: string, jobID: string, jobLog?: JobLog, options?: any): AxiosPromise<JobLog> {
            return localVarFp.createJobLog(projectID, batchID, jobID, jobLog, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a metric. ID and location should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {JobMetric} [jobMetric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetric(projectID: string, batchID: string, jobID: string, jobMetric?: JobMetric, options?: any): AxiosPromise<JobMetric> {
            return localVarFp.createMetric(projectID, batchID, jobID, jobMetric, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates new metrics data associated with a job
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {JobMetricsData} [jobMetricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricsData(projectID: string, batchID: string, jobID: string, jobMetricsData?: JobMetricsData, options?: any): AxiosPromise<JobMetricsData> {
            return localVarFp.createMetricsData(projectID, batchID, jobID, jobMetricsData, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a log.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBatchLog(projectID: string, batchID: string, logID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBatchLog(projectID, batchID, logID, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a log.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobLog(projectID: string, batchID: string, jobID: string, logID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteJobLog(projectID, batchID, jobID, logID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a batch.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatch(projectID: string, batchID: string, options?: any): AxiosPromise<Batch> {
            return localVarFp.getBatch(projectID, batchID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an individual log file
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchLog(projectID: string, batchID: string, logID: string, options?: any): AxiosPromise<BatchLog> {
            return localVarFp.getBatchLog(projectID, batchID, logID, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the given job.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(projectID: string, batchID: string, jobID: string, options?: any): AxiosPromise<Job> {
            return localVarFp.getJob(projectID, batchID, jobID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an individual log file
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobLog(projectID: string, batchID: string, jobID: string, logID: string, options?: any): AxiosPromise<JobLog> {
            return localVarFp.getJobLog(projectID, batchID, jobID, logID, options).then((request) => request(axios, basePath));
        },
        /**
         * List the logs associated with a given batch
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchLogsForBatch(projectID: string, batchID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListBatchLogsOutput> {
            return localVarFp.listBatchLogsForBatch(projectID, batchID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the (batch) metrics for a given batch. Does not return associated data.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetrics(projectID: string, batchID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListBatchMetricsOutput> {
            return localVarFp.listBatchMetrics(projectID, batchID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the metrics data associated with a given batch ID
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetricsData(projectID: string, batchID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListBatchMetricsDataOutput> {
            return localVarFp.listBatchMetricsData(projectID, batchID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the batch metrics data associated with given batch metric ID(s)
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetricsDataForBatchMetricIDs(projectID: string, batchID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListBatchMetricsDataForBatchMetricIDsOutput> {
            return localVarFp.listBatchMetricsDataForBatchMetricIDs(projectID, batchID, metricID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the batch metrics data associated with given batch metrics data IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetricsDataForBatchMetricsDataIDs(projectID: string, batchID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListBatchMetricsDataOutput> {
            return localVarFp.listBatchMetricsDataForBatchMetricsDataIDs(projectID, batchID, metricsDataID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the batch metrics associated with given batch metric IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetricsForBatchMetricIDs(projectID: string, batchID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListBatchMetricsOutput> {
            return localVarFp.listBatchMetricsForBatchMetricIDs(projectID, batchID, metricID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * List the batches.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatches(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListBatchesOutput> {
            return localVarFp.listBatches(projectID, pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the batches for a build.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {Array<string>} buildID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchesForBuilds(projectID: string, branchID: string, buildID: Array<string>, pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListBatchesOutput> {
            return localVarFp.listBatchesForBuilds(projectID, branchID, buildID, pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * List the logs associated with a given job
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobLogsForJob(projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListJobLogsOutput> {
            return localVarFp.listJobLogsForJob(projectID, batchID, jobID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * List the jobs in the given batch.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(projectID: string, batchID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListJobsOutput> {
            return localVarFp.listJobs(projectID, batchID, pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the metrics data associated with a given job ID
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForJob(projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListJobMetricsDataOutput> {
            return localVarFp.listMetricsDataForJob(projectID, batchID, jobID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the metrics data associated with given metric ID(s)
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForMetricIDs(projectID: string, batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListMetricsDataAndMetricIDOutput> {
            return localVarFp.listMetricsDataForMetricIDs(projectID, batchID, jobID, metricID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the metrics data associated with given metrics data IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForMetricsDataIDs(projectID: string, batchID: string, jobID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListJobMetricsDataOutput> {
            return localVarFp.listMetricsDataForMetricsDataIDs(projectID, batchID, jobID, metricsDataID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the metrics for a given job. Does not return associated data.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsForJob(projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListJobMetricsOutput> {
            return localVarFp.listMetricsForJob(projectID, batchID, jobID, pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the metrics associated with given metric IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsForMetricIDs(projectID: string, batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListJobMetricsOutput> {
            return localVarFp.listMetricsForMetricIDs(projectID, batchID, jobID, metricID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a batch\'s metrics status.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatchMetricsStatus(projectID: string, batchID: string, body?: string, options?: any): AxiosPromise<Batch> {
            return localVarFp.updateBatchMetricsStatus(projectID, batchID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a job\'s metrics status.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobMetricsStatus(projectID: string, batchID: string, jobID: string, body?: string, options?: any): AxiosPromise<Job> {
            return localVarFp.updateJobMetricsStatus(projectID, batchID, jobID, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BatchesApi - object-oriented interface
 * @export
 * @class BatchesApi
 * @extends {BaseAPI}
 */
export class BatchesApi extends BaseAPI {
    /**
     * Adds batch metrics data (IDs) to a given batch metric
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} metricID 
     * @param {Array<string>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public addBatchMetricsDataToBatchMetric(projectID: string, batchID: string, metricID: string, requestBody?: Array<string>, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).addBatchMetricsDataToBatchMetric(projectID, batchID, metricID, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds metrics data (IDs) to a given metric
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {string} metricID 
     * @param {Array<string>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public addMetricsDataToMetric(projectID: string, batchID: string, jobID: string, metricID: string, requestBody?: Array<string>, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).addMetricsDataToMetric(projectID, batchID, jobID, metricID, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels a batch.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public cancelBatch(projectID: string, batchID: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).cancelBatch(projectID, batchID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a batch.  ID should be omitted and will be returned in the response.
     * @param {string} projectID 
     * @param {BatchInput} [batchInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createBatch(projectID: string, batchInput?: BatchInput, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createBatch(projectID, batchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a log.  ID should be omitted and will be returned in the response.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {BatchLog} [batchLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createBatchLog(projectID: string, batchID: string, batchLog?: BatchLog, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createBatchLog(projectID, batchID, batchLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a batch metric. ID and location should be omitted and will be returned in the response.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {BatchMetric} [batchMetric] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createBatchMetric(projectID: string, batchID: string, batchMetric?: BatchMetric, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createBatchMetric(projectID, batchID, batchMetric, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new metrics data associated with a batch
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {BatchMetricsData} [batchMetricsData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createBatchMetricsData(projectID: string, batchID: string, batchMetricsData?: BatchMetricsData, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createBatchMetricsData(projectID, batchID, batchMetricsData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a log.  ID should be omitted and will be returned in the response.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {JobLog} [jobLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createJobLog(projectID: string, batchID: string, jobID: string, jobLog?: JobLog, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createJobLog(projectID, batchID, jobID, jobLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a metric. ID and location should be omitted and will be returned in the response.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {JobMetric} [jobMetric] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createMetric(projectID: string, batchID: string, jobID: string, jobMetric?: JobMetric, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createMetric(projectID, batchID, jobID, jobMetric, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates new metrics data associated with a job
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {JobMetricsData} [jobMetricsData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createMetricsData(projectID: string, batchID: string, jobID: string, jobMetricsData?: JobMetricsData, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createMetricsData(projectID, batchID, jobID, jobMetricsData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a log.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} logID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public deleteBatchLog(projectID: string, batchID: string, logID: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).deleteBatchLog(projectID, batchID, logID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a log.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {string} logID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public deleteJobLog(projectID: string, batchID: string, jobID: string, logID: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).deleteJobLog(projectID, batchID, jobID, logID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a batch.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public getBatch(projectID: string, batchID: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).getBatch(projectID, batchID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an individual log file
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} logID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public getBatchLog(projectID: string, batchID: string, logID: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).getBatchLog(projectID, batchID, logID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the given job.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public getJob(projectID: string, batchID: string, jobID: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).getJob(projectID, batchID, jobID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an individual log file
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {string} logID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public getJobLog(projectID: string, batchID: string, jobID: string, logID: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).getJobLog(projectID, batchID, jobID, logID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the logs associated with a given batch
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listBatchLogsForBatch(projectID: string, batchID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listBatchLogsForBatch(projectID, batchID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the (batch) metrics for a given batch. Does not return associated data.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listBatchMetrics(projectID: string, batchID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listBatchMetrics(projectID, batchID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the metrics data associated with a given batch ID
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listBatchMetricsData(projectID: string, batchID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listBatchMetricsData(projectID, batchID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the batch metrics data associated with given batch metric ID(s)
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {Array<string>} metricID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listBatchMetricsDataForBatchMetricIDs(projectID: string, batchID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listBatchMetricsDataForBatchMetricIDs(projectID, batchID, metricID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the batch metrics data associated with given batch metrics data IDs
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {Array<string>} metricsDataID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listBatchMetricsDataForBatchMetricsDataIDs(projectID: string, batchID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listBatchMetricsDataForBatchMetricsDataIDs(projectID, batchID, metricsDataID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the batch metrics associated with given batch metric IDs
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {Array<string>} metricID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listBatchMetricsForBatchMetricIDs(projectID: string, batchID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listBatchMetricsForBatchMetricIDs(projectID, batchID, metricID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the batches.
     * @param {string} projectID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listBatches(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listBatches(projectID, pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the batches for a build.
     * @param {string} projectID 
     * @param {string} branchID 
     * @param {Array<string>} buildID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listBatchesForBuilds(projectID: string, branchID: string, buildID: Array<string>, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listBatchesForBuilds(projectID, branchID, buildID, pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the logs associated with a given job
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listJobLogsForJob(projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listJobLogsForJob(projectID, batchID, jobID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the jobs in the given batch.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listJobs(projectID: string, batchID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listJobs(projectID, batchID, pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the metrics data associated with a given job ID
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listMetricsDataForJob(projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listMetricsDataForJob(projectID, batchID, jobID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the metrics data associated with given metric ID(s)
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {Array<string>} metricID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listMetricsDataForMetricIDs(projectID: string, batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listMetricsDataForMetricIDs(projectID, batchID, jobID, metricID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the metrics data associated with given metrics data IDs
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {Array<string>} metricsDataID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listMetricsDataForMetricsDataIDs(projectID: string, batchID: string, jobID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listMetricsDataForMetricsDataIDs(projectID, batchID, jobID, metricsDataID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the metrics for a given job. Does not return associated data.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listMetricsForJob(projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listMetricsForJob(projectID, batchID, jobID, pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the metrics associated with given metric IDs
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {Array<string>} metricID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listMetricsForMetricIDs(projectID: string, batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listMetricsForMetricIDs(projectID, batchID, jobID, metricID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a batch\'s metrics status.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public updateBatchMetricsStatus(projectID: string, batchID: string, body?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).updateBatchMetricsStatus(projectID, batchID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a job\'s metrics status.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public updateJobMetricsStatus(projectID: string, batchID: string, jobID: string, body?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).updateJobMetricsStatus(projectID, batchID, jobID, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BuildsApi - axios parameter creator
 * @export
 */
export const BuildsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a build.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {Build} [build] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuildForBranch: async (projectID: string, branchID: string, build?: Build, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createBuildForBranch', 'projectID', projectID)
            // verify required parameter 'branchID' is not null or undefined
            assertParamExists('createBuildForBranch', 'branchID', branchID)
            const localVarPath = `/projects/{projectID}/branches/{branchID}/builds`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"branchID"}}`, encodeURIComponent(String(branchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(build, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a build.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {Build} [build] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuildForSystem: async (projectID: string, systemID: string, build?: Build, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createBuildForSystem', 'projectID', projectID)
            // verify required parameter 'systemID' is not null or undefined
            assertParamExists('createBuildForSystem', 'systemID', systemID)
            const localVarPath = `/projects/{projectID}/systems/{systemID}/builds`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"systemID"}}`, encodeURIComponent(String(systemID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(build, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a build.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuildForBranch: async (projectID: string, branchID: string, buildID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('deleteBuildForBranch', 'projectID', projectID)
            // verify required parameter 'branchID' is not null or undefined
            assertParamExists('deleteBuildForBranch', 'branchID', branchID)
            // verify required parameter 'buildID' is not null or undefined
            assertParamExists('deleteBuildForBranch', 'buildID', buildID)
            const localVarPath = `/projects/{projectID}/branches/{branchID}/builds/{buildID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"branchID"}}`, encodeURIComponent(String(branchID)))
                .replace(`{${"buildID"}}`, encodeURIComponent(String(buildID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific build.
         * @param {string} projectID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuild: async (projectID: string, buildID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getBuild', 'projectID', projectID)
            // verify required parameter 'buildID' is not null or undefined
            assertParamExists('getBuild', 'buildID', buildID)
            const localVarPath = `/projects/{projectID}/builds/{buildID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"buildID"}}`, encodeURIComponent(String(buildID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific build for a branch.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuildForBranch: async (projectID: string, branchID: string, buildID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getBuildForBranch', 'projectID', projectID)
            // verify required parameter 'branchID' is not null or undefined
            assertParamExists('getBuildForBranch', 'branchID', branchID)
            // verify required parameter 'buildID' is not null or undefined
            assertParamExists('getBuildForBranch', 'buildID', buildID)
            const localVarPath = `/projects/{projectID}/branches/{branchID}/builds/{buildID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"branchID"}}`, encodeURIComponent(String(branchID)))
                .replace(`{${"buildID"}}`, encodeURIComponent(String(buildID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific build for a system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuildForSystem: async (projectID: string, systemID: string, buildID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getBuildForSystem', 'projectID', projectID)
            // verify required parameter 'systemID' is not null or undefined
            assertParamExists('getBuildForSystem', 'systemID', systemID)
            // verify required parameter 'buildID' is not null or undefined
            assertParamExists('getBuildForSystem', 'buildID', buildID)
            const localVarPath = `/projects/{projectID}/systems/{systemID}/builds/{buildID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"systemID"}}`, encodeURIComponent(String(systemID)))
                .replace(`{${"buildID"}}`, encodeURIComponent(String(buildID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of builds.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilds: async (projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBuilds', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}/builds`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of builds for a branch.
         * @param {string} projectID 
         * @param {Array<string>} branchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuildsForBranches: async (projectID: string, branchID: Array<string>, pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBuildsForBranches', 'projectID', projectID)
            // verify required parameter 'branchID' is not null or undefined
            assertParamExists('listBuildsForBranches', 'branchID', branchID)
            const localVarPath = `/projects/{projectID}/branches/{branchID}/builds`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"branchID"}}`, encodeURIComponent(String(branchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of builds for a system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuildsForSystem: async (projectID: string, systemID: string, pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBuildsForSystem', 'projectID', projectID)
            // verify required parameter 'systemID' is not null or undefined
            assertParamExists('listBuildsForSystem', 'systemID', systemID)
            const localVarPath = `/projects/{projectID}/systems/{systemID}/builds`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"systemID"}}`, encodeURIComponent(String(systemID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BuildsApi - functional programming interface
 * @export
 */
export const BuildsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BuildsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a build.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {Build} [build] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBuildForBranch(projectID: string, branchID: string, build?: Build, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBuildForBranch(projectID, branchID, build, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a build.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {Build} [build] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBuildForSystem(projectID: string, systemID: string, build?: Build, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBuildForSystem(projectID, systemID, build, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a build.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBuildForBranch(projectID: string, branchID: string, buildID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBuildForBranch(projectID, branchID, buildID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific build.
         * @param {string} projectID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBuild(projectID: string, buildID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBuild(projectID, buildID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific build for a branch.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBuildForBranch(projectID: string, branchID: string, buildID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildForBranch(projectID, branchID, buildID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific build for a system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBuildForSystem(projectID: string, systemID: string, buildID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildForSystem(projectID, systemID, buildID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of builds.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBuilds(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBuildsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBuilds(projectID, pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of builds for a branch.
         * @param {string} projectID 
         * @param {Array<string>} branchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBuildsForBranches(projectID: string, branchID: Array<string>, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBuildsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBuildsForBranches(projectID, branchID, pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of builds for a system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBuildsForSystem(projectID: string, systemID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBuildsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBuildsForSystem(projectID, systemID, pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BuildsApi - factory interface
 * @export
 */
export const BuildsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BuildsApiFp(configuration)
    return {
        /**
         * Adds a build.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {Build} [build] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuildForBranch(projectID: string, branchID: string, build?: Build, options?: any): AxiosPromise<Build> {
            return localVarFp.createBuildForBranch(projectID, branchID, build, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a build.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {Build} [build] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuildForSystem(projectID: string, systemID: string, build?: Build, options?: any): AxiosPromise<Build> {
            return localVarFp.createBuildForSystem(projectID, systemID, build, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a build.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuildForBranch(projectID: string, branchID: string, buildID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBuildForBranch(projectID, branchID, buildID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific build.
         * @param {string} projectID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuild(projectID: string, buildID: string, options?: any): AxiosPromise<Build> {
            return localVarFp.getBuild(projectID, buildID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific build for a branch.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuildForBranch(projectID: string, branchID: string, buildID: string, options?: any): AxiosPromise<Build> {
            return localVarFp.getBuildForBranch(projectID, branchID, buildID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific build for a system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuildForSystem(projectID: string, systemID: string, buildID: string, options?: any): AxiosPromise<Build> {
            return localVarFp.getBuildForSystem(projectID, systemID, buildID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of builds.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilds(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListBuildsOutput> {
            return localVarFp.listBuilds(projectID, pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of builds for a branch.
         * @param {string} projectID 
         * @param {Array<string>} branchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuildsForBranches(projectID: string, branchID: Array<string>, pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListBuildsOutput> {
            return localVarFp.listBuildsForBranches(projectID, branchID, pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of builds for a system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuildsForSystem(projectID: string, systemID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListBuildsOutput> {
            return localVarFp.listBuildsForSystem(projectID, systemID, pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BuildsApi - object-oriented interface
 * @export
 * @class BuildsApi
 * @extends {BaseAPI}
 */
export class BuildsApi extends BaseAPI {
    /**
     * Adds a build.  ID should be omitted and will be returned in the response.
     * @param {string} projectID 
     * @param {string} branchID 
     * @param {Build} [build] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildsApi
     */
    public createBuildForBranch(projectID: string, branchID: string, build?: Build, options?: AxiosRequestConfig) {
        return BuildsApiFp(this.configuration).createBuildForBranch(projectID, branchID, build, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a build.  ID should be omitted and will be returned in the response.
     * @param {string} projectID 
     * @param {string} systemID 
     * @param {Build} [build] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildsApi
     */
    public createBuildForSystem(projectID: string, systemID: string, build?: Build, options?: AxiosRequestConfig) {
        return BuildsApiFp(this.configuration).createBuildForSystem(projectID, systemID, build, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a build.
     * @param {string} projectID 
     * @param {string} branchID 
     * @param {string} buildID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildsApi
     */
    public deleteBuildForBranch(projectID: string, branchID: string, buildID: string, options?: AxiosRequestConfig) {
        return BuildsApiFp(this.configuration).deleteBuildForBranch(projectID, branchID, buildID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific build.
     * @param {string} projectID 
     * @param {string} buildID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildsApi
     */
    public getBuild(projectID: string, buildID: string, options?: AxiosRequestConfig) {
        return BuildsApiFp(this.configuration).getBuild(projectID, buildID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific build for a branch.
     * @param {string} projectID 
     * @param {string} branchID 
     * @param {string} buildID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildsApi
     */
    public getBuildForBranch(projectID: string, branchID: string, buildID: string, options?: AxiosRequestConfig) {
        return BuildsApiFp(this.configuration).getBuildForBranch(projectID, branchID, buildID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific build for a system.
     * @param {string} projectID 
     * @param {string} systemID 
     * @param {string} buildID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildsApi
     */
    public getBuildForSystem(projectID: string, systemID: string, buildID: string, options?: AxiosRequestConfig) {
        return BuildsApiFp(this.configuration).getBuildForSystem(projectID, systemID, buildID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of builds.
     * @param {string} projectID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildsApi
     */
    public listBuilds(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return BuildsApiFp(this.configuration).listBuilds(projectID, pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of builds for a branch.
     * @param {string} projectID 
     * @param {Array<string>} branchID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildsApi
     */
    public listBuildsForBranches(projectID: string, branchID: Array<string>, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return BuildsApiFp(this.configuration).listBuildsForBranches(projectID, branchID, pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of builds for a system.
     * @param {string} projectID 
     * @param {string} systemID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildsApi
     */
    public listBuildsForSystem(projectID: string, systemID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return BuildsApiFp(this.configuration).listBuildsForSystem(projectID, systemID, pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExperienceTagsApi - axios parameter creator
 * @export
 */
export const ExperienceTagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds the given experience tag to the given experience.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExperienceTagToExperience: async (projectID: string, experienceTagID: string, experienceID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('addExperienceTagToExperience', 'projectID', projectID)
            // verify required parameter 'experienceTagID' is not null or undefined
            assertParamExists('addExperienceTagToExperience', 'experienceTagID', experienceTagID)
            // verify required parameter 'experienceID' is not null or undefined
            assertParamExists('addExperienceTagToExperience', 'experienceID', experienceID)
            const localVarPath = `/projects/{projectID}/experienceTags/{experienceTagID}/experiences/{experienceID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"experienceTagID"}}`, encodeURIComponent(String(experienceTagID)))
                .replace(`{${"experienceID"}}`, encodeURIComponent(String(experienceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds an experience tag.  ID should be omitted and will be included in the response.
         * @param {string} projectID 
         * @param {ExperienceTag} [experienceTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperienceTag: async (projectID: string, experienceTag?: ExperienceTag, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createExperienceTag', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}/experienceTags`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(experienceTag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an experience tag.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperienceTag: async (projectID: string, experienceTagID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('deleteExperienceTag', 'projectID', projectID)
            // verify required parameter 'experienceTagID' is not null or undefined
            assertParamExists('deleteExperienceTag', 'experienceTagID', experienceTagID)
            const localVarPath = `/projects/{projectID}/experienceTags/{experienceTagID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"experienceTagID"}}`, encodeURIComponent(String(experienceTagID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific experience tag.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperienceTag: async (projectID: string, experienceTagID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getExperienceTag', 'projectID', projectID)
            // verify required parameter 'experienceTagID' is not null or undefined
            assertParamExists('getExperienceTag', 'experienceTagID', experienceTagID)
            const localVarPath = `/projects/{projectID}/experienceTags/{experienceTagID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"experienceTagID"}}`, encodeURIComponent(String(experienceTagID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all experience tags.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperienceTags: async (projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listExperienceTags', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}/experienceTags`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all experiences with the given experience tag.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiencesWithExperienceTag: async (projectID: string, experienceTagID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listExperiencesWithExperienceTag', 'projectID', projectID)
            // verify required parameter 'experienceTagID' is not null or undefined
            assertParamExists('listExperiencesWithExperienceTag', 'experienceTagID', experienceTagID)
            const localVarPath = `/projects/{projectID}/experienceTags/{experienceTagID}/experiences`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"experienceTagID"}}`, encodeURIComponent(String(experienceTagID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the given experience tag from the given experience.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeExperienceTagFromExperience: async (projectID: string, experienceTagID: string, experienceID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('removeExperienceTagFromExperience', 'projectID', projectID)
            // verify required parameter 'experienceTagID' is not null or undefined
            assertParamExists('removeExperienceTagFromExperience', 'experienceTagID', experienceTagID)
            // verify required parameter 'experienceID' is not null or undefined
            assertParamExists('removeExperienceTagFromExperience', 'experienceID', experienceID)
            const localVarPath = `/projects/{projectID}/experienceTags/{experienceTagID}/experiences/{experienceID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"experienceTagID"}}`, encodeURIComponent(String(experienceTagID)))
                .replace(`{${"experienceID"}}`, encodeURIComponent(String(experienceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the experience tag.  Experience membership cannot be changed with this method.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {ExperienceTagInput} [experienceTagInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperienceTag: async (projectID: string, experienceTagID: string, experienceTagInput?: ExperienceTagInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('updateExperienceTag', 'projectID', projectID)
            // verify required parameter 'experienceTagID' is not null or undefined
            assertParamExists('updateExperienceTag', 'experienceTagID', experienceTagID)
            const localVarPath = `/projects/{projectID}/experienceTags/{experienceTagID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"experienceTagID"}}`, encodeURIComponent(String(experienceTagID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(experienceTagInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExperienceTagsApi - functional programming interface
 * @export
 */
export const ExperienceTagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExperienceTagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds the given experience tag to the given experience.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addExperienceTagToExperience(projectID: string, experienceTagID: string, experienceID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addExperienceTagToExperience(projectID, experienceTagID, experienceID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds an experience tag.  ID should be omitted and will be included in the response.
         * @param {string} projectID 
         * @param {ExperienceTag} [experienceTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExperienceTag(projectID: string, experienceTag?: ExperienceTag, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperienceTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExperienceTag(projectID, experienceTag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an experience tag.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExperienceTag(projectID: string, experienceTagID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExperienceTag(projectID, experienceTagID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific experience tag.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperienceTag(projectID: string, experienceTagID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperienceTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperienceTag(projectID, experienceTagID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all experience tags.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExperienceTags(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListExperienceTagsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExperienceTags(projectID, pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all experiences with the given experience tag.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExperiencesWithExperienceTag(projectID: string, experienceTagID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListExperiencesOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExperiencesWithExperienceTag(projectID, experienceTagID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the given experience tag from the given experience.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeExperienceTagFromExperience(projectID: string, experienceTagID: string, experienceID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeExperienceTagFromExperience(projectID, experienceTagID, experienceID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the experience tag.  Experience membership cannot be changed with this method.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {ExperienceTagInput} [experienceTagInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExperienceTag(projectID: string, experienceTagID: string, experienceTagInput?: ExperienceTagInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperienceTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExperienceTag(projectID, experienceTagID, experienceTagInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExperienceTagsApi - factory interface
 * @export
 */
export const ExperienceTagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExperienceTagsApiFp(configuration)
    return {
        /**
         * Adds the given experience tag to the given experience.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExperienceTagToExperience(projectID: string, experienceTagID: string, experienceID: string, options?: any): AxiosPromise<void> {
            return localVarFp.addExperienceTagToExperience(projectID, experienceTagID, experienceID, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds an experience tag.  ID should be omitted and will be included in the response.
         * @param {string} projectID 
         * @param {ExperienceTag} [experienceTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperienceTag(projectID: string, experienceTag?: ExperienceTag, options?: any): AxiosPromise<ExperienceTag> {
            return localVarFp.createExperienceTag(projectID, experienceTag, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an experience tag.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperienceTag(projectID: string, experienceTagID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteExperienceTag(projectID, experienceTagID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific experience tag.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperienceTag(projectID: string, experienceTagID: string, options?: any): AxiosPromise<ExperienceTag> {
            return localVarFp.getExperienceTag(projectID, experienceTagID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all experience tags.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperienceTags(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListExperienceTagsOutput> {
            return localVarFp.listExperienceTags(projectID, pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all experiences with the given experience tag.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiencesWithExperienceTag(projectID: string, experienceTagID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListExperiencesOutput> {
            return localVarFp.listExperiencesWithExperienceTag(projectID, experienceTagID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the given experience tag from the given experience.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeExperienceTagFromExperience(projectID: string, experienceTagID: string, experienceID: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeExperienceTagFromExperience(projectID, experienceTagID, experienceID, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the experience tag.  Experience membership cannot be changed with this method.
         * @param {string} projectID 
         * @param {string} experienceTagID 
         * @param {ExperienceTagInput} [experienceTagInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperienceTag(projectID: string, experienceTagID: string, experienceTagInput?: ExperienceTagInput, options?: any): AxiosPromise<ExperienceTag> {
            return localVarFp.updateExperienceTag(projectID, experienceTagID, experienceTagInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExperienceTagsApi - object-oriented interface
 * @export
 * @class ExperienceTagsApi
 * @extends {BaseAPI}
 */
export class ExperienceTagsApi extends BaseAPI {
    /**
     * Adds the given experience tag to the given experience.
     * @param {string} projectID 
     * @param {string} experienceTagID 
     * @param {string} experienceID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTagsApi
     */
    public addExperienceTagToExperience(projectID: string, experienceTagID: string, experienceID: string, options?: AxiosRequestConfig) {
        return ExperienceTagsApiFp(this.configuration).addExperienceTagToExperience(projectID, experienceTagID, experienceID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds an experience tag.  ID should be omitted and will be included in the response.
     * @param {string} projectID 
     * @param {ExperienceTag} [experienceTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTagsApi
     */
    public createExperienceTag(projectID: string, experienceTag?: ExperienceTag, options?: AxiosRequestConfig) {
        return ExperienceTagsApiFp(this.configuration).createExperienceTag(projectID, experienceTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an experience tag.
     * @param {string} projectID 
     * @param {string} experienceTagID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTagsApi
     */
    public deleteExperienceTag(projectID: string, experienceTagID: string, options?: AxiosRequestConfig) {
        return ExperienceTagsApiFp(this.configuration).deleteExperienceTag(projectID, experienceTagID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific experience tag.
     * @param {string} projectID 
     * @param {string} experienceTagID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTagsApi
     */
    public getExperienceTag(projectID: string, experienceTagID: string, options?: AxiosRequestConfig) {
        return ExperienceTagsApiFp(this.configuration).getExperienceTag(projectID, experienceTagID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all experience tags.
     * @param {string} projectID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTagsApi
     */
    public listExperienceTags(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return ExperienceTagsApiFp(this.configuration).listExperienceTags(projectID, pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all experiences with the given experience tag.
     * @param {string} projectID 
     * @param {string} experienceTagID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTagsApi
     */
    public listExperiencesWithExperienceTag(projectID: string, experienceTagID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return ExperienceTagsApiFp(this.configuration).listExperiencesWithExperienceTag(projectID, experienceTagID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the given experience tag from the given experience.
     * @param {string} projectID 
     * @param {string} experienceTagID 
     * @param {string} experienceID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTagsApi
     */
    public removeExperienceTagFromExperience(projectID: string, experienceTagID: string, experienceID: string, options?: AxiosRequestConfig) {
        return ExperienceTagsApiFp(this.configuration).removeExperienceTagFromExperience(projectID, experienceTagID, experienceID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the experience tag.  Experience membership cannot be changed with this method.
     * @param {string} projectID 
     * @param {string} experienceTagID 
     * @param {ExperienceTagInput} [experienceTagInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTagsApi
     */
    public updateExperienceTag(projectID: string, experienceTagID: string, experienceTagInput?: ExperienceTagInput, options?: AxiosRequestConfig) {
        return ExperienceTagsApiFp(this.configuration).updateExperienceTag(projectID, experienceTagID, experienceTagInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExperiencesApi - axios parameter creator
 * @export
 */
export const ExperiencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds an experience.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {Experience} [experience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperience: async (projectID: string, experience?: Experience, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createExperience', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}/experiences`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(experience, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an experience.
         * @param {string} projectID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperience: async (projectID: string, experienceID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('deleteExperience', 'projectID', projectID)
            // verify required parameter 'experienceID' is not null or undefined
            assertParamExists('deleteExperience', 'experienceID', experienceID)
            const localVarPath = `/projects/{projectID}/experiences/{experienceID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"experienceID"}}`, encodeURIComponent(String(experienceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific experience.
         * @param {string} projectID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperience: async (projectID: string, experienceID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getExperience', 'projectID', projectID)
            // verify required parameter 'experienceID' is not null or undefined
            assertParamExists('getExperience', 'experienceID', experienceID)
            const localVarPath = `/projects/{projectID}/experiences/{experienceID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"experienceID"}}`, encodeURIComponent(String(experienceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the systems for a given experience
         * @param {string} projectID 
         * @param {string} experienceID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemsForExperience: async (projectID: string, experienceID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getSystemsForExperience', 'projectID', projectID)
            // verify required parameter 'experienceID' is not null or undefined
            assertParamExists('getSystemsForExperience', 'experienceID', experienceID)
            const localVarPath = `/projects/{projectID}/experiences/{experienceID}/systems`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"experienceID"}}`, encodeURIComponent(String(experienceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of experience tags associated with a given experience.
         * @param {string} projectID 
         * @param {string} experienceID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperienceTagsForExperience: async (projectID: string, experienceID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listExperienceTagsForExperience', 'projectID', projectID)
            // verify required parameter 'experienceID' is not null or undefined
            assertParamExists('listExperienceTagsForExperience', 'experienceID', experienceID)
            const localVarPath = `/projects/{projectID}/experiences/{experienceID}/experienceTags`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"experienceID"}}`, encodeURIComponent(String(experienceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of experiences.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiences: async (projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listExperiences', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}/experiences`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the experience.
         * @param {string} projectID 
         * @param {string} experienceID 
         * @param {ExperienceInput} [experienceInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperience: async (projectID: string, experienceID: string, experienceInput?: ExperienceInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('updateExperience', 'projectID', projectID)
            // verify required parameter 'experienceID' is not null or undefined
            assertParamExists('updateExperience', 'experienceID', experienceID)
            const localVarPath = `/projects/{projectID}/experiences/{experienceID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"experienceID"}}`, encodeURIComponent(String(experienceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(experienceInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates an experience location can be reached by ReSim.
         * @param {ExperienceLocation} [experienceLocation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateExperienceLocation: async (experienceLocation?: ExperienceLocation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/validateExperienceLocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(experienceLocation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExperiencesApi - functional programming interface
 * @export
 */
export const ExperiencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExperiencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds an experience.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {Experience} [experience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExperience(projectID: string, experience?: Experience, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experience>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExperience(projectID, experience, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an experience.
         * @param {string} projectID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExperience(projectID: string, experienceID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExperience(projectID, experienceID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific experience.
         * @param {string} projectID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperience(projectID: string, experienceID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experience>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperience(projectID, experienceID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the systems for a given experience
         * @param {string} projectID 
         * @param {string} experienceID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemsForExperience(projectID: string, experienceID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSystemsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemsForExperience(projectID, experienceID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of experience tags associated with a given experience.
         * @param {string} projectID 
         * @param {string} experienceID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExperienceTagsForExperience(projectID: string, experienceID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListExperienceTagsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExperienceTagsForExperience(projectID, experienceID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of experiences.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExperiences(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListExperiencesOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExperiences(projectID, pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the experience.
         * @param {string} projectID 
         * @param {string} experienceID 
         * @param {ExperienceInput} [experienceInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExperience(projectID: string, experienceID: string, experienceInput?: ExperienceInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experience>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExperience(projectID, experienceID, experienceInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validates an experience location can be reached by ReSim.
         * @param {ExperienceLocation} [experienceLocation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateExperienceLocation(experienceLocation?: ExperienceLocation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperienceLocationContents>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateExperienceLocation(experienceLocation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExperiencesApi - factory interface
 * @export
 */
export const ExperiencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExperiencesApiFp(configuration)
    return {
        /**
         * Adds an experience.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {Experience} [experience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperience(projectID: string, experience?: Experience, options?: any): AxiosPromise<Experience> {
            return localVarFp.createExperience(projectID, experience, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an experience.
         * @param {string} projectID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperience(projectID: string, experienceID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteExperience(projectID, experienceID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific experience.
         * @param {string} projectID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperience(projectID: string, experienceID: string, options?: any): AxiosPromise<Experience> {
            return localVarFp.getExperience(projectID, experienceID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the systems for a given experience
         * @param {string} projectID 
         * @param {string} experienceID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemsForExperience(projectID: string, experienceID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListSystemsOutput> {
            return localVarFp.getSystemsForExperience(projectID, experienceID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of experience tags associated with a given experience.
         * @param {string} projectID 
         * @param {string} experienceID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperienceTagsForExperience(projectID: string, experienceID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListExperienceTagsOutput> {
            return localVarFp.listExperienceTagsForExperience(projectID, experienceID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of experiences.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiences(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListExperiencesOutput> {
            return localVarFp.listExperiences(projectID, pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the experience.
         * @param {string} projectID 
         * @param {string} experienceID 
         * @param {ExperienceInput} [experienceInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperience(projectID: string, experienceID: string, experienceInput?: ExperienceInput, options?: any): AxiosPromise<Experience> {
            return localVarFp.updateExperience(projectID, experienceID, experienceInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates an experience location can be reached by ReSim.
         * @param {ExperienceLocation} [experienceLocation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateExperienceLocation(experienceLocation?: ExperienceLocation, options?: any): AxiosPromise<ExperienceLocationContents> {
            return localVarFp.validateExperienceLocation(experienceLocation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExperiencesApi - object-oriented interface
 * @export
 * @class ExperiencesApi
 * @extends {BaseAPI}
 */
export class ExperiencesApi extends BaseAPI {
    /**
     * Adds an experience.  ID should be omitted and will be returned in the response.
     * @param {string} projectID 
     * @param {Experience} [experience] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperiencesApi
     */
    public createExperience(projectID: string, experience?: Experience, options?: AxiosRequestConfig) {
        return ExperiencesApiFp(this.configuration).createExperience(projectID, experience, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an experience.
     * @param {string} projectID 
     * @param {string} experienceID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperiencesApi
     */
    public deleteExperience(projectID: string, experienceID: string, options?: AxiosRequestConfig) {
        return ExperiencesApiFp(this.configuration).deleteExperience(projectID, experienceID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific experience.
     * @param {string} projectID 
     * @param {string} experienceID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperiencesApi
     */
    public getExperience(projectID: string, experienceID: string, options?: AxiosRequestConfig) {
        return ExperiencesApiFp(this.configuration).getExperience(projectID, experienceID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the systems for a given experience
     * @param {string} projectID 
     * @param {string} experienceID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperiencesApi
     */
    public getSystemsForExperience(projectID: string, experienceID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return ExperiencesApiFp(this.configuration).getSystemsForExperience(projectID, experienceID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of experience tags associated with a given experience.
     * @param {string} projectID 
     * @param {string} experienceID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperiencesApi
     */
    public listExperienceTagsForExperience(projectID: string, experienceID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return ExperiencesApiFp(this.configuration).listExperienceTagsForExperience(projectID, experienceID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of experiences.
     * @param {string} projectID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperiencesApi
     */
    public listExperiences(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return ExperiencesApiFp(this.configuration).listExperiences(projectID, pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the experience.
     * @param {string} projectID 
     * @param {string} experienceID 
     * @param {ExperienceInput} [experienceInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperiencesApi
     */
    public updateExperience(projectID: string, experienceID: string, experienceInput?: ExperienceInput, options?: AxiosRequestConfig) {
        return ExperiencesApiFp(this.configuration).updateExperience(projectID, experienceID, experienceInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates an experience location can be reached by ReSim.
     * @param {ExperienceLocation} [experienceLocation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperiencesApi
     */
    public validateExperienceLocation(experienceLocation?: ExperienceLocation, options?: AxiosRequestConfig) {
        return ExperiencesApiFp(this.configuration).validateExperienceLocation(experienceLocation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns whether the service is healthy or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns whether the service is healthy or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async health(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.health(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Returns whether the service is healthy or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options?: any): AxiosPromise<void> {
            return localVarFp.health(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * Returns whether the service is healthy or not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public health(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).health(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds batch metrics data (IDs) to a given batch metric
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBatchMetricsDataToBatchMetric: async (projectID: string, batchID: string, metricID: string, requestBody?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('addBatchMetricsDataToBatchMetric', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('addBatchMetricsDataToBatchMetric', 'batchID', batchID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('addBatchMetricsDataToBatchMetric', 'metricID', metricID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metrics/{metricID}/metricsData`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds metrics data (IDs) to a given metric
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetricsDataToMetric: async (projectID: string, batchID: string, jobID: string, metricID: string, requestBody?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('addMetricsDataToMetric', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('addMetricsDataToMetric', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('addMetricsDataToMetric', 'jobID', jobID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('addMetricsDataToMetric', 'metricID', metricID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics/{metricID}/metricsData`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a batch metric. ID and location should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {BatchMetric} [batchMetric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchMetric: async (projectID: string, batchID: string, batchMetric?: BatchMetric, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createBatchMetric', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('createBatchMetric', 'batchID', batchID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metrics`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchMetric, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new metrics data associated with a batch
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {BatchMetricsData} [batchMetricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchMetricsData: async (projectID: string, batchID: string, batchMetricsData?: BatchMetricsData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createBatchMetricsData', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('createBatchMetricsData', 'batchID', batchID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metricsData`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchMetricsData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a metric. ID and location should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {JobMetric} [jobMetric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetric: async (projectID: string, batchID: string, jobID: string, jobMetric?: JobMetric, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createMetric', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('createMetric', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('createMetric', 'jobID', jobID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobMetric, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new metrics data associated with a job
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {JobMetricsData} [jobMetricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricsData: async (projectID: string, batchID: string, jobID: string, jobMetricsData?: JobMetricsData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createMetricsData', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('createMetricsData', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('createMetricsData', 'jobID', jobID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metricsData`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobMetricsData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the (batch) metrics for a given batch. Does not return associated data.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetrics: async (projectID: string, batchID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBatchMetrics', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listBatchMetrics', 'batchID', batchID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metrics`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metrics data associated with a given batch ID
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetricsData: async (projectID: string, batchID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBatchMetricsData', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listBatchMetricsData', 'batchID', batchID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metricsData`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the batch metrics data associated with given batch metric ID(s)
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetricsDataForBatchMetricIDs: async (projectID: string, batchID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBatchMetricsDataForBatchMetricIDs', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listBatchMetricsDataForBatchMetricIDs', 'batchID', batchID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('listBatchMetricsDataForBatchMetricIDs', 'metricID', metricID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metrics/{metricID}/metricsData`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the batch metrics data associated with given batch metrics data IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetricsDataForBatchMetricsDataIDs: async (projectID: string, batchID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBatchMetricsDataForBatchMetricsDataIDs', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listBatchMetricsDataForBatchMetricsDataIDs', 'batchID', batchID)
            // verify required parameter 'metricsDataID' is not null or undefined
            assertParamExists('listBatchMetricsDataForBatchMetricsDataIDs', 'metricsDataID', metricsDataID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metricsData/{metricsDataID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"metricsDataID"}}`, encodeURIComponent(String(metricsDataID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the batch metrics associated with given batch metric IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetricsForBatchMetricIDs: async (projectID: string, batchID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBatchMetricsForBatchMetricIDs', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listBatchMetricsForBatchMetricIDs', 'batchID', batchID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('listBatchMetricsForBatchMetricIDs', 'metricID', metricID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metrics/{metricID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metrics data associated with a given job ID
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForJob: async (projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listMetricsDataForJob', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsDataForJob', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsDataForJob', 'jobID', jobID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metricsData`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metrics data associated with given metric ID(s)
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForMetricIDs: async (projectID: string, batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listMetricsDataForMetricIDs', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsDataForMetricIDs', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsDataForMetricIDs', 'jobID', jobID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('listMetricsDataForMetricIDs', 'metricID', metricID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics/{metricID}/metricsData`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the metrics data associated with given metrics data IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForMetricsDataIDs: async (projectID: string, batchID: string, jobID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listMetricsDataForMetricsDataIDs', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsDataForMetricsDataIDs', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsDataForMetricsDataIDs', 'jobID', jobID)
            // verify required parameter 'metricsDataID' is not null or undefined
            assertParamExists('listMetricsDataForMetricsDataIDs', 'metricsDataID', metricsDataID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metricsData/{metricsDataID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"metricsDataID"}}`, encodeURIComponent(String(metricsDataID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the metrics for a given job. Does not return associated data.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsForJob: async (projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listMetricsForJob', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsForJob', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsForJob', 'jobID', jobID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the metrics associated with given metric IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsForMetricIDs: async (projectID: string, batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listMetricsForMetricIDs', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsForMetricIDs', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsForMetricIDs', 'jobID', jobID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('listMetricsForMetricIDs', 'metricID', metricID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metrics/{metricID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a batch\'s metrics status.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatchMetricsStatus: async (projectID: string, batchID: string, body?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('updateBatchMetricsStatus', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('updateBatchMetricsStatus', 'batchID', batchID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/metricsStatus`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a job\'s metrics status.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobMetricsStatus: async (projectID: string, batchID: string, jobID: string, body?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('updateJobMetricsStatus', 'projectID', projectID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('updateJobMetricsStatus', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('updateJobMetricsStatus', 'jobID', jobID)
            const localVarPath = `/projects/{projectID}/batches/{batchID}/jobs/{jobID}/metricsStatus`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds batch metrics data (IDs) to a given batch metric
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBatchMetricsDataToBatchMetric(projectID: string, batchID: string, metricID: string, requestBody?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchMetricsDataToBatchMetric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBatchMetricsDataToBatchMetric(projectID, batchID, metricID, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds metrics data (IDs) to a given metric
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMetricsDataToMetric(projectID: string, batchID: string, jobID: string, metricID: string, requestBody?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricDataToMetric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMetricsDataToMetric(projectID, batchID, jobID, metricID, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a batch metric. ID and location should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {BatchMetric} [batchMetric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatchMetric(projectID: string, batchID: string, batchMetric?: BatchMetric, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchMetric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatchMetric(projectID, batchID, batchMetric, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new metrics data associated with a batch
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {BatchMetricsData} [batchMetricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatchMetricsData(projectID: string, batchID: string, batchMetricsData?: BatchMetricsData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchMetricsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatchMetricsData(projectID, batchID, batchMetricsData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a metric. ID and location should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {JobMetric} [jobMetric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMetric(projectID: string, batchID: string, jobID: string, jobMetric?: JobMetric, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobMetric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMetric(projectID, batchID, jobID, jobMetric, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates new metrics data associated with a job
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {JobMetricsData} [jobMetricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMetricsData(projectID: string, batchID: string, jobID: string, jobMetricsData?: JobMetricsData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobMetricsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMetricsData(projectID, batchID, jobID, jobMetricsData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the (batch) metrics for a given batch. Does not return associated data.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchMetrics(projectID: string, batchID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatchMetricsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchMetrics(projectID, batchID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the metrics data associated with a given batch ID
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchMetricsData(projectID: string, batchID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatchMetricsDataOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchMetricsData(projectID, batchID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the batch metrics data associated with given batch metric ID(s)
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchMetricsDataForBatchMetricIDs(projectID: string, batchID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatchMetricsDataForBatchMetricIDsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchMetricsDataForBatchMetricIDs(projectID, batchID, metricID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the batch metrics data associated with given batch metrics data IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchMetricsDataForBatchMetricsDataIDs(projectID: string, batchID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatchMetricsDataOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchMetricsDataForBatchMetricsDataIDs(projectID, batchID, metricsDataID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the batch metrics associated with given batch metric IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchMetricsForBatchMetricIDs(projectID: string, batchID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatchMetricsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchMetricsForBatchMetricIDs(projectID, batchID, metricID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the metrics data associated with a given job ID
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsDataForJob(projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListJobMetricsDataOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsDataForJob(projectID, batchID, jobID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the metrics data associated with given metric ID(s)
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsDataForMetricIDs(projectID: string, batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMetricsDataAndMetricIDOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsDataForMetricIDs(projectID, batchID, jobID, metricID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the metrics data associated with given metrics data IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsDataForMetricsDataIDs(projectID: string, batchID: string, jobID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListJobMetricsDataOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsDataForMetricsDataIDs(projectID, batchID, jobID, metricsDataID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the metrics for a given job. Does not return associated data.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsForJob(projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListJobMetricsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsForJob(projectID, batchID, jobID, pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the metrics associated with given metric IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsForMetricIDs(projectID: string, batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListJobMetricsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsForMetricIDs(projectID, batchID, jobID, metricID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a batch\'s metrics status.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBatchMetricsStatus(projectID: string, batchID: string, body?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBatchMetricsStatus(projectID, batchID, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a job\'s metrics status.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateJobMetricsStatus(projectID: string, batchID: string, jobID: string, body?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateJobMetricsStatus(projectID, batchID, jobID, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * Adds batch metrics data (IDs) to a given batch metric
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBatchMetricsDataToBatchMetric(projectID: string, batchID: string, metricID: string, requestBody?: Array<string>, options?: any): AxiosPromise<BatchMetricsDataToBatchMetric> {
            return localVarFp.addBatchMetricsDataToBatchMetric(projectID, batchID, metricID, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds metrics data (IDs) to a given metric
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetricsDataToMetric(projectID: string, batchID: string, jobID: string, metricID: string, requestBody?: Array<string>, options?: any): AxiosPromise<MetricDataToMetric> {
            return localVarFp.addMetricsDataToMetric(projectID, batchID, jobID, metricID, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a batch metric. ID and location should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {BatchMetric} [batchMetric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchMetric(projectID: string, batchID: string, batchMetric?: BatchMetric, options?: any): AxiosPromise<BatchMetric> {
            return localVarFp.createBatchMetric(projectID, batchID, batchMetric, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new metrics data associated with a batch
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {BatchMetricsData} [batchMetricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchMetricsData(projectID: string, batchID: string, batchMetricsData?: BatchMetricsData, options?: any): AxiosPromise<BatchMetricsData> {
            return localVarFp.createBatchMetricsData(projectID, batchID, batchMetricsData, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a metric. ID and location should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {JobMetric} [jobMetric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetric(projectID: string, batchID: string, jobID: string, jobMetric?: JobMetric, options?: any): AxiosPromise<JobMetric> {
            return localVarFp.createMetric(projectID, batchID, jobID, jobMetric, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates new metrics data associated with a job
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {JobMetricsData} [jobMetricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricsData(projectID: string, batchID: string, jobID: string, jobMetricsData?: JobMetricsData, options?: any): AxiosPromise<JobMetricsData> {
            return localVarFp.createMetricsData(projectID, batchID, jobID, jobMetricsData, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the (batch) metrics for a given batch. Does not return associated data.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetrics(projectID: string, batchID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListBatchMetricsOutput> {
            return localVarFp.listBatchMetrics(projectID, batchID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the metrics data associated with a given batch ID
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetricsData(projectID: string, batchID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListBatchMetricsDataOutput> {
            return localVarFp.listBatchMetricsData(projectID, batchID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the batch metrics data associated with given batch metric ID(s)
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetricsDataForBatchMetricIDs(projectID: string, batchID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListBatchMetricsDataForBatchMetricIDsOutput> {
            return localVarFp.listBatchMetricsDataForBatchMetricIDs(projectID, batchID, metricID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the batch metrics data associated with given batch metrics data IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetricsDataForBatchMetricsDataIDs(projectID: string, batchID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListBatchMetricsDataOutput> {
            return localVarFp.listBatchMetricsDataForBatchMetricsDataIDs(projectID, batchID, metricsDataID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the batch metrics associated with given batch metric IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetricsForBatchMetricIDs(projectID: string, batchID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListBatchMetricsOutput> {
            return localVarFp.listBatchMetricsForBatchMetricIDs(projectID, batchID, metricID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the metrics data associated with a given job ID
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForJob(projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListJobMetricsDataOutput> {
            return localVarFp.listMetricsDataForJob(projectID, batchID, jobID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the metrics data associated with given metric ID(s)
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForMetricIDs(projectID: string, batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListMetricsDataAndMetricIDOutput> {
            return localVarFp.listMetricsDataForMetricIDs(projectID, batchID, jobID, metricID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the metrics data associated with given metrics data IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForMetricsDataIDs(projectID: string, batchID: string, jobID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListJobMetricsDataOutput> {
            return localVarFp.listMetricsDataForMetricsDataIDs(projectID, batchID, jobID, metricsDataID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the metrics for a given job. Does not return associated data.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsForJob(projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListJobMetricsOutput> {
            return localVarFp.listMetricsForJob(projectID, batchID, jobID, pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the metrics associated with given metric IDs
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsForMetricIDs(projectID: string, batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListJobMetricsOutput> {
            return localVarFp.listMetricsForMetricIDs(projectID, batchID, jobID, metricID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a batch\'s metrics status.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBatchMetricsStatus(projectID: string, batchID: string, body?: string, options?: any): AxiosPromise<Batch> {
            return localVarFp.updateBatchMetricsStatus(projectID, batchID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a job\'s metrics status.
         * @param {string} projectID 
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobMetricsStatus(projectID: string, batchID: string, jobID: string, body?: string, options?: any): AxiosPromise<Job> {
            return localVarFp.updateJobMetricsStatus(projectID, batchID, jobID, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * Adds batch metrics data (IDs) to a given batch metric
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} metricID 
     * @param {Array<string>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public addBatchMetricsDataToBatchMetric(projectID: string, batchID: string, metricID: string, requestBody?: Array<string>, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).addBatchMetricsDataToBatchMetric(projectID, batchID, metricID, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds metrics data (IDs) to a given metric
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {string} metricID 
     * @param {Array<string>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public addMetricsDataToMetric(projectID: string, batchID: string, jobID: string, metricID: string, requestBody?: Array<string>, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).addMetricsDataToMetric(projectID, batchID, jobID, metricID, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a batch metric. ID and location should be omitted and will be returned in the response.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {BatchMetric} [batchMetric] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public createBatchMetric(projectID: string, batchID: string, batchMetric?: BatchMetric, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).createBatchMetric(projectID, batchID, batchMetric, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new metrics data associated with a batch
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {BatchMetricsData} [batchMetricsData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public createBatchMetricsData(projectID: string, batchID: string, batchMetricsData?: BatchMetricsData, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).createBatchMetricsData(projectID, batchID, batchMetricsData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a metric. ID and location should be omitted and will be returned in the response.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {JobMetric} [jobMetric] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public createMetric(projectID: string, batchID: string, jobID: string, jobMetric?: JobMetric, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).createMetric(projectID, batchID, jobID, jobMetric, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates new metrics data associated with a job
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {JobMetricsData} [jobMetricsData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public createMetricsData(projectID: string, batchID: string, jobID: string, jobMetricsData?: JobMetricsData, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).createMetricsData(projectID, batchID, jobID, jobMetricsData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the (batch) metrics for a given batch. Does not return associated data.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listBatchMetrics(projectID: string, batchID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listBatchMetrics(projectID, batchID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the metrics data associated with a given batch ID
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listBatchMetricsData(projectID: string, batchID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listBatchMetricsData(projectID, batchID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the batch metrics data associated with given batch metric ID(s)
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {Array<string>} metricID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listBatchMetricsDataForBatchMetricIDs(projectID: string, batchID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listBatchMetricsDataForBatchMetricIDs(projectID, batchID, metricID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the batch metrics data associated with given batch metrics data IDs
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {Array<string>} metricsDataID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listBatchMetricsDataForBatchMetricsDataIDs(projectID: string, batchID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listBatchMetricsDataForBatchMetricsDataIDs(projectID, batchID, metricsDataID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the batch metrics associated with given batch metric IDs
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {Array<string>} metricID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listBatchMetricsForBatchMetricIDs(projectID: string, batchID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listBatchMetricsForBatchMetricIDs(projectID, batchID, metricID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the metrics data associated with a given job ID
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listMetricsDataForJob(projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listMetricsDataForJob(projectID, batchID, jobID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the metrics data associated with given metric ID(s)
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {Array<string>} metricID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listMetricsDataForMetricIDs(projectID: string, batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listMetricsDataForMetricIDs(projectID, batchID, jobID, metricID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the metrics data associated with given metrics data IDs
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {Array<string>} metricsDataID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listMetricsDataForMetricsDataIDs(projectID: string, batchID: string, jobID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listMetricsDataForMetricsDataIDs(projectID, batchID, jobID, metricsDataID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the metrics for a given job. Does not return associated data.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listMetricsForJob(projectID: string, batchID: string, jobID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listMetricsForJob(projectID, batchID, jobID, pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the metrics associated with given metric IDs
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {Array<string>} metricID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listMetricsForMetricIDs(projectID: string, batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listMetricsForMetricIDs(projectID, batchID, jobID, metricID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a batch\'s metrics status.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public updateBatchMetricsStatus(projectID: string, batchID: string, body?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).updateBatchMetricsStatus(projectID, batchID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a job\'s metrics status.
     * @param {string} projectID 
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public updateJobMetricsStatus(projectID: string, batchID: string, jobID: string, body?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).updateJobMetricsStatus(projectID, batchID, jobID, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetricsBuildsApi - axios parameter creator
 * @export
 */
export const MetricsBuildsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a metrics build.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {MetricsBuild} [metricsBuild] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricsBuild: async (projectID: string, metricsBuild?: MetricsBuild, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createMetricsBuild', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}/metricsBuilds`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metricsBuild, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific metrics build.
         * @param {string} projectID 
         * @param {string} metricsBuildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsBuild: async (projectID: string, metricsBuildID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getMetricsBuild', 'projectID', projectID)
            // verify required parameter 'metricsBuildID' is not null or undefined
            assertParamExists('getMetricsBuild', 'metricsBuildID', metricsBuildID)
            const localVarPath = `/projects/{projectID}/metricsBuilds/{metricsBuildID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"metricsBuildID"}}`, encodeURIComponent(String(metricsBuildID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the systems for a given metrics build
         * @param {string} projectID 
         * @param {string} metricsBuildID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemsForMetricsBuild: async (projectID: string, metricsBuildID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getSystemsForMetricsBuild', 'projectID', projectID)
            // verify required parameter 'metricsBuildID' is not null or undefined
            assertParamExists('getSystemsForMetricsBuild', 'metricsBuildID', metricsBuildID)
            const localVarPath = `/projects/{projectID}/metricsBuilds/{metricsBuildID}/systems`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"metricsBuildID"}}`, encodeURIComponent(String(metricsBuildID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of metrics builds.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsBuilds: async (projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listMetricsBuilds', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}/metricsBuilds`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsBuildsApi - functional programming interface
 * @export
 */
export const MetricsBuildsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsBuildsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a metrics build.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {MetricsBuild} [metricsBuild] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMetricsBuild(projectID: string, metricsBuild?: MetricsBuild, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsBuild>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMetricsBuild(projectID, metricsBuild, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific metrics build.
         * @param {string} projectID 
         * @param {string} metricsBuildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricsBuild(projectID: string, metricsBuildID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsBuild>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricsBuild(projectID, metricsBuildID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the systems for a given metrics build
         * @param {string} projectID 
         * @param {string} metricsBuildID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemsForMetricsBuild(projectID: string, metricsBuildID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSystemsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemsForMetricsBuild(projectID, metricsBuildID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of metrics builds.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsBuilds(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMetricsBuildOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsBuilds(projectID, pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsBuildsApi - factory interface
 * @export
 */
export const MetricsBuildsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsBuildsApiFp(configuration)
    return {
        /**
         * Adds a metrics build.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {MetricsBuild} [metricsBuild] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricsBuild(projectID: string, metricsBuild?: MetricsBuild, options?: any): AxiosPromise<MetricsBuild> {
            return localVarFp.createMetricsBuild(projectID, metricsBuild, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific metrics build.
         * @param {string} projectID 
         * @param {string} metricsBuildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsBuild(projectID: string, metricsBuildID: string, options?: any): AxiosPromise<MetricsBuild> {
            return localVarFp.getMetricsBuild(projectID, metricsBuildID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the systems for a given metrics build
         * @param {string} projectID 
         * @param {string} metricsBuildID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemsForMetricsBuild(projectID: string, metricsBuildID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListSystemsOutput> {
            return localVarFp.getSystemsForMetricsBuild(projectID, metricsBuildID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of metrics builds.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsBuilds(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListMetricsBuildOutput> {
            return localVarFp.listMetricsBuilds(projectID, pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsBuildsApi - object-oriented interface
 * @export
 * @class MetricsBuildsApi
 * @extends {BaseAPI}
 */
export class MetricsBuildsApi extends BaseAPI {
    /**
     * Adds a metrics build.  ID should be omitted and will be returned in the response.
     * @param {string} projectID 
     * @param {MetricsBuild} [metricsBuild] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsBuildsApi
     */
    public createMetricsBuild(projectID: string, metricsBuild?: MetricsBuild, options?: AxiosRequestConfig) {
        return MetricsBuildsApiFp(this.configuration).createMetricsBuild(projectID, metricsBuild, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific metrics build.
     * @param {string} projectID 
     * @param {string} metricsBuildID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsBuildsApi
     */
    public getMetricsBuild(projectID: string, metricsBuildID: string, options?: AxiosRequestConfig) {
        return MetricsBuildsApiFp(this.configuration).getMetricsBuild(projectID, metricsBuildID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the systems for a given metrics build
     * @param {string} projectID 
     * @param {string} metricsBuildID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsBuildsApi
     */
    public getSystemsForMetricsBuild(projectID: string, metricsBuildID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return MetricsBuildsApiFp(this.configuration).getSystemsForMetricsBuild(projectID, metricsBuildID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of metrics builds.
     * @param {string} projectID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsBuildsApi
     */
    public listMetricsBuilds(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return MetricsBuildsApiFp(this.configuration).listMetricsBuilds(projectID, pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ParameterSweepsApi - axios parameter creator
 * @export
 */
export const ParameterSweepsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels a parameter sweep.
         * @param {string} projectID 
         * @param {string} sweepID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelParameterSweep: async (projectID: string, sweepID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('cancelParameterSweep', 'projectID', projectID)
            // verify required parameter 'sweepID' is not null or undefined
            assertParamExists('cancelParameterSweep', 'sweepID', sweepID)
            const localVarPath = `/projects/{projectID}/sweeps/{sweepID}/:cancel`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"sweepID"}}`, encodeURIComponent(String(sweepID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sweeps:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sweeps:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sweeps:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a parameter sweep.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {ParameterSweepInput} [parameterSweepInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createParameterSweep: async (projectID: string, parameterSweepInput?: ParameterSweepInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createParameterSweep', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}/sweeps`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sweeps:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sweeps:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sweeps:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parameterSweepInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific parameer sweep.
         * @param {string} projectID 
         * @param {string} sweepID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParameterSweep: async (projectID: string, sweepID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getParameterSweep', 'projectID', projectID)
            // verify required parameter 'sweepID' is not null or undefined
            assertParamExists('getParameterSweep', 'sweepID', sweepID)
            const localVarPath = `/projects/{projectID}/sweeps/{sweepID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"sweepID"}}`, encodeURIComponent(String(sweepID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sweeps:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sweeps:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sweeps:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of parameter sweeps.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listParameterSweeps: async (projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listParameterSweeps', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}/sweeps`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sweeps:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sweeps:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sweeps:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParameterSweepsApi - functional programming interface
 * @export
 */
export const ParameterSweepsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParameterSweepsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancels a parameter sweep.
         * @param {string} projectID 
         * @param {string} sweepID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelParameterSweep(projectID: string, sweepID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelParameterSweep(projectID, sweepID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a parameter sweep.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {ParameterSweepInput} [parameterSweepInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createParameterSweep(projectID: string, parameterSweepInput?: ParameterSweepInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParameterSweep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createParameterSweep(projectID, parameterSweepInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific parameer sweep.
         * @param {string} projectID 
         * @param {string} sweepID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParameterSweep(projectID: string, sweepID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParameterSweep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParameterSweep(projectID, sweepID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of parameter sweeps.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listParameterSweeps(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListParameterSweepsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listParameterSweeps(projectID, pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ParameterSweepsApi - factory interface
 * @export
 */
export const ParameterSweepsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParameterSweepsApiFp(configuration)
    return {
        /**
         * Cancels a parameter sweep.
         * @param {string} projectID 
         * @param {string} sweepID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelParameterSweep(projectID: string, sweepID: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelParameterSweep(projectID, sweepID, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a parameter sweep.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {ParameterSweepInput} [parameterSweepInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createParameterSweep(projectID: string, parameterSweepInput?: ParameterSweepInput, options?: any): AxiosPromise<ParameterSweep> {
            return localVarFp.createParameterSweep(projectID, parameterSweepInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific parameer sweep.
         * @param {string} projectID 
         * @param {string} sweepID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParameterSweep(projectID: string, sweepID: string, options?: any): AxiosPromise<ParameterSweep> {
            return localVarFp.getParameterSweep(projectID, sweepID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of parameter sweeps.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listParameterSweeps(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListParameterSweepsOutput> {
            return localVarFp.listParameterSweeps(projectID, pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ParameterSweepsApi - object-oriented interface
 * @export
 * @class ParameterSweepsApi
 * @extends {BaseAPI}
 */
export class ParameterSweepsApi extends BaseAPI {
    /**
     * Cancels a parameter sweep.
     * @param {string} projectID 
     * @param {string} sweepID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParameterSweepsApi
     */
    public cancelParameterSweep(projectID: string, sweepID: string, options?: AxiosRequestConfig) {
        return ParameterSweepsApiFp(this.configuration).cancelParameterSweep(projectID, sweepID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a parameter sweep.  ID should be omitted and will be returned in the response.
     * @param {string} projectID 
     * @param {ParameterSweepInput} [parameterSweepInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParameterSweepsApi
     */
    public createParameterSweep(projectID: string, parameterSweepInput?: ParameterSweepInput, options?: AxiosRequestConfig) {
        return ParameterSweepsApiFp(this.configuration).createParameterSweep(projectID, parameterSweepInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific parameer sweep.
     * @param {string} projectID 
     * @param {string} sweepID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParameterSweepsApi
     */
    public getParameterSweep(projectID: string, sweepID: string, options?: AxiosRequestConfig) {
        return ParameterSweepsApiFp(this.configuration).getParameterSweep(projectID, sweepID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of parameter sweeps.
     * @param {string} projectID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParameterSweepsApi
     */
    public listParameterSweeps(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return ParameterSweepsApiFp(this.configuration).listParameterSweeps(projectID, pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a branch for a project.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {Branch} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBranchForProject: async (projectID: string, branch?: Branch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createBranchForProject', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}/branches`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(branch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a project.  ID should be omitted and will be returned in the response.
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (project?: Project, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(project, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a branch for a project.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranchForProject: async (projectID: string, branchID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('deleteBranchForProject', 'projectID', projectID)
            // verify required parameter 'branchID' is not null or undefined
            assertParamExists('deleteBranchForProject', 'branchID', branchID)
            const localVarPath = `/projects/{projectID}/branches/{branchID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"branchID"}}`, encodeURIComponent(String(branchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a project.
         * @param {string} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (projectID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('deleteProject', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific branch for a project.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranchForProject: async (projectID: string, branchID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getBranchForProject', 'projectID', projectID)
            // verify required parameter 'branchID' is not null or undefined
            assertParamExists('getBranchForProject', 'branchID', branchID)
            const localVarPath = `/projects/{projectID}/branches/{branchID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"branchID"}}`, encodeURIComponent(String(branchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific project.
         * @param {string} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (projectID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getProject', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of branches for a project.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBranchesForProject: async (projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBranchesForProject', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}/branches`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of projects.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects: async (pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the project.
         * @param {string} projectID 
         * @param {ProjectUpdateInput} [projectUpdateInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (projectID: string, projectUpdateInput?: ProjectUpdateInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('updateProject', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a branch for a project.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {Branch} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBranchForProject(projectID: string, branch?: Branch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBranchForProject(projectID, branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a project.  ID should be omitted and will be returned in the response.
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(project?: Project, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(project, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a branch for a project.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBranchForProject(projectID: string, branchID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBranchForProject(projectID, branchID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a project.
         * @param {string} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(projectID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(projectID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific branch for a project.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBranchForProject(projectID: string, branchID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBranchForProject(projectID, branchID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific project.
         * @param {string} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(projectID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projectID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of branches for a project.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBranchesForProject(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBranchesOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBranchesForProject(projectID, pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of projects.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjects(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProjectsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the project.
         * @param {string} projectID 
         * @param {ProjectUpdateInput} [projectUpdateInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(projectID: string, projectUpdateInput?: ProjectUpdateInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(projectID, projectUpdateInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Adds a branch for a project.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {Branch} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBranchForProject(projectID: string, branch?: Branch, options?: any): AxiosPromise<Branch> {
            return localVarFp.createBranchForProject(projectID, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a project.  ID should be omitted and will be returned in the response.
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(project?: Project, options?: any): AxiosPromise<Project> {
            return localVarFp.createProject(project, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a branch for a project.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranchForProject(projectID: string, branchID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBranchForProject(projectID, branchID, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a project.
         * @param {string} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(projectID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProject(projectID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific branch for a project.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranchForProject(projectID: string, branchID: string, options?: any): AxiosPromise<Branch> {
            return localVarFp.getBranchForProject(projectID, branchID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific project.
         * @param {string} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectID: string, options?: any): AxiosPromise<Project> {
            return localVarFp.getProject(projectID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of branches for a project.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBranchesForProject(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListBranchesOutput> {
            return localVarFp.listBranchesForProject(projectID, pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of projects.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListProjectsOutput> {
            return localVarFp.listProjects(pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the project.
         * @param {string} projectID 
         * @param {ProjectUpdateInput} [projectUpdateInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(projectID: string, projectUpdateInput?: ProjectUpdateInput, options?: any): AxiosPromise<Project> {
            return localVarFp.updateProject(projectID, projectUpdateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * Adds a branch for a project.  ID should be omitted and will be returned in the response.
     * @param {string} projectID 
     * @param {Branch} [branch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createBranchForProject(projectID: string, branch?: Branch, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createBranchForProject(projectID, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a project.  ID should be omitted and will be returned in the response.
     * @param {Project} [project] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProject(project?: Project, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createProject(project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a branch for a project.
     * @param {string} projectID 
     * @param {string} branchID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteBranchForProject(projectID: string, branchID: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteBranchForProject(projectID, branchID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a project.
     * @param {string} projectID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProject(projectID: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteProject(projectID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific branch for a project.
     * @param {string} projectID 
     * @param {string} branchID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getBranchForProject(projectID: string, branchID: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getBranchForProject(projectID, branchID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific project.
     * @param {string} projectID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProject(projectID: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getProject(projectID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of branches for a project.
     * @param {string} projectID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listBranchesForProject(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listBranchesForProject(projectID, pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of projects.
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjects(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listProjects(pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the project.
     * @param {string} projectID 
     * @param {ProjectUpdateInput} [projectUpdateInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProject(projectID: string, projectUpdateInput?: ProjectUpdateInput, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).updateProject(projectID, projectUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SandboxApi - axios parameter creator
 * @export
 */
export const SandboxApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Destroys a sandbox environment.
         * @param {SandboxInput} [sandboxInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySandbox: async (sandboxInput?: SandboxInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sandbox/:destroy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sandbox:destroy"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sandbox:destroy"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sandbox:destroy"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sandboxInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initializes a sandbox environment.
         * @param {SandboxInput} [sandboxInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupSandbox: async (sandboxInput?: SandboxInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sandbox/:setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sandbox:setup"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sandbox:setup"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sandbox:setup"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sandboxInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SandboxApi - functional programming interface
 * @export
 */
export const SandboxApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SandboxApiAxiosParamCreator(configuration)
    return {
        /**
         * Destroys a sandbox environment.
         * @param {SandboxInput} [sandboxInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroySandbox(sandboxInput?: SandboxInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroySandbox(sandboxInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initializes a sandbox environment.
         * @param {SandboxInput} [sandboxInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setupSandbox(sandboxInput?: SandboxInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setupSandbox(sandboxInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SandboxApi - factory interface
 * @export
 */
export const SandboxApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SandboxApiFp(configuration)
    return {
        /**
         * Destroys a sandbox environment.
         * @param {SandboxInput} [sandboxInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySandbox(sandboxInput?: SandboxInput, options?: any): AxiosPromise<void> {
            return localVarFp.destroySandbox(sandboxInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Initializes a sandbox environment.
         * @param {SandboxInput} [sandboxInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupSandbox(sandboxInput?: SandboxInput, options?: any): AxiosPromise<void> {
            return localVarFp.setupSandbox(sandboxInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SandboxApi - object-oriented interface
 * @export
 * @class SandboxApi
 * @extends {BaseAPI}
 */
export class SandboxApi extends BaseAPI {
    /**
     * Destroys a sandbox environment.
     * @param {SandboxInput} [sandboxInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandboxApi
     */
    public destroySandbox(sandboxInput?: SandboxInput, options?: AxiosRequestConfig) {
        return SandboxApiFp(this.configuration).destroySandbox(sandboxInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initializes a sandbox environment.
     * @param {SandboxInput} [sandboxInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandboxApi
     */
    public setupSandbox(sandboxInput?: SandboxInput, options?: AxiosRequestConfig) {
        return SandboxApiFp(this.configuration).setupSandbox(sandboxInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemsApi - axios parameter creator
 * @export
 */
export const SystemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Registers the given experience as applicable for the system
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSystemToExperience: async (projectID: string, systemID: string, experienceID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('addSystemToExperience', 'projectID', projectID)
            // verify required parameter 'systemID' is not null or undefined
            assertParamExists('addSystemToExperience', 'systemID', systemID)
            // verify required parameter 'experienceID' is not null or undefined
            assertParamExists('addSystemToExperience', 'experienceID', experienceID)
            const localVarPath = `/projects/{projectID}/systems/{systemID}/experiences/{experienceID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"systemID"}}`, encodeURIComponent(String(systemID)))
                .replace(`{${"experienceID"}}`, encodeURIComponent(String(experienceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers the given metrics build as applicable for the system
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {string} metricsBuildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSystemToMetricsBuild: async (projectID: string, systemID: string, metricsBuildID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('addSystemToMetricsBuild', 'projectID', projectID)
            // verify required parameter 'systemID' is not null or undefined
            assertParamExists('addSystemToMetricsBuild', 'systemID', systemID)
            // verify required parameter 'metricsBuildID' is not null or undefined
            assertParamExists('addSystemToMetricsBuild', 'metricsBuildID', metricsBuildID)
            const localVarPath = `/projects/{projectID}/systems/{systemID}/metricsBuilds/{metricsBuildID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"systemID"}}`, encodeURIComponent(String(systemID)))
                .replace(`{${"metricsBuildID"}}`, encodeURIComponent(String(metricsBuildID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a system.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {System} [system] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSystem: async (projectID: string, system?: System, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createSystem', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}/systems`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(system, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystem: async (projectID: string, systemID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getSystem', 'projectID', projectID)
            // verify required parameter 'systemID' is not null or undefined
            assertParamExists('getSystem', 'systemID', systemID)
            const localVarPath = `/projects/{projectID}/systems/{systemID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"systemID"}}`, encodeURIComponent(String(systemID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all experiences applicable to the system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiencesForSystem: async (projectID: string, systemID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listExperiencesForSystem', 'projectID', projectID)
            // verify required parameter 'systemID' is not null or undefined
            assertParamExists('listExperiencesForSystem', 'systemID', systemID)
            const localVarPath = `/projects/{projectID}/systems/{systemID}/experiences`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"systemID"}}`, encodeURIComponent(String(systemID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all metrics builds applicable to the system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsBuildsForSystem: async (projectID: string, systemID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listMetricsBuildsForSystem', 'projectID', projectID)
            // verify required parameter 'systemID' is not null or undefined
            assertParamExists('listMetricsBuildsForSystem', 'systemID', systemID)
            const localVarPath = `/projects/{projectID}/systems/{systemID}/metricsBuilds`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"systemID"}}`, encodeURIComponent(String(systemID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of systems.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSystems: async (projectID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listSystems', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}/systems`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deregisters the given experience as applicable for the system
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSystemFromExperience: async (projectID: string, systemID: string, experienceID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('removeSystemFromExperience', 'projectID', projectID)
            // verify required parameter 'systemID' is not null or undefined
            assertParamExists('removeSystemFromExperience', 'systemID', systemID)
            // verify required parameter 'experienceID' is not null or undefined
            assertParamExists('removeSystemFromExperience', 'experienceID', experienceID)
            const localVarPath = `/projects/{projectID}/systems/{systemID}/experiences/{experienceID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"systemID"}}`, encodeURIComponent(String(systemID)))
                .replace(`{${"experienceID"}}`, encodeURIComponent(String(experienceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deregisters the given metrics build as applicable for the system
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {string} metricsBuildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSystemFromMetricsBuild: async (projectID: string, systemID: string, metricsBuildID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('removeSystemFromMetricsBuild', 'projectID', projectID)
            // verify required parameter 'systemID' is not null or undefined
            assertParamExists('removeSystemFromMetricsBuild', 'systemID', systemID)
            // verify required parameter 'metricsBuildID' is not null or undefined
            assertParamExists('removeSystemFromMetricsBuild', 'metricsBuildID', metricsBuildID)
            const localVarPath = `/projects/{projectID}/systems/{systemID}/metricsBuilds/{metricsBuildID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"systemID"}}`, encodeURIComponent(String(systemID)))
                .replace(`{${"metricsBuildID"}}`, encodeURIComponent(String(metricsBuildID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {SystemInput} [systemInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSystem: async (projectID: string, systemID: string, systemInput?: SystemInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('updateSystem', 'projectID', projectID)
            // verify required parameter 'systemID' is not null or undefined
            assertParamExists('updateSystem', 'systemID', systemID)
            const localVarPath = `/projects/{projectID}/systems/{systemID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"systemID"}}`, encodeURIComponent(String(systemID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["systems:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemsApi - functional programming interface
 * @export
 */
export const SystemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Registers the given experience as applicable for the system
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSystemToExperience(projectID: string, systemID: string, experienceID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSystemToExperience(projectID, systemID, experienceID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers the given metrics build as applicable for the system
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {string} metricsBuildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSystemToMetricsBuild(projectID: string, systemID: string, metricsBuildID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSystemToMetricsBuild(projectID, systemID, metricsBuildID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a system.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {System} [system] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSystem(projectID: string, system?: System, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<System>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSystem(projectID, system, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystem(projectID: string, systemID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<System>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystem(projectID, systemID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all experiences applicable to the system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExperiencesForSystem(projectID: string, systemID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListExperiencesOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExperiencesForSystem(projectID, systemID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all metrics builds applicable to the system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsBuildsForSystem(projectID: string, systemID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMetricsBuildOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsBuildsForSystem(projectID, systemID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of systems.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSystems(projectID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSystemsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSystems(projectID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deregisters the given experience as applicable for the system
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeSystemFromExperience(projectID: string, systemID: string, experienceID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeSystemFromExperience(projectID, systemID, experienceID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deregisters the given metrics build as applicable for the system
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {string} metricsBuildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeSystemFromMetricsBuild(projectID: string, systemID: string, metricsBuildID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeSystemFromMetricsBuild(projectID, systemID, metricsBuildID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {SystemInput} [systemInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSystem(projectID: string, systemID: string, systemInput?: SystemInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<System>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSystem(projectID, systemID, systemInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemsApi - factory interface
 * @export
 */
export const SystemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemsApiFp(configuration)
    return {
        /**
         * Registers the given experience as applicable for the system
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSystemToExperience(projectID: string, systemID: string, experienceID: string, options?: any): AxiosPromise<void> {
            return localVarFp.addSystemToExperience(projectID, systemID, experienceID, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers the given metrics build as applicable for the system
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {string} metricsBuildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSystemToMetricsBuild(projectID: string, systemID: string, metricsBuildID: string, options?: any): AxiosPromise<void> {
            return localVarFp.addSystemToMetricsBuild(projectID, systemID, metricsBuildID, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a system.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {System} [system] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSystem(projectID: string, system?: System, options?: any): AxiosPromise<System> {
            return localVarFp.createSystem(projectID, system, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystem(projectID: string, systemID: string, options?: any): AxiosPromise<System> {
            return localVarFp.getSystem(projectID, systemID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all experiences applicable to the system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiencesForSystem(projectID: string, systemID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListExperiencesOutput> {
            return localVarFp.listExperiencesForSystem(projectID, systemID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all metrics builds applicable to the system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsBuildsForSystem(projectID: string, systemID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListMetricsBuildOutput> {
            return localVarFp.listMetricsBuildsForSystem(projectID, systemID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of systems.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSystems(projectID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListSystemsOutput> {
            return localVarFp.listSystems(projectID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Deregisters the given experience as applicable for the system
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSystemFromExperience(projectID: string, systemID: string, experienceID: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeSystemFromExperience(projectID, systemID, experienceID, options).then((request) => request(axios, basePath));
        },
        /**
         * Deregisters the given metrics build as applicable for the system
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {string} metricsBuildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSystemFromMetricsBuild(projectID: string, systemID: string, metricsBuildID: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeSystemFromMetricsBuild(projectID, systemID, metricsBuildID, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the system.
         * @param {string} projectID 
         * @param {string} systemID 
         * @param {SystemInput} [systemInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSystem(projectID: string, systemID: string, systemInput?: SystemInput, options?: any): AxiosPromise<System> {
            return localVarFp.updateSystem(projectID, systemID, systemInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemsApi - object-oriented interface
 * @export
 * @class SystemsApi
 * @extends {BaseAPI}
 */
export class SystemsApi extends BaseAPI {
    /**
     * Registers the given experience as applicable for the system
     * @param {string} projectID 
     * @param {string} systemID 
     * @param {string} experienceID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public addSystemToExperience(projectID: string, systemID: string, experienceID: string, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).addSystemToExperience(projectID, systemID, experienceID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers the given metrics build as applicable for the system
     * @param {string} projectID 
     * @param {string} systemID 
     * @param {string} metricsBuildID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public addSystemToMetricsBuild(projectID: string, systemID: string, metricsBuildID: string, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).addSystemToMetricsBuild(projectID, systemID, metricsBuildID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a system.  ID should be omitted and will be returned in the response.
     * @param {string} projectID 
     * @param {System} [system] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public createSystem(projectID: string, system?: System, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).createSystem(projectID, system, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific system.
     * @param {string} projectID 
     * @param {string} systemID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public getSystem(projectID: string, systemID: string, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).getSystem(projectID, systemID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all experiences applicable to the system.
     * @param {string} projectID 
     * @param {string} systemID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public listExperiencesForSystem(projectID: string, systemID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).listExperiencesForSystem(projectID, systemID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all metrics builds applicable to the system.
     * @param {string} projectID 
     * @param {string} systemID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public listMetricsBuildsForSystem(projectID: string, systemID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).listMetricsBuildsForSystem(projectID, systemID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of systems.
     * @param {string} projectID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public listSystems(projectID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).listSystems(projectID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deregisters the given experience as applicable for the system
     * @param {string} projectID 
     * @param {string} systemID 
     * @param {string} experienceID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public removeSystemFromExperience(projectID: string, systemID: string, experienceID: string, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).removeSystemFromExperience(projectID, systemID, experienceID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deregisters the given metrics build as applicable for the system
     * @param {string} projectID 
     * @param {string} systemID 
     * @param {string} metricsBuildID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public removeSystemFromMetricsBuild(projectID: string, systemID: string, metricsBuildID: string, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).removeSystemFromMetricsBuild(projectID, systemID, metricsBuildID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the system.
     * @param {string} projectID 
     * @param {string} systemID 
     * @param {SystemInput} [systemInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public updateSystem(projectID: string, systemID: string, systemInput?: SystemInput, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).updateSystem(projectID, systemID, systemInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ViewApi - axios parameter creator
 * @export
 */
export const ViewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new View session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createViewSession: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/view/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds an update to the View session.  Updates will be serialized sequentially by ID.
         * @param {string} viewSessionID 
         * @param {number} viewUpdateID 
         * @param {File} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createViewUpdate: async (viewSessionID: string, viewUpdateID: number, body?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewSessionID' is not null or undefined
            assertParamExists('createViewUpdate', 'viewSessionID', viewSessionID)
            // verify required parameter 'viewUpdateID' is not null or undefined
            assertParamExists('createViewUpdate', 'viewUpdateID', viewUpdateID)
            const localVarPath = `/view/sessions/{viewSessionID}/updates/{viewUpdateID}`
                .replace(`{${"viewSessionID"}}`, encodeURIComponent(String(viewSessionID)))
                .replace(`{${"viewUpdateID"}}`, encodeURIComponent(String(viewUpdateID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the view object and metadata associated with a specific view.
         * @param {string} viewSessionID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewSession: async (viewSessionID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewSessionID' is not null or undefined
            assertParamExists('getViewSession', 'viewSessionID', viewSessionID)
            const localVarPath = `/view/sessions/{viewSessionID}`
                .replace(`{${"viewSessionID"}}`, encodeURIComponent(String(viewSessionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all View sessions.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViewSessions: async (pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/view/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewApi - functional programming interface
 * @export
 */
export const ViewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ViewApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new View session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createViewSession(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createViewSession(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds an update to the View session.  Updates will be serialized sequentially by ID.
         * @param {string} viewSessionID 
         * @param {number} viewUpdateID 
         * @param {File} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createViewUpdate(viewSessionID: string, viewUpdateID: number, body?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewSessionUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createViewUpdate(viewSessionID, viewUpdateID, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the view object and metadata associated with a specific view.
         * @param {string} viewSessionID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getViewSession(viewSessionID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewObjectAndMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getViewSession(viewSessionID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all View sessions.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listViewSessions(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListViewObjectsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listViewSessions(pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ViewApi - factory interface
 * @export
 */
export const ViewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ViewApiFp(configuration)
    return {
        /**
         * Creates a new View session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createViewSession(options?: any): AxiosPromise<string> {
            return localVarFp.createViewSession(options).then((request) => request(axios, basePath));
        },
        /**
         * Adds an update to the View session.  Updates will be serialized sequentially by ID.
         * @param {string} viewSessionID 
         * @param {number} viewUpdateID 
         * @param {File} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createViewUpdate(viewSessionID: string, viewUpdateID: number, body?: File, options?: any): AxiosPromise<ViewSessionUpdate> {
            return localVarFp.createViewUpdate(viewSessionID, viewUpdateID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the view object and metadata associated with a specific view.
         * @param {string} viewSessionID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewSession(viewSessionID: string, options?: any): AxiosPromise<ViewObjectAndMetadata> {
            return localVarFp.getViewSession(viewSessionID, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all View sessions.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViewSessions(pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListViewObjectsOutput> {
            return localVarFp.listViewSessions(pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ViewApi - object-oriented interface
 * @export
 * @class ViewApi
 * @extends {BaseAPI}
 */
export class ViewApi extends BaseAPI {
    /**
     * Creates a new View session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewApi
     */
    public createViewSession(options?: AxiosRequestConfig) {
        return ViewApiFp(this.configuration).createViewSession(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds an update to the View session.  Updates will be serialized sequentially by ID.
     * @param {string} viewSessionID 
     * @param {number} viewUpdateID 
     * @param {File} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewApi
     */
    public createViewUpdate(viewSessionID: string, viewUpdateID: number, body?: File, options?: AxiosRequestConfig) {
        return ViewApiFp(this.configuration).createViewUpdate(viewSessionID, viewUpdateID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the view object and metadata associated with a specific view.
     * @param {string} viewSessionID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewApi
     */
    public getViewSession(viewSessionID: string, options?: AxiosRequestConfig) {
        return ViewApiFp(this.configuration).getViewSession(viewSessionID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all View sessions.
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewApi
     */
    public listViewSessions(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return ViewApiFp(this.configuration).listViewSessions(pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}



