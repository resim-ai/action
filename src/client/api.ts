/* tslint:disable */
/* eslint-disable */
/**
 * ReRun API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddMetricsDataToMetric201Response
 */
export interface AddMetricsDataToMetric201Response {
    /**
     * 
     * @type {string}
     * @memberof AddMetricsDataToMetric201Response
     */
    'metricID'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AddMetricsDataToMetric201Response
     */
    'metricsDataIDs'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Batch
 */
export interface Batch {
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'batchID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'buildID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'friendlyName'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Batch
     */
    'instantiatedExperienceIDs'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Batch
     */
    'instantiatedExperienceTagIDs'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'metricsBuildID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'orgID'?: string;
    /**
     * 
     * @type {BatchStatus}
     * @memberof Batch
     */
    'status'?: BatchStatus;
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'userID'?: string;
}


/**
 * 
 * @export
 * @interface BatchMetric
 */
export interface BatchMetric {
    /**
     * 
     * @type {string}
     * @memberof BatchMetric
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof BatchMetric
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BatchStatus = {
    Submitted: 'SUBMITTED',
    Running: 'RUNNING',
    Failed: 'FAILED',
    Succeeded: 'SUCCEEDED',
    Cancelled: 'CANCELLED'
} as const;

export type BatchStatus = typeof BatchStatus[keyof typeof BatchStatus];


/**
 * 
 * @export
 * @interface Branch
 */
export interface Branch {
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'branchID'?: string;
    /**
     * 
     * @type {BranchType}
     * @memberof Branch
     */
    'branchType'?: BranchType;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'orgID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'projectID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'userID'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const BranchType = {
    ChangeRequest: 'CHANGE_REQUEST',
    Main: 'MAIN',
    Release: 'RELEASE'
} as const;

export type BranchType = typeof BranchType[keyof typeof BranchType];


/**
 * 
 * @export
 * @interface Build
 */
export interface Build {
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'branchID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'buildID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'imageUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'orgID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'projectID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Build
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface CreateBatchRequest
 */
export interface CreateBatchRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateBatchRequest
     */
    'buildID'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBatchRequest
     */
    'experienceIDs'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBatchRequest
     */
    'experienceNames'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBatchRequest
     */
    'experienceTagIDs'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBatchRequest
     */
    'experienceTagNames'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof CreateBatchRequest
     */
    'metricsBuildID'?: string;
}
/**
 * 
 * @export
 * @interface CreateViewUpdate201Response
 */
export interface CreateViewUpdate201Response {
    /**
     * 
     * @type {string}
     * @memberof CreateViewUpdate201Response
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateViewUpdate201Response
     */
    'mcap'?: string;
    /**
     * A link to view the session.
     * @type {string}
     * @memberof CreateViewUpdate201Response
     */
    'view'?: string;
}
/**
 * 
 * @export
 * @interface DestroySandboxRequest
 */
export interface DestroySandboxRequest {
    /**
     * 
     * @type {string}
     * @memberof DestroySandboxRequest
     */
    'orgID'?: string;
    /**
     * 
     * @type {string}
     * @memberof DestroySandboxRequest
     */
    'userID'?: string;
}
/**
 * 
 * @export
 * @interface Experience
 */
export interface Experience {
    /**
     * 
     * @type {string}
     * @memberof Experience
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Experience
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Experience
     */
    'experienceID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Experience
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof Experience
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Experience
     */
    'orgID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Experience
     */
    'userID'?: string;
}
/**
 * 
 * @export
 * @interface ExperienceTag
 */
export interface ExperienceTag {
    /**
     * 
     * @type {string}
     * @memberof ExperienceTag
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExperienceTag
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExperienceTag
     */
    'experienceTagID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExperienceTag
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExperienceTag
     */
    'orgID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExperienceTag
     */
    'userID'?: string;
}
/**
 * 
 * @export
 * @interface GetViewSession200Response
 */
export interface GetViewSession200Response {
    /**
     * 
     * @type {Array<ViewMetadata>}
     * @memberof GetViewSession200Response
     */
    'viewMetadata'?: Array<ViewMetadata>;
    /**
     * 
     * @type {ViewObject}
     * @memberof GetViewSession200Response
     */
    'viewObject'?: ViewObject;
}
/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'buildID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'experienceID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'jobID'?: string;
    /**
     * 
     * @type {JobStatus}
     * @memberof Job
     */
    'jobStatus'?: JobStatus;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'orgID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'outputLocation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'userID'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const JobStatus = {
    Submitted: 'SUBMITTED',
    ExperienceRunning: 'EXPERIENCE_RUNNING',
    MetricsQueued: 'METRICS_QUEUED',
    MetricsRunning: 'METRICS_RUNNING',
    Failed: 'FAILED',
    Succeeded: 'SUCCEEDED',
    Cancelled: 'CANCELLED'
} as const;

export type JobStatus = typeof JobStatus[keyof typeof JobStatus];


/**
 * 
 * @export
 * @interface ListBatchMetrics200Response
 */
export interface ListBatchMetrics200Response {
    /**
     * 
     * @type {Array<BatchMetric>}
     * @memberof ListBatchMetrics200Response
     */
    'batchMetrics'?: Array<BatchMetric>;
}
/**
 * 
 * @export
 * @interface ListBatches200Response
 */
export interface ListBatches200Response {
    /**
     * 
     * @type {Array<Batch>}
     * @memberof ListBatches200Response
     */
    'batches'?: Array<Batch>;
    /**
     * 
     * @type {string}
     * @memberof ListBatches200Response
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListBranchesForProject200Response
 */
export interface ListBranchesForProject200Response {
    /**
     * 
     * @type {Array<Branch>}
     * @memberof ListBranchesForProject200Response
     */
    'branches'?: Array<Branch>;
    /**
     * 
     * @type {string}
     * @memberof ListBranchesForProject200Response
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListBuilds200Response
 */
export interface ListBuilds200Response {
    /**
     * 
     * @type {Array<Build>}
     * @memberof ListBuilds200Response
     */
    'builds'?: Array<Build>;
    /**
     * 
     * @type {string}
     * @memberof ListBuilds200Response
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListExperienceTags200Response
 */
export interface ListExperienceTags200Response {
    /**
     * 
     * @type {Array<ExperienceTag>}
     * @memberof ListExperienceTags200Response
     */
    'experienceTags'?: Array<ExperienceTag>;
    /**
     * 
     * @type {string}
     * @memberof ListExperienceTags200Response
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListExperiencesWithExperienceTag200Response
 */
export interface ListExperiencesWithExperienceTag200Response {
    /**
     * 
     * @type {Array<Experience>}
     * @memberof ListExperiencesWithExperienceTag200Response
     */
    'experiences'?: Array<Experience>;
    /**
     * 
     * @type {string}
     * @memberof ListExperiencesWithExperienceTag200Response
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListJobs200Response
 */
export interface ListJobs200Response {
    /**
     * 
     * @type {Array<Job>}
     * @memberof ListJobs200Response
     */
    'jobs'?: Array<Job>;
    /**
     * 
     * @type {string}
     * @memberof ListJobs200Response
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListLogsForJob200Response
 */
export interface ListLogsForJob200Response {
    /**
     * 
     * @type {Array<Log>}
     * @memberof ListLogsForJob200Response
     */
    'logs'?: Array<Log>;
    /**
     * 
     * @type {string}
     * @memberof ListLogsForJob200Response
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListMetricsBuilds200Response
 */
export interface ListMetricsBuilds200Response {
    /**
     * 
     * @type {Array<MetricsBuild>}
     * @memberof ListMetricsBuilds200Response
     */
    'metricsBuilds'?: Array<MetricsBuild>;
    /**
     * 
     * @type {string}
     * @memberof ListMetricsBuilds200Response
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListMetricsDataForJob200Response
 */
export interface ListMetricsDataForJob200Response {
    /**
     * 
     * @type {Array<MetricsData>}
     * @memberof ListMetricsDataForJob200Response
     */
    'metricsData'?: Array<MetricsData>;
    /**
     * 
     * @type {string}
     * @memberof ListMetricsDataForJob200Response
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListMetricsDataForMetricIDs200Response
 */
export interface ListMetricsDataForMetricIDs200Response {
    /**
     * 
     * @type {Array<MetricsDataAndMetricID>}
     * @memberof ListMetricsDataForMetricIDs200Response
     */
    'metricsDataAndIDs'?: Array<MetricsDataAndMetricID>;
    /**
     * 
     * @type {string}
     * @memberof ListMetricsDataForMetricIDs200Response
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListMetricsForJob200Response
 */
export interface ListMetricsForJob200Response {
    /**
     * 
     * @type {Array<Metric>}
     * @memberof ListMetricsForJob200Response
     */
    'metrics'?: Array<Metric>;
    /**
     * 
     * @type {string}
     * @memberof ListMetricsForJob200Response
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ListProjects200Response
 */
export interface ListProjects200Response {
    /**
     * 
     * @type {string}
     * @memberof ListProjects200Response
     */
    'nextPageToken'?: string;
    /**
     * 
     * @type {Array<Project>}
     * @memberof ListProjects200Response
     */
    'projects'?: Array<Project>;
}
/**
 * 
 * @export
 * @interface ListViewSessions200Response
 */
export interface ListViewSessions200Response {
    /**
     * 
     * @type {string}
     * @memberof ListViewSessions200Response
     */
    'nextPageToken'?: string;
    /**
     * 
     * @type {Array<ViewObject>}
     * @memberof ListViewSessions200Response
     */
    'viewSessions'?: Array<ViewObject>;
}
/**
 * 
 * @export
 * @interface Log
 */
export interface Log {
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'checksum'?: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'fileName'?: string;
    /**
     * 
     * @type {number}
     * @memberof Log
     */
    'fileSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'jobID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'logID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'logOutputLocation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'orgID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'userID'?: string;
}
/**
 * 
 * @export
 * @interface Metric
 */
export interface Metric {
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Metric
     */
    'dataIDs'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'fileLocation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'jobID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'metricID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'metricURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'orgID'?: string;
    /**
     * 
     * @type {MetricStatus}
     * @memberof Metric
     */
    'status'?: MetricStatus;
    /**
     * 
     * @type {MetricType}
     * @memberof Metric
     */
    'type'?: MetricType;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    'userID'?: string;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    'value'?: number | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const MetricStatus = {
    Passed: 'PASSED',
    Failed: 'FAILED',
    Raw: 'RAW',
    NotApplicable: 'NOT_APPLICABLE'
} as const;

export type MetricStatus = typeof MetricStatus[keyof typeof MetricStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const MetricType = {
    Scalar: 'SCALAR',
    Composite: 'COMPOSITE'
} as const;

export type MetricType = typeof MetricType[keyof typeof MetricType];


/**
 * 
 * @export
 * @interface MetricsBuild
 */
export interface MetricsBuild {
    /**
     * 
     * @type {string}
     * @memberof MetricsBuild
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsBuild
     */
    'imageUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsBuild
     */
    'metricsBuildID'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsBuild
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsBuild
     */
    'orgID'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsBuild
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsBuild
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface MetricsData
 */
export interface MetricsData {
    /**
     * 
     * @type {string}
     * @memberof MetricsData
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsData
     */
    'dataID'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsData
     */
    'fileLocation'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsData
     */
    'jobID'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsData
     */
    'metricsDataURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsData
     */
    'orgID'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricsData
     */
    'userID'?: string;
}
/**
 * 
 * @export
 * @interface MetricsDataAndMetricID
 */
export interface MetricsDataAndMetricID {
    /**
     * 
     * @type {string}
     * @memberof MetricsDataAndMetricID
     */
    'metricID'?: string;
    /**
     * 
     * @type {MetricsData}
     * @memberof MetricsDataAndMetricID
     */
    'metricsData'?: MetricsData;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ObjectType = {
    Frame: 'TYPE_FRAME',
    Se3: 'TYPE_SE3',
    So3: 'TYPE_SO3',
    DcurveSe3: 'TYPE_DCURVE_SE3',
    TcurveSe3: 'TYPE_TCURVE_SE3',
    Trajectory: 'TYPE_TRAJECTORY',
    FramedVector: 'TYPE_FRAMED_VECTOR'
} as const;

export type ObjectType = typeof ObjectType[keyof typeof ObjectType];


/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'orgID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'projectID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'userID'?: string;
}
/**
 * 
 * @export
 * @interface UpdateExperienceRequest
 */
export interface UpdateExperienceRequest {
    /**
     * 
     * @type {Experience}
     * @memberof UpdateExperienceRequest
     */
    'experience'?: Experience;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateExperienceRequest
     */
    'updateMask'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateExperienceTagRequest
 */
export interface UpdateExperienceTagRequest {
    /**
     * 
     * @type {ExperienceTag}
     * @memberof UpdateExperienceTagRequest
     */
    'experienceTag'?: ExperienceTag;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateExperienceTagRequest
     */
    'updateMask'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateProjectRequest
 */
export interface UpdateProjectRequest {
    /**
     * 
     * @type {Project}
     * @memberof UpdateProjectRequest
     */
    'project'?: Project;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateProjectRequest
     */
    'updateMask'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ViewMetadata
 */
export interface ViewMetadata {
    /**
     * 
     * @type {string}
     * @memberof ViewMetadata
     */
    'fileName'?: string;
    /**
     * 
     * @type {number}
     * @memberof ViewMetadata
     */
    'lineNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof ViewMetadata
     */
    'objectName'?: string;
    /**
     * 
     * @type {ObjectType}
     * @memberof ViewMetadata
     */
    'objectType'?: ObjectType;
}


/**
 * 
 * @export
 * @interface ViewObject
 */
export interface ViewObject {
    /**
     * 
     * @type {string}
     * @memberof ViewObject
     */
    'friendlyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewObject
     */
    'mcapURL'?: string;
    /**
     * 
     * @type {number}
     * @memberof ViewObject
     */
    'objectCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ViewObject
     */
    'orgID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewObject
     */
    'userID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewObject
     */
    'viewSessionID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewObject
     */
    'viewTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewObject
     */
    'viewURL'?: string;
}

/**
 * BatchesApi - axios parameter creator
 * @export
 */
export const BatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds metrics data (IDs) to a given metric
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetricsDataToMetric: async (batchID: string, jobID: string, metricID: string, requestBody?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('addMetricsDataToMetric', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('addMetricsDataToMetric', 'jobID', jobID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('addMetricsDataToMetric', 'metricID', metricID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/metrics/{metricID}/metricsData`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels a batch.
         * @param {string} batchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelBatch: async (batchID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('cancelBatch', 'batchID', batchID)
            const localVarPath = `/batches/{batchID}/:cancel`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a batch.  ID should be omitted and will be returned in the response.
         * @param {CreateBatchRequest} [createBatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch: async (createBatchRequest?: CreateBatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a log.  ID should be omitted and will be returned in the response.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Log} [log] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLog: async (batchID: string, jobID: string, log?: Log, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('createLog', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('createLog', 'jobID', jobID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/logs`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(log, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a metric. ID and location should be omitted and will be returned in the response.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Metric} [metric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetric: async (batchID: string, jobID: string, metric?: Metric, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('createMetric', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('createMetric', 'jobID', jobID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/metrics`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metric, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new metrics data associated with a job
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {MetricsData} [metricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricsData: async (batchID: string, jobID: string, metricsData?: MetricsData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('createMetricsData', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('createMetricsData', 'jobID', jobID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/metricsData`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metricsData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a log.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLog: async (batchID: string, jobID: string, logID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('deleteLog', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('deleteLog', 'jobID', jobID)
            // verify required parameter 'logID' is not null or undefined
            assertParamExists('deleteLog', 'logID', logID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/logs/{logID}`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"logID"}}`, encodeURIComponent(String(logID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a batch.
         * @param {string} batchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatch: async (batchID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('getBatch', 'batchID', batchID)
            const localVarPath = `/batches/{batchID}`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the given job.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob: async (batchID: string, jobID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('getJob', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('getJob', 'jobID', jobID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an individual log file
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLog: async (batchID: string, jobID: string, logID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('getLog', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('getLog', 'jobID', jobID)
            // verify required parameter 'logID' is not null or undefined
            assertParamExists('getLog', 'logID', logID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/logs/{logID}`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"logID"}}`, encodeURIComponent(String(logID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the batch-level metrics. Currently the average values for scalar metrics across the jobs.
         * @param {string} batchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetrics: async (batchID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listBatchMetrics', 'batchID', batchID)
            const localVarPath = `/batches/{batchID}/metrics`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the batches.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatches: async (pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the batches for a build.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {string} buildID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchesForBuild: async (projectID: string, branchID: string, buildID: string, pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBatchesForBuild', 'projectID', projectID)
            // verify required parameter 'branchID' is not null or undefined
            assertParamExists('listBatchesForBuild', 'branchID', branchID)
            // verify required parameter 'buildID' is not null or undefined
            assertParamExists('listBatchesForBuild', 'buildID', buildID)
            const localVarPath = `/projects/{projectID}/branches/{branchID}/builds/{buildID}/batches`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"branchID"}}`, encodeURIComponent(String(branchID)))
                .replace(`{${"buildID"}}`, encodeURIComponent(String(buildID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the jobs in the given batch.
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs: async (batchID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listJobs', 'batchID', batchID)
            const localVarPath = `/batches/{batchID}/jobs`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the logs associated with a given job
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogsForJob: async (batchID: string, jobID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listLogsForJob', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listLogsForJob', 'jobID', jobID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/logs`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metricsdata associated with a given job ID
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForJob: async (batchID: string, jobID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsDataForJob', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsDataForJob', 'jobID', jobID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/metricsData`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metrics data associated with given metric ID(s)
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForMetricIDs: async (batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsDataForMetricIDs', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsDataForMetricIDs', 'jobID', jobID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('listMetricsDataForMetricIDs', 'metricID', metricID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/metrics/{metricID}/metricsData`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the metrics data associated with given metrics data IDs
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForMetricsDataIDs: async (batchID: string, jobID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsDataForMetricsDataIDs', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsDataForMetricsDataIDs', 'jobID', jobID)
            // verify required parameter 'metricsDataID' is not null or undefined
            assertParamExists('listMetricsDataForMetricsDataIDs', 'metricsDataID', metricsDataID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/metricsData/{metricsDataID}`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"metricsDataID"}}`, encodeURIComponent(String(metricsDataID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the metrics for a given job. Does not return associated data.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsForJob: async (batchID: string, jobID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsForJob', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsForJob', 'jobID', jobID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/metrics`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the metrics associated with given metric IDs
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsForMetricIDs: async (batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsForMetricIDs', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsForMetricIDs', 'jobID', jobID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('listMetricsForMetricIDs', 'metricID', metricID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/metrics/{metricID}`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatchesApi - functional programming interface
 * @export
 */
export const BatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BatchesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds metrics data (IDs) to a given metric
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMetricsDataToMetric(batchID: string, jobID: string, metricID: string, requestBody?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddMetricsDataToMetric201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMetricsDataToMetric(batchID, jobID, metricID, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancels a batch.
         * @param {string} batchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelBatch(batchID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelBatch(batchID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a batch.  ID should be omitted and will be returned in the response.
         * @param {CreateBatchRequest} [createBatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatch(createBatchRequest?: CreateBatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatch(createBatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a log.  ID should be omitted and will be returned in the response.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Log} [log] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLog(batchID: string, jobID: string, log?: Log, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Log>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLog(batchID, jobID, log, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a metric. ID and location should be omitted and will be returned in the response.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Metric} [metric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMetric(batchID: string, jobID: string, metric?: Metric, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMetric(batchID, jobID, metric, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates new metrics data associated with a job
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {MetricsData} [metricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMetricsData(batchID: string, jobID: string, metricsData?: MetricsData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMetricsData(batchID, jobID, metricsData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a log.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLog(batchID: string, jobID: string, logID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLog(batchID, jobID, logID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a batch.
         * @param {string} batchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatch(batchID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatch(batchID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the given job.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJob(batchID: string, jobID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJob(batchID, jobID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an individual log file
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLog(batchID: string, jobID: string, logID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Log>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLog(batchID, jobID, logID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the batch-level metrics. Currently the average values for scalar metrics across the jobs.
         * @param {string} batchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchMetrics(batchID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatchMetrics200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchMetrics(batchID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the batches.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatches(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatches200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatches(pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the batches for a build.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {string} buildID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchesForBuild(projectID: string, branchID: string, buildID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatches200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchesForBuild(projectID, branchID, buildID, pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the jobs in the given batch.
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobs(batchID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListJobs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobs(batchID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the logs associated with a given job
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLogsForJob(batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListLogsForJob200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLogsForJob(batchID, jobID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the metricsdata associated with a given job ID
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsDataForJob(batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMetricsDataForJob200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsDataForJob(batchID, jobID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the metrics data associated with given metric ID(s)
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsDataForMetricIDs(batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMetricsDataForMetricIDs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsDataForMetricIDs(batchID, jobID, metricID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the metrics data associated with given metrics data IDs
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsDataForMetricsDataIDs(batchID: string, jobID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMetricsDataForJob200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsDataForMetricsDataIDs(batchID, jobID, metricsDataID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the metrics for a given job. Does not return associated data.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsForJob(batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMetricsForJob200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsForJob(batchID, jobID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the metrics associated with given metric IDs
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsForMetricIDs(batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMetricsForJob200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsForMetricIDs(batchID, jobID, metricID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BatchesApi - factory interface
 * @export
 */
export const BatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BatchesApiFp(configuration)
    return {
        /**
         * Adds metrics data (IDs) to a given metric
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetricsDataToMetric(batchID: string, jobID: string, metricID: string, requestBody?: Array<string>, options?: any): AxiosPromise<AddMetricsDataToMetric201Response> {
            return localVarFp.addMetricsDataToMetric(batchID, jobID, metricID, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels a batch.
         * @param {string} batchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelBatch(batchID: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelBatch(batchID, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a batch.  ID should be omitted and will be returned in the response.
         * @param {CreateBatchRequest} [createBatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch(createBatchRequest?: CreateBatchRequest, options?: any): AxiosPromise<Batch> {
            return localVarFp.createBatch(createBatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a log.  ID should be omitted and will be returned in the response.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Log} [log] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLog(batchID: string, jobID: string, log?: Log, options?: any): AxiosPromise<Log> {
            return localVarFp.createLog(batchID, jobID, log, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a metric. ID and location should be omitted and will be returned in the response.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Metric} [metric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetric(batchID: string, jobID: string, metric?: Metric, options?: any): AxiosPromise<Metric> {
            return localVarFp.createMetric(batchID, jobID, metric, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates new metrics data associated with a job
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {MetricsData} [metricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricsData(batchID: string, jobID: string, metricsData?: MetricsData, options?: any): AxiosPromise<MetricsData> {
            return localVarFp.createMetricsData(batchID, jobID, metricsData, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a log.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLog(batchID: string, jobID: string, logID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteLog(batchID, jobID, logID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a batch.
         * @param {string} batchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatch(batchID: string, options?: any): AxiosPromise<Batch> {
            return localVarFp.getBatch(batchID, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the given job.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(batchID: string, jobID: string, options?: any): AxiosPromise<Job> {
            return localVarFp.getJob(batchID, jobID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an individual log file
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} logID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLog(batchID: string, jobID: string, logID: string, options?: any): AxiosPromise<Log> {
            return localVarFp.getLog(batchID, jobID, logID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the batch-level metrics. Currently the average values for scalar metrics across the jobs.
         * @param {string} batchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchMetrics(batchID: string, options?: any): AxiosPromise<ListBatchMetrics200Response> {
            return localVarFp.listBatchMetrics(batchID, options).then((request) => request(axios, basePath));
        },
        /**
         * List the batches.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatches(pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListBatches200Response> {
            return localVarFp.listBatches(pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the batches for a build.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {string} buildID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchesForBuild(projectID: string, branchID: string, buildID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListBatches200Response> {
            return localVarFp.listBatchesForBuild(projectID, branchID, buildID, pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * List the jobs in the given batch.
         * @param {string} batchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(batchID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListJobs200Response> {
            return localVarFp.listJobs(batchID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * List the logs associated with a given job
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogsForJob(batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListLogsForJob200Response> {
            return localVarFp.listLogsForJob(batchID, jobID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the metricsdata associated with a given job ID
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForJob(batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListMetricsDataForJob200Response> {
            return localVarFp.listMetricsDataForJob(batchID, jobID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the metrics data associated with given metric ID(s)
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForMetricIDs(batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListMetricsDataForMetricIDs200Response> {
            return localVarFp.listMetricsDataForMetricIDs(batchID, jobID, metricID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the metrics data associated with given metrics data IDs
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForMetricsDataIDs(batchID: string, jobID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListMetricsDataForJob200Response> {
            return localVarFp.listMetricsDataForMetricsDataIDs(batchID, jobID, metricsDataID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the metrics for a given job. Does not return associated data.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsForJob(batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListMetricsForJob200Response> {
            return localVarFp.listMetricsForJob(batchID, jobID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the metrics associated with given metric IDs
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsForMetricIDs(batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListMetricsForJob200Response> {
            return localVarFp.listMetricsForMetricIDs(batchID, jobID, metricID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BatchesApi - object-oriented interface
 * @export
 * @class BatchesApi
 * @extends {BaseAPI}
 */
export class BatchesApi extends BaseAPI {
    /**
     * Adds metrics data (IDs) to a given metric
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {string} metricID 
     * @param {Array<string>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public addMetricsDataToMetric(batchID: string, jobID: string, metricID: string, requestBody?: Array<string>, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).addMetricsDataToMetric(batchID, jobID, metricID, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels a batch.
     * @param {string} batchID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public cancelBatch(batchID: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).cancelBatch(batchID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a batch.  ID should be omitted and will be returned in the response.
     * @param {CreateBatchRequest} [createBatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createBatch(createBatchRequest?: CreateBatchRequest, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createBatch(createBatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a log.  ID should be omitted and will be returned in the response.
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {Log} [log] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createLog(batchID: string, jobID: string, log?: Log, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createLog(batchID, jobID, log, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a metric. ID and location should be omitted and will be returned in the response.
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {Metric} [metric] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createMetric(batchID: string, jobID: string, metric?: Metric, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createMetric(batchID, jobID, metric, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates new metrics data associated with a job
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {MetricsData} [metricsData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createMetricsData(batchID: string, jobID: string, metricsData?: MetricsData, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createMetricsData(batchID, jobID, metricsData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a log.
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {string} logID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public deleteLog(batchID: string, jobID: string, logID: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).deleteLog(batchID, jobID, logID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a batch.
     * @param {string} batchID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public getBatch(batchID: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).getBatch(batchID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the given job.
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public getJob(batchID: string, jobID: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).getJob(batchID, jobID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an individual log file
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {string} logID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public getLog(batchID: string, jobID: string, logID: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).getLog(batchID, jobID, logID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the batch-level metrics. Currently the average values for scalar metrics across the jobs.
     * @param {string} batchID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listBatchMetrics(batchID: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listBatchMetrics(batchID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the batches.
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listBatches(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listBatches(pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the batches for a build.
     * @param {string} projectID 
     * @param {string} branchID 
     * @param {string} buildID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listBatchesForBuild(projectID: string, branchID: string, buildID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listBatchesForBuild(projectID, branchID, buildID, pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the jobs in the given batch.
     * @param {string} batchID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listJobs(batchID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listJobs(batchID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the logs associated with a given job
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listLogsForJob(batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listLogsForJob(batchID, jobID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the metricsdata associated with a given job ID
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listMetricsDataForJob(batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listMetricsDataForJob(batchID, jobID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the metrics data associated with given metric ID(s)
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {Array<string>} metricID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listMetricsDataForMetricIDs(batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listMetricsDataForMetricIDs(batchID, jobID, metricID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the metrics data associated with given metrics data IDs
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {Array<string>} metricsDataID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listMetricsDataForMetricsDataIDs(batchID: string, jobID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listMetricsDataForMetricsDataIDs(batchID, jobID, metricsDataID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the metrics for a given job. Does not return associated data.
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listMetricsForJob(batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listMetricsForJob(batchID, jobID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the metrics associated with given metric IDs
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {Array<string>} metricID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public listMetricsForMetricIDs(batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).listMetricsForMetricIDs(batchID, jobID, metricID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BuildsApi - axios parameter creator
 * @export
 */
export const BuildsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a build.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {Build} [build] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuildForBranch: async (projectID: string, branchID: string, build?: Build, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createBuildForBranch', 'projectID', projectID)
            // verify required parameter 'branchID' is not null or undefined
            assertParamExists('createBuildForBranch', 'branchID', branchID)
            const localVarPath = `/projects/{projectID}/branches/{branchID}/builds`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"branchID"}}`, encodeURIComponent(String(branchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(build, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a build.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuildForBranch: async (projectID: string, branchID: string, buildID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('deleteBuildForBranch', 'projectID', projectID)
            // verify required parameter 'branchID' is not null or undefined
            assertParamExists('deleteBuildForBranch', 'branchID', branchID)
            // verify required parameter 'buildID' is not null or undefined
            assertParamExists('deleteBuildForBranch', 'buildID', buildID)
            const localVarPath = `/projects/{projectID}/branches/{branchID}/builds/{buildID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"branchID"}}`, encodeURIComponent(String(branchID)))
                .replace(`{${"buildID"}}`, encodeURIComponent(String(buildID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific build.
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuild: async (buildID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'buildID' is not null or undefined
            assertParamExists('getBuild', 'buildID', buildID)
            const localVarPath = `/builds/{buildID}`
                .replace(`{${"buildID"}}`, encodeURIComponent(String(buildID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific build for a branch.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuildForBranch: async (projectID: string, branchID: string, buildID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getBuildForBranch', 'projectID', projectID)
            // verify required parameter 'branchID' is not null or undefined
            assertParamExists('getBuildForBranch', 'branchID', branchID)
            // verify required parameter 'buildID' is not null or undefined
            assertParamExists('getBuildForBranch', 'buildID', buildID)
            const localVarPath = `/projects/{projectID}/branches/{branchID}/builds/{buildID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"branchID"}}`, encodeURIComponent(String(branchID)))
                .replace(`{${"buildID"}}`, encodeURIComponent(String(buildID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of builds.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilds: async (pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/builds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of builds for a branch.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuildsForBranch: async (projectID: string, branchID: string, pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBuildsForBranch', 'projectID', projectID)
            // verify required parameter 'branchID' is not null or undefined
            assertParamExists('listBuildsForBranch', 'branchID', branchID)
            const localVarPath = `/projects/{projectID}/branches/{branchID}/builds`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"branchID"}}`, encodeURIComponent(String(branchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BuildsApi - functional programming interface
 * @export
 */
export const BuildsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BuildsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a build.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {Build} [build] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBuildForBranch(projectID: string, branchID: string, build?: Build, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBuildForBranch(projectID, branchID, build, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a build.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBuildForBranch(projectID: string, branchID: string, buildID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBuildForBranch(projectID, branchID, buildID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific build.
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBuild(buildID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBuild(buildID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific build for a branch.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBuildForBranch(projectID: string, branchID: string, buildID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildForBranch(projectID, branchID, buildID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of builds.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBuilds(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBuilds200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBuilds(pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of builds for a branch.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBuildsForBranch(projectID: string, branchID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBuilds200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBuildsForBranch(projectID, branchID, pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BuildsApi - factory interface
 * @export
 */
export const BuildsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BuildsApiFp(configuration)
    return {
        /**
         * Adds a build.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {Build} [build] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuildForBranch(projectID: string, branchID: string, build?: Build, options?: any): AxiosPromise<Build> {
            return localVarFp.createBuildForBranch(projectID, branchID, build, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a build.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuildForBranch(projectID: string, branchID: string, buildID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBuildForBranch(projectID, branchID, buildID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific build.
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuild(buildID: string, options?: any): AxiosPromise<Build> {
            return localVarFp.getBuild(buildID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific build for a branch.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {string} buildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuildForBranch(projectID: string, branchID: string, buildID: string, options?: any): AxiosPromise<Build> {
            return localVarFp.getBuildForBranch(projectID, branchID, buildID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of builds.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilds(pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListBuilds200Response> {
            return localVarFp.listBuilds(pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of builds for a branch.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuildsForBranch(projectID: string, branchID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListBuilds200Response> {
            return localVarFp.listBuildsForBranch(projectID, branchID, pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BuildsApi - object-oriented interface
 * @export
 * @class BuildsApi
 * @extends {BaseAPI}
 */
export class BuildsApi extends BaseAPI {
    /**
     * Adds a build.  ID should be omitted and will be returned in the response.
     * @param {string} projectID 
     * @param {string} branchID 
     * @param {Build} [build] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildsApi
     */
    public createBuildForBranch(projectID: string, branchID: string, build?: Build, options?: AxiosRequestConfig) {
        return BuildsApiFp(this.configuration).createBuildForBranch(projectID, branchID, build, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a build.
     * @param {string} projectID 
     * @param {string} branchID 
     * @param {string} buildID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildsApi
     */
    public deleteBuildForBranch(projectID: string, branchID: string, buildID: string, options?: AxiosRequestConfig) {
        return BuildsApiFp(this.configuration).deleteBuildForBranch(projectID, branchID, buildID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific build.
     * @param {string} buildID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildsApi
     */
    public getBuild(buildID: string, options?: AxiosRequestConfig) {
        return BuildsApiFp(this.configuration).getBuild(buildID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific build for a branch.
     * @param {string} projectID 
     * @param {string} branchID 
     * @param {string} buildID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildsApi
     */
    public getBuildForBranch(projectID: string, branchID: string, buildID: string, options?: AxiosRequestConfig) {
        return BuildsApiFp(this.configuration).getBuildForBranch(projectID, branchID, buildID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of builds.
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildsApi
     */
    public listBuilds(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return BuildsApiFp(this.configuration).listBuilds(pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of builds for a branch.
     * @param {string} projectID 
     * @param {string} branchID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildsApi
     */
    public listBuildsForBranch(projectID: string, branchID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return BuildsApiFp(this.configuration).listBuildsForBranch(projectID, branchID, pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExperienceTagsApi - axios parameter creator
 * @export
 */
export const ExperienceTagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds the given experience tag to the given experience.
         * @param {string} experienceTagID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExperienceTagToExperience: async (experienceTagID: string, experienceID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceTagID' is not null or undefined
            assertParamExists('addExperienceTagToExperience', 'experienceTagID', experienceTagID)
            // verify required parameter 'experienceID' is not null or undefined
            assertParamExists('addExperienceTagToExperience', 'experienceID', experienceID)
            const localVarPath = `/experienceTags/{experienceTagID}/experiences/{experienceID}`
                .replace(`{${"experienceTagID"}}`, encodeURIComponent(String(experienceTagID)))
                .replace(`{${"experienceID"}}`, encodeURIComponent(String(experienceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds an experience tag.  ID should be omitted and will be included in the response.
         * @param {ExperienceTag} [experienceTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperienceTag: async (experienceTag?: ExperienceTag, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/experienceTags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(experienceTag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an experience tag.
         * @param {string} experienceTagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperienceTag: async (experienceTagID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceTagID' is not null or undefined
            assertParamExists('deleteExperienceTag', 'experienceTagID', experienceTagID)
            const localVarPath = `/experienceTags/{experienceTagID}`
                .replace(`{${"experienceTagID"}}`, encodeURIComponent(String(experienceTagID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific experience tag.
         * @param {string} experienceTagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperienceTag: async (experienceTagID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceTagID' is not null or undefined
            assertParamExists('getExperienceTag', 'experienceTagID', experienceTagID)
            const localVarPath = `/experienceTags/{experienceTagID}`
                .replace(`{${"experienceTagID"}}`, encodeURIComponent(String(experienceTagID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all experience tags.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperienceTags: async (pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/experienceTags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all experiences with the given experience tag.
         * @param {string} experienceTagID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiencesWithExperienceTag: async (experienceTagID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceTagID' is not null or undefined
            assertParamExists('listExperiencesWithExperienceTag', 'experienceTagID', experienceTagID)
            const localVarPath = `/experienceTags/{experienceTagID}/experiences`
                .replace(`{${"experienceTagID"}}`, encodeURIComponent(String(experienceTagID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the given experience tag from the given experience.
         * @param {string} experienceTagID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeExperienceTagFromExperience: async (experienceTagID: string, experienceID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceTagID' is not null or undefined
            assertParamExists('removeExperienceTagFromExperience', 'experienceTagID', experienceTagID)
            // verify required parameter 'experienceID' is not null or undefined
            assertParamExists('removeExperienceTagFromExperience', 'experienceID', experienceID)
            const localVarPath = `/experienceTags/{experienceTagID}/experiences/{experienceID}`
                .replace(`{${"experienceTagID"}}`, encodeURIComponent(String(experienceTagID)))
                .replace(`{${"experienceID"}}`, encodeURIComponent(String(experienceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the experience tag.  Experience membership cannot be changed with this method.
         * @param {string} experienceTagID 
         * @param {UpdateExperienceTagRequest} [updateExperienceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperienceTag: async (experienceTagID: string, updateExperienceTagRequest?: UpdateExperienceTagRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceTagID' is not null or undefined
            assertParamExists('updateExperienceTag', 'experienceTagID', experienceTagID)
            const localVarPath = `/experienceTags/{experienceTagID}`
                .replace(`{${"experienceTagID"}}`, encodeURIComponent(String(experienceTagID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experienceTags:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateExperienceTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExperienceTagsApi - functional programming interface
 * @export
 */
export const ExperienceTagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExperienceTagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds the given experience tag to the given experience.
         * @param {string} experienceTagID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addExperienceTagToExperience(experienceTagID: string, experienceID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addExperienceTagToExperience(experienceTagID, experienceID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds an experience tag.  ID should be omitted and will be included in the response.
         * @param {ExperienceTag} [experienceTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExperienceTag(experienceTag?: ExperienceTag, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperienceTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExperienceTag(experienceTag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an experience tag.
         * @param {string} experienceTagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExperienceTag(experienceTagID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExperienceTag(experienceTagID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific experience tag.
         * @param {string} experienceTagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperienceTag(experienceTagID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperienceTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperienceTag(experienceTagID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all experience tags.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExperienceTags(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListExperienceTags200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExperienceTags(pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all experiences with the given experience tag.
         * @param {string} experienceTagID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExperiencesWithExperienceTag(experienceTagID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListExperiencesWithExperienceTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExperiencesWithExperienceTag(experienceTagID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the given experience tag from the given experience.
         * @param {string} experienceTagID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeExperienceTagFromExperience(experienceTagID: string, experienceID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeExperienceTagFromExperience(experienceTagID, experienceID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the experience tag.  Experience membership cannot be changed with this method.
         * @param {string} experienceTagID 
         * @param {UpdateExperienceTagRequest} [updateExperienceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExperienceTag(experienceTagID: string, updateExperienceTagRequest?: UpdateExperienceTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperienceTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExperienceTag(experienceTagID, updateExperienceTagRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExperienceTagsApi - factory interface
 * @export
 */
export const ExperienceTagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExperienceTagsApiFp(configuration)
    return {
        /**
         * Adds the given experience tag to the given experience.
         * @param {string} experienceTagID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExperienceTagToExperience(experienceTagID: string, experienceID: string, options?: any): AxiosPromise<void> {
            return localVarFp.addExperienceTagToExperience(experienceTagID, experienceID, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds an experience tag.  ID should be omitted and will be included in the response.
         * @param {ExperienceTag} [experienceTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperienceTag(experienceTag?: ExperienceTag, options?: any): AxiosPromise<ExperienceTag> {
            return localVarFp.createExperienceTag(experienceTag, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an experience tag.
         * @param {string} experienceTagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperienceTag(experienceTagID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteExperienceTag(experienceTagID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific experience tag.
         * @param {string} experienceTagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperienceTag(experienceTagID: string, options?: any): AxiosPromise<ExperienceTag> {
            return localVarFp.getExperienceTag(experienceTagID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all experience tags.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperienceTags(pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListExperienceTags200Response> {
            return localVarFp.listExperienceTags(pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all experiences with the given experience tag.
         * @param {string} experienceTagID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiencesWithExperienceTag(experienceTagID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListExperiencesWithExperienceTag200Response> {
            return localVarFp.listExperiencesWithExperienceTag(experienceTagID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the given experience tag from the given experience.
         * @param {string} experienceTagID 
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeExperienceTagFromExperience(experienceTagID: string, experienceID: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeExperienceTagFromExperience(experienceTagID, experienceID, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the experience tag.  Experience membership cannot be changed with this method.
         * @param {string} experienceTagID 
         * @param {UpdateExperienceTagRequest} [updateExperienceTagRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperienceTag(experienceTagID: string, updateExperienceTagRequest?: UpdateExperienceTagRequest, options?: any): AxiosPromise<ExperienceTag> {
            return localVarFp.updateExperienceTag(experienceTagID, updateExperienceTagRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExperienceTagsApi - object-oriented interface
 * @export
 * @class ExperienceTagsApi
 * @extends {BaseAPI}
 */
export class ExperienceTagsApi extends BaseAPI {
    /**
     * Adds the given experience tag to the given experience.
     * @param {string} experienceTagID 
     * @param {string} experienceID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTagsApi
     */
    public addExperienceTagToExperience(experienceTagID: string, experienceID: string, options?: AxiosRequestConfig) {
        return ExperienceTagsApiFp(this.configuration).addExperienceTagToExperience(experienceTagID, experienceID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds an experience tag.  ID should be omitted and will be included in the response.
     * @param {ExperienceTag} [experienceTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTagsApi
     */
    public createExperienceTag(experienceTag?: ExperienceTag, options?: AxiosRequestConfig) {
        return ExperienceTagsApiFp(this.configuration).createExperienceTag(experienceTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an experience tag.
     * @param {string} experienceTagID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTagsApi
     */
    public deleteExperienceTag(experienceTagID: string, options?: AxiosRequestConfig) {
        return ExperienceTagsApiFp(this.configuration).deleteExperienceTag(experienceTagID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific experience tag.
     * @param {string} experienceTagID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTagsApi
     */
    public getExperienceTag(experienceTagID: string, options?: AxiosRequestConfig) {
        return ExperienceTagsApiFp(this.configuration).getExperienceTag(experienceTagID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all experience tags.
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTagsApi
     */
    public listExperienceTags(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return ExperienceTagsApiFp(this.configuration).listExperienceTags(pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all experiences with the given experience tag.
     * @param {string} experienceTagID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTagsApi
     */
    public listExperiencesWithExperienceTag(experienceTagID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return ExperienceTagsApiFp(this.configuration).listExperiencesWithExperienceTag(experienceTagID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the given experience tag from the given experience.
     * @param {string} experienceTagID 
     * @param {string} experienceID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTagsApi
     */
    public removeExperienceTagFromExperience(experienceTagID: string, experienceID: string, options?: AxiosRequestConfig) {
        return ExperienceTagsApiFp(this.configuration).removeExperienceTagFromExperience(experienceTagID, experienceID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the experience tag.  Experience membership cannot be changed with this method.
     * @param {string} experienceTagID 
     * @param {UpdateExperienceTagRequest} [updateExperienceTagRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTagsApi
     */
    public updateExperienceTag(experienceTagID: string, updateExperienceTagRequest?: UpdateExperienceTagRequest, options?: AxiosRequestConfig) {
        return ExperienceTagsApiFp(this.configuration).updateExperienceTag(experienceTagID, updateExperienceTagRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExperiencesApi - axios parameter creator
 * @export
 */
export const ExperiencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds an experience.  ID should be omitted and will be returned in the response.
         * @param {Experience} [experience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperience: async (experience?: Experience, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/experiences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(experience, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an experience.
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperience: async (experienceID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceID' is not null or undefined
            assertParamExists('deleteExperience', 'experienceID', experienceID)
            const localVarPath = `/experiences/{experienceID}`
                .replace(`{${"experienceID"}}`, encodeURIComponent(String(experienceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific experience.
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperience: async (experienceID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceID' is not null or undefined
            assertParamExists('getExperience', 'experienceID', experienceID)
            const localVarPath = `/experiences/{experienceID}`
                .replace(`{${"experienceID"}}`, encodeURIComponent(String(experienceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of experience tags associated with a given experience.
         * @param {string} experienceID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperienceTagsForExperience: async (experienceID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceID' is not null or undefined
            assertParamExists('listExperienceTagsForExperience', 'experienceID', experienceID)
            const localVarPath = `/experiences/{experienceID}/experienceTags`
                .replace(`{${"experienceID"}}`, encodeURIComponent(String(experienceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of experiences.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiences: async (pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/experiences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the experience.
         * @param {string} experienceID 
         * @param {UpdateExperienceRequest} [updateExperienceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperience: async (experienceID: string, updateExperienceRequest?: UpdateExperienceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceID' is not null or undefined
            assertParamExists('updateExperience', 'experienceID', experienceID)
            const localVarPath = `/experiences/{experienceID}`
                .replace(`{${"experienceID"}}`, encodeURIComponent(String(experienceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["experiences:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateExperienceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExperiencesApi - functional programming interface
 * @export
 */
export const ExperiencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExperiencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds an experience.  ID should be omitted and will be returned in the response.
         * @param {Experience} [experience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExperience(experience?: Experience, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experience>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExperience(experience, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an experience.
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExperience(experienceID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExperience(experienceID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific experience.
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperience(experienceID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experience>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperience(experienceID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of experience tags associated with a given experience.
         * @param {string} experienceID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExperienceTagsForExperience(experienceID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListExperienceTags200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExperienceTagsForExperience(experienceID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of experiences.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExperiences(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListExperiencesWithExperienceTag200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExperiences(pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the experience.
         * @param {string} experienceID 
         * @param {UpdateExperienceRequest} [updateExperienceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExperience(experienceID: string, updateExperienceRequest?: UpdateExperienceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experience>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExperience(experienceID, updateExperienceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExperiencesApi - factory interface
 * @export
 */
export const ExperiencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExperiencesApiFp(configuration)
    return {
        /**
         * Adds an experience.  ID should be omitted and will be returned in the response.
         * @param {Experience} [experience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperience(experience?: Experience, options?: any): AxiosPromise<Experience> {
            return localVarFp.createExperience(experience, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an experience.
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperience(experienceID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteExperience(experienceID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific experience.
         * @param {string} experienceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperience(experienceID: string, options?: any): AxiosPromise<Experience> {
            return localVarFp.getExperience(experienceID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of experience tags associated with a given experience.
         * @param {string} experienceID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperienceTagsForExperience(experienceID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListExperienceTags200Response> {
            return localVarFp.listExperienceTagsForExperience(experienceID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of experiences.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiences(pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListExperiencesWithExperienceTag200Response> {
            return localVarFp.listExperiences(pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the experience.
         * @param {string} experienceID 
         * @param {UpdateExperienceRequest} [updateExperienceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperience(experienceID: string, updateExperienceRequest?: UpdateExperienceRequest, options?: any): AxiosPromise<Experience> {
            return localVarFp.updateExperience(experienceID, updateExperienceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExperiencesApi - object-oriented interface
 * @export
 * @class ExperiencesApi
 * @extends {BaseAPI}
 */
export class ExperiencesApi extends BaseAPI {
    /**
     * Adds an experience.  ID should be omitted and will be returned in the response.
     * @param {Experience} [experience] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperiencesApi
     */
    public createExperience(experience?: Experience, options?: AxiosRequestConfig) {
        return ExperiencesApiFp(this.configuration).createExperience(experience, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an experience.
     * @param {string} experienceID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperiencesApi
     */
    public deleteExperience(experienceID: string, options?: AxiosRequestConfig) {
        return ExperiencesApiFp(this.configuration).deleteExperience(experienceID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific experience.
     * @param {string} experienceID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperiencesApi
     */
    public getExperience(experienceID: string, options?: AxiosRequestConfig) {
        return ExperiencesApiFp(this.configuration).getExperience(experienceID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of experience tags associated with a given experience.
     * @param {string} experienceID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperiencesApi
     */
    public listExperienceTagsForExperience(experienceID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return ExperiencesApiFp(this.configuration).listExperienceTagsForExperience(experienceID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of experiences.
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperiencesApi
     */
    public listExperiences(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return ExperiencesApiFp(this.configuration).listExperiences(pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the experience.
     * @param {string} experienceID 
     * @param {UpdateExperienceRequest} [updateExperienceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperiencesApi
     */
    public updateExperience(experienceID: string, updateExperienceRequest?: UpdateExperienceRequest, options?: AxiosRequestConfig) {
        return ExperiencesApiFp(this.configuration).updateExperience(experienceID, updateExperienceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns whether the service is healthy or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns whether the service is healthy or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async health(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.health(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Returns whether the service is healthy or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options?: any): AxiosPromise<void> {
            return localVarFp.health(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * Returns whether the service is healthy or not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public health(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).health(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds metrics data (IDs) to a given metric
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetricsDataToMetric: async (batchID: string, jobID: string, metricID: string, requestBody?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('addMetricsDataToMetric', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('addMetricsDataToMetric', 'jobID', jobID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('addMetricsDataToMetric', 'metricID', metricID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/metrics/{metricID}/metricsData`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a metric. ID and location should be omitted and will be returned in the response.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Metric} [metric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetric: async (batchID: string, jobID: string, metric?: Metric, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('createMetric', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('createMetric', 'jobID', jobID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/metrics`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metric, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new metrics data associated with a job
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {MetricsData} [metricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricsData: async (batchID: string, jobID: string, metricsData?: MetricsData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('createMetricsData', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('createMetricsData', 'jobID', jobID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/metricsData`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metricsData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metricsdata associated with a given job ID
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForJob: async (batchID: string, jobID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsDataForJob', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsDataForJob', 'jobID', jobID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/metricsData`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metrics data associated with given metric ID(s)
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForMetricIDs: async (batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsDataForMetricIDs', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsDataForMetricIDs', 'jobID', jobID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('listMetricsDataForMetricIDs', 'metricID', metricID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/metrics/{metricID}/metricsData`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the metrics data associated with given metrics data IDs
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForMetricsDataIDs: async (batchID: string, jobID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsDataForMetricsDataIDs', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsDataForMetricsDataIDs', 'jobID', jobID)
            // verify required parameter 'metricsDataID' is not null or undefined
            assertParamExists('listMetricsDataForMetricsDataIDs', 'metricsDataID', metricsDataID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/metricsData/{metricsDataID}`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"metricsDataID"}}`, encodeURIComponent(String(metricsDataID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the metrics for a given job. Does not return associated data.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsForJob: async (batchID: string, jobID: string, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsForJob', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsForJob', 'jobID', jobID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/metrics`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the metrics associated with given metric IDs
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsForMetricIDs: async (batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('listMetricsForMetricIDs', 'batchID', batchID)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('listMetricsForMetricIDs', 'jobID', jobID)
            // verify required parameter 'metricID' is not null or undefined
            assertParamExists('listMetricsForMetricIDs', 'metricID', metricID)
            const localVarPath = `/batches/{batchID}/jobs/{jobID}/metrics/{metricID}`
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)))
                .replace(`{${"metricID"}}`, encodeURIComponent(String(metricID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["batches:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds metrics data (IDs) to a given metric
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMetricsDataToMetric(batchID: string, jobID: string, metricID: string, requestBody?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddMetricsDataToMetric201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMetricsDataToMetric(batchID, jobID, metricID, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a metric. ID and location should be omitted and will be returned in the response.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Metric} [metric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMetric(batchID: string, jobID: string, metric?: Metric, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMetric(batchID, jobID, metric, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates new metrics data associated with a job
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {MetricsData} [metricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMetricsData(batchID: string, jobID: string, metricsData?: MetricsData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMetricsData(batchID, jobID, metricsData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the metricsdata associated with a given job ID
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsDataForJob(batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMetricsDataForJob200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsDataForJob(batchID, jobID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the metrics data associated with given metric ID(s)
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsDataForMetricIDs(batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMetricsDataForMetricIDs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsDataForMetricIDs(batchID, jobID, metricID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the metrics data associated with given metrics data IDs
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsDataForMetricsDataIDs(batchID: string, jobID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMetricsDataForJob200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsDataForMetricsDataIDs(batchID, jobID, metricsDataID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the metrics for a given job. Does not return associated data.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsForJob(batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMetricsForJob200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsForJob(batchID, jobID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the metrics associated with given metric IDs
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsForMetricIDs(batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMetricsForJob200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsForMetricIDs(batchID, jobID, metricID, pageSize, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * Adds metrics data (IDs) to a given metric
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {string} metricID 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetricsDataToMetric(batchID: string, jobID: string, metricID: string, requestBody?: Array<string>, options?: any): AxiosPromise<AddMetricsDataToMetric201Response> {
            return localVarFp.addMetricsDataToMetric(batchID, jobID, metricID, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a metric. ID and location should be omitted and will be returned in the response.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Metric} [metric] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetric(batchID: string, jobID: string, metric?: Metric, options?: any): AxiosPromise<Metric> {
            return localVarFp.createMetric(batchID, jobID, metric, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates new metrics data associated with a job
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {MetricsData} [metricsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricsData(batchID: string, jobID: string, metricsData?: MetricsData, options?: any): AxiosPromise<MetricsData> {
            return localVarFp.createMetricsData(batchID, jobID, metricsData, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the metricsdata associated with a given job ID
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForJob(batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListMetricsDataForJob200Response> {
            return localVarFp.listMetricsDataForJob(batchID, jobID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the metrics data associated with given metric ID(s)
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForMetricIDs(batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListMetricsDataForMetricIDs200Response> {
            return localVarFp.listMetricsDataForMetricIDs(batchID, jobID, metricID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the metrics data associated with given metrics data IDs
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricsDataID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsDataForMetricsDataIDs(batchID: string, jobID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListMetricsDataForJob200Response> {
            return localVarFp.listMetricsDataForMetricsDataIDs(batchID, jobID, metricsDataID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the metrics for a given job. Does not return associated data.
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsForJob(batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListMetricsForJob200Response> {
            return localVarFp.listMetricsForJob(batchID, jobID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the metrics associated with given metric IDs
         * @param {string} batchID 
         * @param {string} jobID 
         * @param {Array<string>} metricID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsForMetricIDs(batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: any): AxiosPromise<ListMetricsForJob200Response> {
            return localVarFp.listMetricsForMetricIDs(batchID, jobID, metricID, pageSize, pageToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * Adds metrics data (IDs) to a given metric
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {string} metricID 
     * @param {Array<string>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public addMetricsDataToMetric(batchID: string, jobID: string, metricID: string, requestBody?: Array<string>, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).addMetricsDataToMetric(batchID, jobID, metricID, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a metric. ID and location should be omitted and will be returned in the response.
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {Metric} [metric] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public createMetric(batchID: string, jobID: string, metric?: Metric, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).createMetric(batchID, jobID, metric, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates new metrics data associated with a job
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {MetricsData} [metricsData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public createMetricsData(batchID: string, jobID: string, metricsData?: MetricsData, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).createMetricsData(batchID, jobID, metricsData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the metricsdata associated with a given job ID
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listMetricsDataForJob(batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listMetricsDataForJob(batchID, jobID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the metrics data associated with given metric ID(s)
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {Array<string>} metricID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listMetricsDataForMetricIDs(batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listMetricsDataForMetricIDs(batchID, jobID, metricID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the metrics data associated with given metrics data IDs
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {Array<string>} metricsDataID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listMetricsDataForMetricsDataIDs(batchID: string, jobID: string, metricsDataID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listMetricsDataForMetricsDataIDs(batchID, jobID, metricsDataID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the metrics for a given job. Does not return associated data.
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listMetricsForJob(batchID: string, jobID: string, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listMetricsForJob(batchID, jobID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the metrics associated with given metric IDs
     * @param {string} batchID 
     * @param {string} jobID 
     * @param {Array<string>} metricID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listMetricsForMetricIDs(batchID: string, jobID: string, metricID: Array<string>, pageSize?: number, pageToken?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listMetricsForMetricIDs(batchID, jobID, metricID, pageSize, pageToken, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetricsBuildsApi - axios parameter creator
 * @export
 */
export const MetricsBuildsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a metrics build.  ID should be omitted and will be returned in the response.
         * @param {MetricsBuild} [metricsBuild] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricsBuild: async (metricsBuild?: MetricsBuild, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metricsBuilds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metricsBuild, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific metrics build.
         * @param {string} metricsBuildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsBuild: async (metricsBuildID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metricsBuildID' is not null or undefined
            assertParamExists('getMetricsBuild', 'metricsBuildID', metricsBuildID)
            const localVarPath = `/metricsBuilds/{metricsBuildID}`
                .replace(`{${"metricsBuildID"}}`, encodeURIComponent(String(metricsBuildID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of metrics builds.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsBuilds: async (pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metricsBuilds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["builds:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsBuildsApi - functional programming interface
 * @export
 */
export const MetricsBuildsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsBuildsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a metrics build.  ID should be omitted and will be returned in the response.
         * @param {MetricsBuild} [metricsBuild] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMetricsBuild(metricsBuild?: MetricsBuild, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsBuild>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMetricsBuild(metricsBuild, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific metrics build.
         * @param {string} metricsBuildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricsBuild(metricsBuildID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsBuild>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricsBuild(metricsBuildID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of metrics builds.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetricsBuilds(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMetricsBuilds200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetricsBuilds(pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsBuildsApi - factory interface
 * @export
 */
export const MetricsBuildsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsBuildsApiFp(configuration)
    return {
        /**
         * Adds a metrics build.  ID should be omitted and will be returned in the response.
         * @param {MetricsBuild} [metricsBuild] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricsBuild(metricsBuild?: MetricsBuild, options?: any): AxiosPromise<MetricsBuild> {
            return localVarFp.createMetricsBuild(metricsBuild, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific metrics build.
         * @param {string} metricsBuildID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsBuild(metricsBuildID: string, options?: any): AxiosPromise<MetricsBuild> {
            return localVarFp.getMetricsBuild(metricsBuildID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of metrics builds.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetricsBuilds(pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListMetricsBuilds200Response> {
            return localVarFp.listMetricsBuilds(pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsBuildsApi - object-oriented interface
 * @export
 * @class MetricsBuildsApi
 * @extends {BaseAPI}
 */
export class MetricsBuildsApi extends BaseAPI {
    /**
     * Adds a metrics build.  ID should be omitted and will be returned in the response.
     * @param {MetricsBuild} [metricsBuild] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsBuildsApi
     */
    public createMetricsBuild(metricsBuild?: MetricsBuild, options?: AxiosRequestConfig) {
        return MetricsBuildsApiFp(this.configuration).createMetricsBuild(metricsBuild, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific metrics build.
     * @param {string} metricsBuildID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsBuildsApi
     */
    public getMetricsBuild(metricsBuildID: string, options?: AxiosRequestConfig) {
        return MetricsBuildsApiFp(this.configuration).getMetricsBuild(metricsBuildID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of metrics builds.
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsBuildsApi
     */
    public listMetricsBuilds(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return MetricsBuildsApiFp(this.configuration).listMetricsBuilds(pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a branch for a project.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {Branch} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBranchForProject: async (projectID: string, branch?: Branch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('createBranchForProject', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}/branches`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(branch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a project.  ID should be omitted and will be returned in the response.
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (project?: Project, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(project, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a branch for a project.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranchForProject: async (projectID: string, branchID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('deleteBranchForProject', 'projectID', projectID)
            // verify required parameter 'branchID' is not null or undefined
            assertParamExists('deleteBranchForProject', 'branchID', branchID)
            const localVarPath = `/projects/{projectID}/branches/{branchID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"branchID"}}`, encodeURIComponent(String(branchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a project.
         * @param {string} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (projectID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('deleteProject', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific branch for a project.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranchForProject: async (projectID: string, branchID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getBranchForProject', 'projectID', projectID)
            // verify required parameter 'branchID' is not null or undefined
            assertParamExists('getBranchForProject', 'branchID', branchID)
            const localVarPath = `/projects/{projectID}/branches/{branchID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"branchID"}}`, encodeURIComponent(String(branchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific project.
         * @param {string} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (projectID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('getProject', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of branches for a project.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBranchesForProject: async (projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('listBranchesForProject', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}/branches`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of projects.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects: async (pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the project.
         * @param {string} projectID 
         * @param {UpdateProjectRequest} [updateProjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (projectID: string, updateProjectRequest?: UpdateProjectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectID' is not null or undefined
            assertParamExists('updateProject', 'projectID', projectID)
            const localVarPath = `/projects/{projectID}`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["projects:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a branch for a project.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {Branch} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBranchForProject(projectID: string, branch?: Branch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBranchForProject(projectID, branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a project.  ID should be omitted and will be returned in the response.
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(project?: Project, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(project, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a branch for a project.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBranchForProject(projectID: string, branchID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBranchForProject(projectID, branchID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a project.
         * @param {string} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(projectID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(projectID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific branch for a project.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBranchForProject(projectID: string, branchID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBranchForProject(projectID, branchID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific project.
         * @param {string} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(projectID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projectID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of branches for a project.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBranchesForProject(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBranchesForProject200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBranchesForProject(projectID, pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of projects.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjects(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProjects200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the project.
         * @param {string} projectID 
         * @param {UpdateProjectRequest} [updateProjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(projectID: string, updateProjectRequest?: UpdateProjectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(projectID, updateProjectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Adds a branch for a project.  ID should be omitted and will be returned in the response.
         * @param {string} projectID 
         * @param {Branch} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBranchForProject(projectID: string, branch?: Branch, options?: any): AxiosPromise<Branch> {
            return localVarFp.createBranchForProject(projectID, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a project.  ID should be omitted and will be returned in the response.
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(project?: Project, options?: any): AxiosPromise<Project> {
            return localVarFp.createProject(project, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a branch for a project.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranchForProject(projectID: string, branchID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBranchForProject(projectID, branchID, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a project.
         * @param {string} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(projectID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProject(projectID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific branch for a project.
         * @param {string} projectID 
         * @param {string} branchID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranchForProject(projectID: string, branchID: string, options?: any): AxiosPromise<Branch> {
            return localVarFp.getBranchForProject(projectID, branchID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific project.
         * @param {string} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectID: string, options?: any): AxiosPromise<Project> {
            return localVarFp.getProject(projectID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of branches for a project.
         * @param {string} projectID 
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBranchesForProject(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListBranchesForProject200Response> {
            return localVarFp.listBranchesForProject(projectID, pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of projects.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListProjects200Response> {
            return localVarFp.listProjects(pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the project.
         * @param {string} projectID 
         * @param {UpdateProjectRequest} [updateProjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(projectID: string, updateProjectRequest?: UpdateProjectRequest, options?: any): AxiosPromise<Project> {
            return localVarFp.updateProject(projectID, updateProjectRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * Adds a branch for a project.  ID should be omitted and will be returned in the response.
     * @param {string} projectID 
     * @param {Branch} [branch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createBranchForProject(projectID: string, branch?: Branch, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createBranchForProject(projectID, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a project.  ID should be omitted and will be returned in the response.
     * @param {Project} [project] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProject(project?: Project, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createProject(project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a branch for a project.
     * @param {string} projectID 
     * @param {string} branchID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteBranchForProject(projectID: string, branchID: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteBranchForProject(projectID, branchID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a project.
     * @param {string} projectID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProject(projectID: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteProject(projectID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific branch for a project.
     * @param {string} projectID 
     * @param {string} branchID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getBranchForProject(projectID: string, branchID: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getBranchForProject(projectID, branchID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific project.
     * @param {string} projectID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProject(projectID: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getProject(projectID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of branches for a project.
     * @param {string} projectID 
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listBranchesForProject(projectID: string, pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listBranchesForProject(projectID, pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of projects.
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjects(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listProjects(pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the project.
     * @param {string} projectID 
     * @param {UpdateProjectRequest} [updateProjectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProject(projectID: string, updateProjectRequest?: UpdateProjectRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).updateProject(projectID, updateProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SandboxApi - axios parameter creator
 * @export
 */
export const SandboxApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Destroys a sandbox environment.
         * @param {DestroySandboxRequest} [destroySandboxRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySandbox: async (destroySandboxRequest?: DestroySandboxRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sandbox/:destroy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sandbox:destroy"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sandbox:destroy"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sandbox:destroy"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destroySandboxRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initializes a sandbox environment.
         * @param {DestroySandboxRequest} [destroySandboxRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupSandbox: async (destroySandboxRequest?: DestroySandboxRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sandbox/:setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sandbox:setup"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sandbox:setup"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["sandbox:setup"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destroySandboxRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SandboxApi - functional programming interface
 * @export
 */
export const SandboxApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SandboxApiAxiosParamCreator(configuration)
    return {
        /**
         * Destroys a sandbox environment.
         * @param {DestroySandboxRequest} [destroySandboxRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroySandbox(destroySandboxRequest?: DestroySandboxRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroySandbox(destroySandboxRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initializes a sandbox environment.
         * @param {DestroySandboxRequest} [destroySandboxRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setupSandbox(destroySandboxRequest?: DestroySandboxRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setupSandbox(destroySandboxRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SandboxApi - factory interface
 * @export
 */
export const SandboxApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SandboxApiFp(configuration)
    return {
        /**
         * Destroys a sandbox environment.
         * @param {DestroySandboxRequest} [destroySandboxRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySandbox(destroySandboxRequest?: DestroySandboxRequest, options?: any): AxiosPromise<void> {
            return localVarFp.destroySandbox(destroySandboxRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Initializes a sandbox environment.
         * @param {DestroySandboxRequest} [destroySandboxRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupSandbox(destroySandboxRequest?: DestroySandboxRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setupSandbox(destroySandboxRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SandboxApi - object-oriented interface
 * @export
 * @class SandboxApi
 * @extends {BaseAPI}
 */
export class SandboxApi extends BaseAPI {
    /**
     * Destroys a sandbox environment.
     * @param {DestroySandboxRequest} [destroySandboxRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandboxApi
     */
    public destroySandbox(destroySandboxRequest?: DestroySandboxRequest, options?: AxiosRequestConfig) {
        return SandboxApiFp(this.configuration).destroySandbox(destroySandboxRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initializes a sandbox environment.
     * @param {DestroySandboxRequest} [destroySandboxRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandboxApi
     */
    public setupSandbox(destroySandboxRequest?: DestroySandboxRequest, options?: AxiosRequestConfig) {
        return SandboxApiFp(this.configuration).setupSandbox(destroySandboxRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ViewApi - axios parameter creator
 * @export
 */
export const ViewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new View session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createViewSession: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/view/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds an update to the View session.  Updates will be serialized sequentially by ID.
         * @param {string} viewSessionID 
         * @param {number} viewUpdateID 
         * @param {File} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createViewUpdate: async (viewSessionID: string, viewUpdateID: number, body?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewSessionID' is not null or undefined
            assertParamExists('createViewUpdate', 'viewSessionID', viewSessionID)
            // verify required parameter 'viewUpdateID' is not null or undefined
            assertParamExists('createViewUpdate', 'viewUpdateID', viewUpdateID)
            const localVarPath = `/view/sessions/{viewSessionID}/updates/{viewUpdateID}`
                .replace(`{${"viewSessionID"}}`, encodeURIComponent(String(viewSessionID)))
                .replace(`{${"viewUpdateID"}}`, encodeURIComponent(String(viewUpdateID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:write"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the view object and metadata associated with a specific view.
         * @param {string} viewSessionID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewSession: async (viewSessionID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewSessionID' is not null or undefined
            assertParamExists('getViewSession', 'viewSessionID', viewSessionID)
            const localVarPath = `/view/sessions/{viewSessionID}`
                .replace(`{${"viewSessionID"}}`, encodeURIComponent(String(viewSessionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all View sessions.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViewSessions: async (pageSize?: number, pageToken?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/view/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:read"], configuration)

            // authentication OAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth", ["view:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewApi - functional programming interface
 * @export
 */
export const ViewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ViewApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new View session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createViewSession(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createViewSession(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds an update to the View session.  Updates will be serialized sequentially by ID.
         * @param {string} viewSessionID 
         * @param {number} viewUpdateID 
         * @param {File} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createViewUpdate(viewSessionID: string, viewUpdateID: number, body?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateViewUpdate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createViewUpdate(viewSessionID, viewUpdateID, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the view object and metadata associated with a specific view.
         * @param {string} viewSessionID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getViewSession(viewSessionID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetViewSession200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getViewSession(viewSessionID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all View sessions.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listViewSessions(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListViewSessions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listViewSessions(pageSize, pageToken, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ViewApi - factory interface
 * @export
 */
export const ViewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ViewApiFp(configuration)
    return {
        /**
         * Creates a new View session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createViewSession(options?: any): AxiosPromise<string> {
            return localVarFp.createViewSession(options).then((request) => request(axios, basePath));
        },
        /**
         * Adds an update to the View session.  Updates will be serialized sequentially by ID.
         * @param {string} viewSessionID 
         * @param {number} viewUpdateID 
         * @param {File} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createViewUpdate(viewSessionID: string, viewUpdateID: number, body?: File, options?: any): AxiosPromise<CreateViewUpdate201Response> {
            return localVarFp.createViewUpdate(viewSessionID, viewUpdateID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the view object and metadata associated with a specific view.
         * @param {string} viewSessionID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewSession(viewSessionID: string, options?: any): AxiosPromise<GetViewSession200Response> {
            return localVarFp.getViewSession(viewSessionID, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all View sessions.
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViewSessions(pageSize?: number, pageToken?: string, orderBy?: string, options?: any): AxiosPromise<ListViewSessions200Response> {
            return localVarFp.listViewSessions(pageSize, pageToken, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ViewApi - object-oriented interface
 * @export
 * @class ViewApi
 * @extends {BaseAPI}
 */
export class ViewApi extends BaseAPI {
    /**
     * Creates a new View session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewApi
     */
    public createViewSession(options?: AxiosRequestConfig) {
        return ViewApiFp(this.configuration).createViewSession(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds an update to the View session.  Updates will be serialized sequentially by ID.
     * @param {string} viewSessionID 
     * @param {number} viewUpdateID 
     * @param {File} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewApi
     */
    public createViewUpdate(viewSessionID: string, viewUpdateID: number, body?: File, options?: AxiosRequestConfig) {
        return ViewApiFp(this.configuration).createViewUpdate(viewSessionID, viewUpdateID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the view object and metadata associated with a specific view.
     * @param {string} viewSessionID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewApi
     */
    public getViewSession(viewSessionID: string, options?: AxiosRequestConfig) {
        return ViewApiFp(this.configuration).getViewSession(viewSessionID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all View sessions.
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewApi
     */
    public listViewSessions(pageSize?: number, pageToken?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return ViewApiFp(this.configuration).listViewSessions(pageSize, pageToken, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}



